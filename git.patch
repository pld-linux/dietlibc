diff -urN -x .git dietlibc-0.33/alpha/Makefile.add dietlibc/alpha/Makefile.add
--- dietlibc-0.33/alpha/Makefile.add	2012-01-24 18:24:24.000000000 +0000
+++ dietlibc/alpha/Makefile.add	2015-01-01 12:14:43.454938895 +0000
@@ -3,3 +3,5 @@
 VPATH:=alpha:syscalls.s:$(VPATH)
 
 LIBOBJ+=$(patsubst %,$(OBJDIR)/%,divq.o divl.o remq.o reml.o __time.o __alarm.o __CAS.o)
+
+$(OBJDIR)/__pause.o: include/signal.h
diff -urN -x .git dietlibc-0.33/alpha/start.S dietlibc/alpha/start.S
--- dietlibc-0.33/alpha/start.S	2006-05-29 16:30:53.000000000 +0000
+++ dietlibc/alpha/start.S	2015-01-01 12:14:43.454938895 +0000
@@ -24,6 +24,15 @@
 
 	stq	$18, environ
 
+#ifdef WANT_ELFINFO
+#  warning "MAKE ME alpha ASSEMBLER!"
+1:	ldq	$19, $18	; load *envp into $19
+	addq	$18,  1,  $18	; increment *envp
+	orr	$19, $19, $19
+	jne	1b
+	stq	$18, __elfinfo
+#endif
+
 #ifdef WANT_DYNAMIC
 /* in v0 ($0) is the ld.so _fini pointer */
 	mov	 $0, $19	/* mov v0(dynload) to a3 */
diff -urN -x .git dietlibc-0.33/alpha/syscalls.h dietlibc/alpha/syscalls.h
--- dietlibc-0.33/alpha/syscalls.h	2008-05-06 17:18:34.000000000 +0000
+++ dietlibc/alpha/syscalls.h	2015-01-01 12:14:43.454938895 +0000
@@ -412,7 +412,38 @@
 #define __NR_signalfd			476
 #define __NR_timerfd			477
 #define __NR_eventfd			478
-
+#define __NR_recvmmsg			479
+#define __NR_fallocate			480
+#define __NR_timerfd_create		481
+#define __NR_timerfd_settime		482
+#define __NR_timerfd_gettime		483
+#define __NR_signalfd4			484
+#define __NR_eventfd2			485
+#define __NR_epoll_create1		486
+#define __NR_dup3			487
+#define __NR_pipe2			488
+#define __NR_inotify_init1		489
+#define __NR_preadv			490
+#define __NR_pwritev			491
+#define __NR_rt_tgsigqueueinfo		492
+#define __NR_perf_event_open		493
+#define __NR_fanotify_init		494
+#define __NR_fanotify_mark		495
+#define __NR_prlimit64			496
+#define __NR_name_to_handle_at		497
+#define __NR_open_by_handle_at		498
+#define __NR_clock_adjtime		499
+#define __NR_syncfs			500
+#define __NR_setns			501
+#define __NR_accept4			502
+#define __NR_sendmmsg			503
+#define __NR_process_vm_readv		504
+#define __NR_process_vm_writev		505
+#define __NR_kcmp			506
+#define __NR_finit_module		507
+#define __NR_sched_setattr		508
+#define __NR_sched_getattr		509
+#define __NR_renameat2			510
 
 #define syscall_weak(name,wsym,sym) \
 .text ; \
diff -urN -x .git dietlibc-0.33/arm/__aeabi_read_tp.S dietlibc/arm/__aeabi_read_tp.S
--- dietlibc-0.33/arm/__aeabi_read_tp.S	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/arm/__aeabi_read_tp.S	2015-01-01 12:14:43.454938895 +0000
@@ -0,0 +1,13 @@
+#include "arm-features.h"
+
+FUNC_START __aeabi_read_tp
+
+#if __ARM_ARCH__ < 6
+	mvn     r0, #0xf000
+	sub     pc, r0, #31
+#else
+	mrc     15, 0, r0, cr13, cr0, 3
+	bx      lr
+#endif
+
+FUNC_END __aeabi_read_tp
diff -urN -x .git dietlibc-0.33/arm/__aeabi_unwind_cpp.S dietlibc/arm/__aeabi_unwind_cpp.S
--- dietlibc-0.33/arm/__aeabi_unwind_cpp.S	2008-04-11 22:51:11.000000000 +0000
+++ dietlibc/arm/__aeabi_unwind_cpp.S	2015-01-01 12:14:43.454938895 +0000
@@ -1,21 +1,14 @@
-.text
-.global __aeabi_unwind_cpp_pr0
-.hidden __aeabi_unwind_cpp_pr0
-.type __aeabi_unwind_cpp_pr0, %function
+#include "arm-features.h"
 
-.global __aeabi_unwind_cpp_pr1
+FUNC_START __aeabi_unwind_cpp_pr0
+FUNC_START __aeabi_unwind_cpp_pr1
+FUNC_START __aeabi_unwind_cpp_pr2
+.hidden __aeabi_unwind_cpp_pr0
 .hidden __aeabi_unwind_cpp_pr1
-.type __aeabi_unwind_cpp_pr1, %function
-
-.global __aeabi_unwind_cpp_pr2
 .hidden __aeabi_unwind_cpp_pr2
-.type __aeabi_unwind_cpp_pr2, %function
 
-__aeabi_unwind_cpp_pr0:
-__aeabi_unwind_cpp_pr1:
-__aeabi_unwind_cpp_pr2:
-	mov	pc, lr	@ return from subroutine
+	RET
 
-.size __aeabi_unwind_cpp_pr0,.-__aeabi_unwind_cpp_pr0
-.size __aeabi_unwind_cpp_pr1,.-__aeabi_unwind_cpp_pr1
-.size __aeabi_unwind_cpp_pr2,.-__aeabi_unwind_cpp_pr2
+FUNC_END  __aeabi_unwind_cpp_pr2
+FUNC_END  __aeabi_unwind_cpp_pr1
+FUNC_END  __aeabi_unwind_cpp_pr0
diff -urN -x .git dietlibc-0.33/arm/arm-features.h dietlibc/arm/arm-features.h
--- dietlibc-0.33/arm/arm-features.h	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/arm/arm-features.h	2015-01-01 12:14:43.454938895 +0000
@@ -0,0 +1,110 @@
+/* --*- asm -*-- */
+
+#ifndef H_DIETLIBC_ARM_FEATURES_H
+#define H_DIETLIBC_ARM_FEATURES_H
+
+/* Stolen from gcc (gcc/config/arm/lib1funcs.asm) */
+#if defined(__ARM_ARCH_2__)
+# define __ARM_ARCH__ 2
+#endif
+
+#if defined(__ARM_ARCH_3__)
+# define __ARM_ARCH__ 3
+#endif
+
+#if defined(__ARM_ARCH_3M__) || defined(__ARM_ARCH_4__) \
+        || defined(__ARM_ARCH_4T__)
+# define __ARM_ARCH__ 4
+#endif
+
+#if defined(__ARM_ARCH_5__) || defined(__ARM_ARCH_5T__) \
+        || defined(__ARM_ARCH_5E__) || defined(__ARM_ARCH_5TE__) \
+        || defined(__ARM_ARCH_5TEJ__)
+# define __ARM_ARCH__ 5
+#endif
+
+#if defined(__ARM_ARCH_6__) || defined(__ARM_ARCH_6J__) \
+        || defined(__ARM_ARCH_6K__) || defined(__ARM_ARCH_6Z__) \
+        || defined(__ARM_ARCH_6ZK__) || defined(__ARM_ARCH_6T2__) \
+        || defined(__ARM_ARCH_6M__)
+# define __ARM_ARCH__ 6
+#endif
+
+#if defined(__ARM_ARCH_7__) || defined(__ARM_ARCH_7A__) \
+        || defined(__ARM_ARCH_7R__) || defined(__ARM_ARCH_7M__)
+# define __ARM_ARCH__ 7
+#endif
+
+#ifndef __ARM_ARCH__
+#error Unable to determine architecture.
+#endif
+
+#define DIET_JMPBUFSZ_REGS_REGULAR	10*32/8	/* r4-r11, sp, pc */
+#define DIET_JMPBUFSZ_REGS_FPv4		16*64/8 /* d0-d15 */
+
+#if !defined(__SOFTFP__) || defined(__IWMMXT__)
+#  define DIET_HAVE_COPROC_REGS	1
+#else
+#  undef  DIET_HAVE_COPROC_REGS
+#endif
+
+#ifdef __ASSEMBLER__
+
+.macro	FUNC_START name
+	.text
+	.align	0
+	.global	\name
+	.type	\name, %function
+\name:
+.endm
+
+.macro	FUNC_START_WEAK name
+	.text
+	.align	0
+	.weak	\name
+	.type	\name, %function
+\name:
+.endm
+
+.macro	FUNC_END name
+	.size	\name, . - \name
+.endm
+
+.macro	RET
+#if (__ARM_ARCH__ > 4) || defined(__ARM_ARCH_4T__)
+	bx	lr
+#else
+	mov	pc, lr
+#endif
+.endm
+
+.macro	SWI_UNIFIED	name
+#ifdef __ARM_EABI__
+	b	__unified_syscall_swi
+#else
+	swi	\name
+	b	__unified_syscall
+#endif
+.endm
+
+.macro	SWI_UNIFIED4
+#ifdef __ARM_EABI__
+	b	__unified_syscall_swi
+#else
+	swi	\name
+	b	__unified_syscall4
+#endif
+.endm
+
+.macro	LOAD_ARG4_5
+#if defined(__ARM_ARCH_4__) || defined(__ARM_ARCH_4T__) || defined(__ARM_ARCH_5T__)
+	ldr	r4, [sp,#16]
+	ldr	r5, [sp,#20]
+#else
+	ldrd	r4, [sp,#16]
+#endif
+.endm
+
+#endif	/* __ASSEMBLER__ */
+
+#endif	/* H_DIETLIBC_ARM_FEATURES_H */
diff -urN -x .git dietlibc-0.33/arm/arm_set_tls.S dietlibc/arm/arm_set_tls.S
--- dietlibc-0.33/arm/arm_set_tls.S	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/arm/arm_set_tls.S	2015-01-01 12:14:43.454938895 +0000
@@ -0,0 +1,27 @@
+#include "syscalls.h"
+#include "arm-features.h"
+
+#ifdef __ARM_EABI__
+
+@ Calling convention:
+@   r0 ... thread data
+@ Returns:
+@   r0 ... low-level error code
+FUNC_START	__arm_set_tls
+	mov	ip, r7
+	ldr	r7, =__ARM_NR_set_tls
+	swi	0
+	mov	r7, ip
+
+	@ we do not have much options here to handle errors because
+	@ errno might not be available yet. Return error code as-is
+	@ and let it handle by the caller
+
+	RET
+FUNC_END	__arm_set_tls
+
+#else
+
+#warning "setup-tls only implemented for ARM_EABI!"
+
+#endif
diff -urN -x .git dietlibc-0.33/arm/clone.S dietlibc/arm/clone.S
--- dietlibc-0.33/arm/clone.S	2008-12-10 20:00:58.000000000 +0000
+++ dietlibc/arm/clone.S	2015-01-01 12:14:43.454938895 +0000
@@ -1,11 +1,7 @@
-
 #include <errno.h>
 #include "syscalls.h"
+#include "arm-features.h"
 
-	.text
-	.weak 	clone
-	.global __clone
-	
 @
 @ Some slightly tricky stuff here... edit with care :-)
 @
@@ -15,13 +11,12 @@
 
 #define CLONE_VM      0x00000100
 #define CLONE_THREAD  0x00010000
-	
+
 @ ;  don't do this yet
 @#define RESET_PID
 
-		
-clone:
-__clone:
+FUNC_START_WEAK	clone
+FUNC_START	__clone
 	@ ; start with a sanity check
 	cmp	r0, #0
 	cmpne	r1, #0
@@ -31,13 +26,13 @@
 	@ ; insert args into stack
 	str	r3, [r1, #-4]!
 	str	r0, [r1, #-4]!
-	
+
 	@ ; do the system call
 	@ ; get the flags
 	mov	r0, r2
-#ifdef RESET_PID	
+#ifdef RESET_PID
 	mov	ip, r2
-#endif	
+#endif
 	@ ; child sp is already in r1
 	stmfd	sp!, {r4, r7}
 	@stmdb	sp!, {r4, r7}
@@ -46,14 +41,14 @@
 	ldr	r4, [sp, #16]
         ldr     r7, =__NR_clone
 	swi	0
-	
+
 	cmp	r0, #0
 	beq	1f
-	ldmfd	sp!, {r4, r7}	
+	ldmfd	sp!, {r4, r7}
 	blt	__unified_syscall	@ (return code < 0): handle as an error
-	bx	lr
-1:	
-#ifdef RESET_PID		
+	RET
+1:
+#ifdef RESET_PID
 	tst	ip, #CLONE_THREAD
 	bne	3f
 
@@ -67,21 +62,22 @@
 	swi	0
 	str	r0, [r1, #PID_OFFSET] @	; not defined yet ??
 	str	r0, [r1, #TID_OFFSET] @	; not defined yet ??
-3:	
+3:
 #endif
 	@ ; pick the function arg and call address off the stack and execute
 	ldr	r0, [sp, #4]
 	mov	lr, pc
 	ldr	pc, [sp], #8
-	
+
 	@ ; and we're done, passing return value through r0
 	b	_exit			@ branch to _exit (PIC safe)
+FUNC_END	__clone
+FUNC_END	clone
 
-	
 #else
-		
-clone:
-__clone:
+
+FUNC_START_WEAK	clone
+FUNC_START	__clone
 	movs	r12, r0			@ check function pointer
 	cmpne	r1, #0			@ if function check for stack pointer
 	moveq	r0, #-EINVAL		@ if one is not available set errno value
@@ -101,5 +97,7 @@
 	ldmia	sp!, { r0, pc } 	@ load function param and jump to thread function
 
 1:	b	_exit			@ branch to _exit (PIC safe)
+FUNC_END	__clone
+FUNC_END	clone
 
 #endif
diff -urN -x .git dietlibc-0.33/arm/dyn_syscalls.S dietlibc/arm/dyn_syscalls.S
--- dietlibc-0.33/arm/dyn_syscalls.S	2012-01-24 18:24:24.000000000 +0000
+++ dietlibc/arm/dyn_syscalls.S	2015-01-01 12:14:43.454938895 +0000
@@ -3,16 +3,21 @@
  * Olaf Dreesen
  */
 
+#include "arm-features.h"
+
 #include "../syscalls.s/environ.S"
 #include "../syscalls.s/errno.S"
 
 #include <dietfeatures.h>
 #include "syscalls.h"
 
-.text
-__unified_syscall4:
+#ifdef __ARM_EABI__
+# error "dyn_syscall.S not ported for EABI yet"
+#endif
+
+FUNC_START	__unified_syscall4
 	ldmfd	sp!, {r4, r5, r6}
-__unified_syscall:
+FUNC_START	__unified_syscall
 	cmn	r0, #4096
 	movcc	pc, lr
 	rsb	r1, r0, #0
@@ -25,7 +30,9 @@
 
 	mvn	r0, #0
 #include "dietuglyweaks.h"
-	mov	pc, lr
+	RET
+FUNC_END	__unified_syscall
+FUNC_END	__unified_syscall4
 
 /* ok now include all syscalls.s (*.S) and sysdep *.S */
 #include "mmap.S"
@@ -104,7 +111,6 @@
 #include "../syscalls.s/n_sigprocmask.S"
 #include "../syscalls.s/n_sigsuspend.S"
 #include "../syscalls.s/nanosleep.S"
-#include "../syscalls.s/nice.S"
 #include "../syscalls.s/open.S"
 #include "../syscalls.s/pause.S"
 #include "../syscalls.s/personality.S"
@@ -280,9 +286,11 @@
 #include "../syscalls.s/fgetxattr.S"
 
 /* other asm-files w.o. changes ... */
-__exit:
+FUNC_START	__exit
 	swi	$__NR_exit
 	eor	pc,lr,lr
+FUNC_END	__exit
+
 #define _exit __exit
 #include "clone.S"
 #undef _exit
diff -urN -x .git dietlibc-0.33/arm/__fadvise.c dietlibc/arm/__fadvise.c
--- dietlibc-0.33/arm/__fadvise.c	2011-03-03 18:40:05.000000000 +0000
+++ dietlibc/arm/__fadvise.c	2015-01-01 12:14:43.454938895 +0000
@@ -1,5 +1,7 @@
-#include <fcntl.h>
 #include "syscalls.h"
+#define _LINUX_SOURCE
+#include <fcntl.h>
+#include <unistd.h>
 
 #ifndef __NR_fadvise64
 long fadvise64_64(int fd, off64_t offset, off64_t len, int advice)
diff -urN -x .git dietlibc-0.33/arm/__guard.S dietlibc/arm/__guard.S
--- dietlibc-0.33/arm/__guard.S	2006-06-21 19:55:25.000000000 +0000
+++ dietlibc/arm/__guard.S	2015-01-01 12:14:43.454938895 +0000
@@ -1,4 +1,5 @@
 .data
+.align 2
 .type __guard,#object
 .global __guard
 .type __stack_chk_guard,#object
@@ -7,3 +8,5 @@
 __stack_chk_guard:
 .long 0xaff00
 
+.size __guard, . - __guard
+.size __stack_chk_guard, . - __stack_chk_guard
diff -urN -x .git dietlibc-0.33/arm/__longjmp.S dietlibc/arm/__longjmp.S
--- dietlibc-0.33/arm/__longjmp.S	2001-07-02 16:06:48.000000000 +0000
+++ dietlibc/arm/__longjmp.S	2015-01-01 12:14:43.454938895 +0000
@@ -1,11 +1,23 @@
-.text
-.global __longjmp
-.type __longjmp,function
-__longjmp:
+#include "arm-features.h"
+
+FUNC_START	__longjmp
 	mov	ip, r0
 	movs	r0, r1
 	moveq	r0, #1
-#ifndef	__SOFTFP__
-	lfm	f4, 4, [ip], #48
+#ifndef __SOFTFP__
+# if __ARM_ARCH__ == 7
+	vldm	ip!, {d0-d15}
+#   ifdef __ARM_NEON__
+	vldm	ip!, {d16-d31}
+#   endif
+# else
+	lfm	f4, 4, [ip]!
+# endif
 #endif
-	ldmia   ip, {r4-r11, sp, pc}
+
+#ifdef __IWMMXT__
+#  warning "sigjmp will not restore iwmmxt coprocessor registers"
+#endif
+
+	ldmia   ip!, {r4-r11, sp, pc}
+FUNC_END	__longjmp
diff -urN -x .git dietlibc-0.33/arm/Makefile.add dietlibc/arm/Makefile.add
--- dietlibc-0.33/arm/Makefile.add	2012-01-24 18:24:24.000000000 +0000
+++ dietlibc/arm/Makefile.add	2015-01-01 12:14:43.454938895 +0000
@@ -1,6 +1,7 @@
 
 LIBOBJ+=$(OBJDIR)/md5asm.o $(OBJDIR)/__aeabi_unwind_cpp.o
 LIBOBJ+=$(OBJDIR)/__fadvise.o $(OBJDIR)/arm_fadvise.o
+LIBOBJ+=$(OBJDIR)/__aeabi_read_tp.o $(OBJDIR)/arm_set_tls.o
 CFLAGS+=-Os -fomit-frame-pointer -fstrict-aliasing
 #ifdef __ARM_EABI__
 #CFLAGS+=-mabi=aapcs-linux -mno-thumb-interwork
diff -urN -x .git dietlibc-0.33/arm/mcount.S dietlibc/arm/mcount.S
--- dietlibc-0.33/arm/mcount.S	2002-05-09 03:50:17.000000000 +0000
+++ dietlibc/arm/mcount.S	2015-01-01 12:14:43.454938895 +0000
@@ -1,4 +1,4 @@
-
+#include "arm-features.h"
 @
 @ mcount.S: ARM assembler implementation of mcount
 @
@@ -27,11 +27,7 @@
 @
 @
 
-.text
-
-.global mcount
-
-mcount:
+FUNC_START	mcount
     mov     ip,  sp
     stmdb   sp!, { r0 - r3, fp, ip, lr, pc }    @ build stack frame
     sub     fp,  ip, #4                         @ setup new fp
@@ -43,4 +39,4 @@
     bl      __mcount                            @ call __mcount
 
     ldmdb   fp,  { r0 - r3, fp, sp, pc }        @ restore context from stack frame and return.
-
+FUNC_END	mcount
diff -urN -x .git dietlibc-0.33/arm/md5asm.S dietlibc/arm/md5asm.S
--- dietlibc-0.33/arm/md5asm.S	2008-12-10 20:00:58.000000000 +0000
+++ dietlibc/arm/md5asm.S	2015-01-01 12:14:43.454938895 +0000
@@ -1,400 +1,394 @@
-/*****************************************************************************
-* Copyright (C) 2002 Andre McCurdy  <armccurdy@yahoo.co.uk>
-*
-* "derived from the RSA Data Security, Inc. MD5 Message-Digest Algorithm"
-*
-* This program is free software. you can redistribute it and/or modify
-* it under the terms of the GNU General Public License as published by
-* the Free Software Foundation; either version 2 of the License, or
-* (at your option) any later version.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY, without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
-*
-******************************************************************************
-*
-* History:
-*
-* 2002/02/12:  Andre McCurdy <armccurdy@yahoo.co.uk>
-*   - Original created.
-*
-* 2002/02/13:  Andre McCurdy <armccurdy@yahoo.co.uk>
-*   - Rewrote MD5Update in assembler (saves 52 bytes).
-*   - Added guard so we don't compile anything for Big-Endian targets.
-*
-* 2002/02/22:  Andre McCurdy <armccurdy@yahoo.co.uk>
-*   - Added new function MD5Update (a wrapper for the original version) which
-*     checks for correct 32bit alignment of the input data pointer.
-*   - Original MD5Update function renamed __MD5Update.
-*   - __MD5Transform symbol no longer exported.
-*
-* 2002/02/25:  Andre McCurdy <armccurdy@yahoo.co.uk>
-*   - MD5Update re-written in assembler (saves 12 bytes + lots of cycles :-)
-*
-* 2002/03/07:  Andre McCurdy <armccurdy@yahoo.co.uk>
-*   - _Finally_ fixed hashing from an unaligned buffer in all cases :-)
-*
-******************************************************************************
-*
-* Notes:
-*
-* This code is believed to be Position Independent (ie can be safely used
-* as part of a shared library).
-*
-*****************************************************************************/
-
-#include <endian.h>
-
-#if (__BYTE_ORDER == __LITTLE_ENDIAN)
-
-   .global MD5Init
-   .global MD5Update
-
-   .text
-#ifdef __ARM_EABI__
-   .align  4
-#else		
-   .align  2
-#endif
-	
-    @ --
-    @ void MD5Init (MD5_CTX* context);
-    @ --
-
-MD5Init:
-
-    adr     r1, 1f                          @ r1 = base address of MD5InitData array
-    ldmia   r1, { r1 - r3, r12 }            @ load 4 elements from MD5InitData array
-    stmia   r0, { r1 - r3, r12 }            @ store into MD5 context->state[0..3]
-    mov     r1, #0
-    str     r1, [r0, #0x10]                 @ initial count[0] = 0
-    str     r1, [r0, #0x14]                 @ initial count[1] = 0
-    mov     pc, lr                          @ return
-
-1: .word    0x67452301                      @ initial MD5 context->state[0]
-   .word    0xefcdab89                      @ initial MD5 context->state[1]
-   .word    0x98badcfe                      @ initial MD5 context->state[2]
-   .word    0x10325476                      @ initial MD5 context->state[3]
-
-
-    @ --
-    @ void MD5Update (MD5_CTX* context, const uint8_t* buf, signed int len);
-    @ --
-
-MD5Update:
-
-    stmdb   sp!, { r4 - r8, lr }
-    add     r4, r0, #(6 * 4)                @ r4 = &context->buffer[0]
-    ldmdb   r4, { r0, r3 }                  @ r0 = count[0], r3 = count[1]
-    mov     r5, r1                          @ r5 = input
-    mov     r6, r0, lsr #3                  @ r6 = (context->count[0] >> 3)
-    and     r6, r6, #0x3f                   @ r6 = byteIndex = ((context->count[0] >> 3) & 0x3f)
-    adds    r0, r0, r2, lsl #3
-    adc     r3, r3, r2, lsr #29
-    stmdb   r4, { r0, r3 }                  @ context->count += (inputBytes * 8)
-    rsb     r7, r6, #64                     @ r7 = (64 - byteIndex) == partLen
-    subs    r8, r2, r7                      @ r8 = (inputBytes - partLen)
-    add     r0, r4, r6
-    bcc     2f
-    mov     r2, r7
-    bl      memcpy                          @ memcpy (&context->buffer[byteIndex], input, partLen);
-    sub     r0, r4, #(6 * 4)
-    mov     r1, r4
-    mov     r2, #1
-    bl      __MD5Transform                  @ __MD5Transform (context->state, context->buffer, 1);
-    sub     r0, r4, #(6 * 4)
-    add     r1, r5, r7
-    mov     r2, r8, lsr #6                  @ r2 = len = ((inputBytes - partLen) / 64)
-    tst     r1, #3                          @ if (input & 0x03)
-    adr     lr, 1f
-    beq     __MD5Transform                  @ __MD5Transform (context->state, &input[partLen], len);
-    bne     __UnalignedMD5Transform         @ else __UnalignedMD5Transform (context->state, &input[partLen], len);
-1:  mov     r0, r4
-    bic     r2, r8, #0x3f
-    add     r1, r2, r7
-    add     r1, r1, r5
-    sub     r2, r8, r2
-2:  ldmia   sp!, { r4 - r8, lr }
-    b       memcpy                          @ classic tail-call optimisation...
-
-
-    @ --
-    @ static void __MD5Transform (uint32_t *buf, const uint32_t *in, int repeat);
-    @ --
-
-MD5MagicData:
-
-1: .word     0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee
-   .word     0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501, ( 3f- 4f-4)
-   .word     0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be, ( 3f- 4f-4)
-   .word     0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821, ( 3f- 4f-4)
-   .word     0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa, ( 4f- 4f-4)
-   .word     0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8, ( 5f- 9f-4)
-   .word     0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, ( 6f- 9f-4)
-   .word     0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a, ( 7f- 9f-4)
-   .word     0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c, ( 9f- 9f-4)
-   .word     0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70, (10f-14f-4)
-   .word     0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05, (11f-14f-4)
-   .word     0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665, (12f-14f-4)
-   .word     0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, (14f-14f-4)
-   .word     0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1, (15f-19f-4)
-   .word     0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1, (16f-19f-4)
-   .word     0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391, (17f-19f-4)
-   .word     0x6e4120A9, 0x20657264, 0x7543634d, 0x00796472, (19f-19f-4)
-
-__MD5Transform:
-
-    cmp     r2, #0
-    moveq   pc, lr                          @ return if (repeat == 0)
-    stmdb   sp!, { r0, r2, r4 - r11, lr }   @ stack 'buf', 'repeat' and all callee saved registers
-    ldmia   r0,  { r2 - r5 }                @ r2 = a, r3 = b, r4 = c, r5 = d
-2:  adr     r0, 1b                          @ r0 = base address of MD5MagicData
-    ldmia   r0!, { r6 - r9 }                @ load first 4 elements from MD5MagicData
-3:  ldmia   r1!, { r10 - r12, lr }          @ r10 = in[i], r11 = in[i+1], r12 = in[i+2], lr = in[i+3]
-
-    add     r10, r10, r6                    @ r10 = in[i] + MD5MagicData[i]
-    eor     r6, r4, r5                      @ r6  =   (c ^ d)
-    and     r6, r6, r3                      @ r6  =  ((c ^ d) & b)
-    eor     r6, r6, r5                      @ r6  = (((c ^ d) & b) ^ d)
-    add     r2, r2, r6                      @ a   = (((c ^ d) & b) ^ d) + a
-    add     r2, r2, r10                     @ a   = (((c ^ d) & b) ^ d) + a + (in[i] + MD5MagicData[i])
-    add     r2, r3, r2, ROR #(32 -  7)      @ a   = b + (a rotated left by  7 places)
-
-    add     r11, r11, r7                    @ r11 = in[i+1] + MD5MagicData[i+1]
-    eor     r7, r3, r4                      @ r7  =   (b ^ c)
-    and     r7, r7, r2                      @ r7  =  ((b ^ c) & a)
-    eor     r7, r7, r4                      @ r7  = (((b ^ c) & a) ^ c)
-    add     r5, r5, r7                      @ d   = (((b ^ c) & a) ^ c) + d
-    add     r5, r5, r11                     @ d   = (((b ^ c) & a) ^ c) + d + (in[i+1] + MD5MagicData[i+1])
-    add     r5, r2, r5, ROR #(32 - 12)      @ d   = a + (d rotated left by 12 places)
-
-    add     r12, r12, r8                    @ r12 = in[i+2] + MD5MagicData[i+2]
-    eor     r8, r2, r3                      @ r8  =   (a ^ b)
-    and     r8, r8, r5                      @ r8  =  ((a ^ b) & d)
-    eor     r8, r8, r3                      @ r8  = (((a ^ b) & d) ^ b)
-    add     r4, r4, r8                      @ c   = (((a ^ b) & d) ^ b) + c
-    add     r4, r4, r12                     @ c   = (((a ^ b) & d) ^ b) + c + (in[i+2] + MD5MagicData[i+2])
-    add     r4, r5, r4, ROR #(32 - 17)      @ c   = d + (c rotated left by 17 places)
-
-    add     lr, lr, r9                      @ lr  = in[i+3] + MD5MagicData[i+3]
-    eor     r9, r5, r2                      @ r9  =   (d ^ a)
-    and     r9, r9, r4                      @ r9  =  ((d ^ a) & c)
-    eor     r9, r9, r2                      @ r9  = (((d ^ a) & c) ^ a)
-    add     r3, r3, r9                      @ b   = (((d ^ a) & c) ^ a) + b
-    add     r3, r3, lr                      @ b   = (((d ^ a) & c) ^ a) + b + (in[i+3] + MD5MagicData[i+3])
-    add     r3, r4, r3, ROR #(32 - 22)      @ b   = c + (b rotated left by 22 places)
-
-    ldmia   r0!, { r6 - r10 }               @ load next 4 elements from MD5MagicData
-    add     pc, pc, r10                     @ and branch to next state
-
-4:  ldr     r10, [r1, #-(15*4)]             @ r10 = in[ 1]
-    ldr     r11, [r1, #-(10*4)]             @ r11 = in[ 6]
-    ldr     r12, [r1, #-( 5*4)]             @ r12 = in[11]
-    ldr     lr,  [r1, #-(16*4)]             @ lr  = in[ 0]
-    b       8f
-5:  ldr     r10, [r1, #-(11*4)]             @ r10 = in[ 5]
-    ldr     r11, [r1, #-( 6*4)]             @ r11 = in[10]
-    ldr     r12, [r1, #-( 1*4)]             @ r12 = in[15]
-    ldr     lr,  [r1, #-(12*4)]             @ lr  = in[ 4]
-    b       8f
-6:  ldr     r10, [r1, #-( 7*4)]             @ r10 = in[ 9]
-    ldr     r11, [r1, #-( 2*4)]             @ r11 = in[14]
-    ldr     r12, [r1, #-(13*4)]             @ r12 = in[ 3]
-    ldr     lr,  [r1, #-( 8*4)]             @ lr  = in[ 8]
-    b       8f
-7:  ldr     r10, [r1, #-( 3*4)]             @ r10 = in[13]
-    ldr     r11, [r1, #-(14*4)]             @ r11 = in[ 2]
-    ldr     r12, [r1, #-( 9*4)]             @ r12 = in[ 7]
-    ldr     lr,  [r1, #-( 4*4)]             @ lr  = in[12]
-
-8:  add     r10, r10, r6                    @ r10 = in[x] + MD5MagicData[i]
-    eor     r6, r3, r4                      @ r6  =   (b ^ c)
-    and     r6, r6, r5                      @ r6  =  ((b ^ c) & d)
-    eor     r6, r6, r4                      @ r6  = (((b ^ c) & d) ^ c)
-    add     r2, r2, r6                      @ a   = (((b ^ c) & d) ^ c) + a
-    add     r2, r2, r10                     @ a   = (((b ^ c) & d) ^ c) + a + (in[x] + MD5MagicData[i])
-    add     r2, r3, r2, ROR #(32 -  5)      @ a   = b + (a rotated left by  5 places)
-
-    add     r11, r11, r7                    @ r11 = in[x] + MD5MagicData[i+1]
-    eor     r7, r2, r3                      @ r7  =   (a ^ b)
-    and     r7, r7, r4                      @ r7  =  ((a ^ b) & c)
-    eor     r7, r7, r3                      @ r7  = (((a ^ b) & c) ^ b)
-    add     r5, r5, r7                      @ d   = (((a ^ b) & c) ^ b) + d
-    add     r5, r5, r11                     @ d   = (((a ^ b) & c) ^ b) + d + (in[x] + MD5MagicData[i+1])
-    add     r5, r2, r5, ROR #(32 -  9)      @ d   = a + (d rotated left by  9 places)
-
-    add     r12, r12, r8                    @ r12 = in[x] + MD5MagicData[i+2]
-    eor     r8, r5, r2                      @ r8  =   (d ^ a)
-    and     r8, r8, r3                      @ r8  =  ((d ^ a) & b)
-    eor     r8, r8, r2                      @ r8  = (((d ^ a) & b) ^ a)
-    add     r4, r4, r8                      @ c   = (((d ^ a) & b) ^ a) + c
-    add     r4, r4, r12                     @ c   = (((d ^ a) & b) ^ a) + c + (in[x] + MD5MagicData[i+2])
-    add     r4, r5, r4, ROR #(32 - 14)      @ c   = d + (c rotated left by 14 places)
-
-    add     lr, lr, r9                      @ lr  = in[x] + MD5MagicData[i+3]
-    eor     r9, r4, r5                      @ r9  =   (c ^ d)
-    and     r9, r9, r2                      @ r9  =  ((c ^ d) & a)
-    eor     r9, r9, r5                      @ r9  = (((c ^ d) & a) ^ d)
-    add     r3, r3, r9                      @ b   = (((c ^ d) & a) ^ d) + b
-    add     r3, r3, lr                      @ b   = (((c ^ d) & a) ^ d) + b + (in[x] + MD5MagicData[i+3])
-    add     r3, r4, r3, ROR #(32 - 20)      @ b   = c + (b rotated left by 20 places)
-
-    ldmia   r0!, { r6 - r10 }               @ load next 4 elements from MD5MagicData
-    add     pc, pc, r10                     @ and branch to next state
-
-9:  ldr     r10, [r1, #-(11*4)]             @ r10 = in[ 5]
-    ldr     r11, [r1, #-( 8*4)]             @ r11 = in[ 8]
-    ldr     r12, [r1, #-( 5*4)]             @ r12 = in[11]
-    ldr     lr,  [r1, #-( 2*4)]             @ lr  = in[14]
-    b       13f
-10: ldr     r10, [r1, #-(15*4)]             @ r10 = in[ 1]
-    ldr     r11, [r1, #-(12*4)]             @ r11 = in[ 4]
-    ldr     r12, [r1, #-( 9*4)]             @ r12 = in[ 7]
-    ldr     lr,  [r1, #-( 6*4)]             @ lr  = in[10]
-    b       13f
-11: ldr     r10, [r1, #-( 3*4)]             @ r10 = in[13]
-    ldr     r11, [r1, #-(16*4)]             @ r11 = in[ 0]
-    ldr     r12, [r1, #-(13*4)]             @ r12 = in[ 3]
-    ldr     lr,  [r1, #-(10*4)]             @ lr  = in[ 6]
-    b       13f
-12: ldr     r10, [r1, #-( 7*4)]             @ r10 = in[ 9]
-    ldr     r11, [r1, #-( 4*4)]             @ r11 = in[12]
-    ldr     r12, [r1, #-( 1*4)]             @ r12 = in[15]
-    ldr     lr,  [r1, #-(14*4)]             @ lr  = in[ 2]
-
-13: add     r10, r10, r6                    @ r10 = in[x] + MD5MagicData[i]
-    add     r2, r2, r10                     @ a  += in[x] + MD5MagicData[i]
-    eor     r6, r3, r4                      @ r6  = (b ^ c)
-    eor     r10, r6, r5                     @ r10 = (b ^ c ^ d)
-    add     r2, r2, r10                     @ a  += (b ^ c ^ d)
-    add     r2, r3, r2, ROR #(32 -  4)      @ a   = b + (a rotated left by  4 places)
-
-    add     r11, r11, r7                    @ r11 = in[x] + MD5MagicData[i+1]
-    eor     r7, r2, r6                      @ r7  = (a ^ b ^ c)
-    add     r5, r5, r7                      @ d   = (a ^ b ^ c) + d
-    add     r5, r5, r11                     @ d   = (a ^ b ^ c) + d + (in[x] + MD5MagicData[i+1])
-    add     r5, r2, r5, ROR #(32 - 11)      @ d   = a + (d rotated left by 11 places)
-
-    add     r12, r12, r8                    @ r12 = in[x] + MD5MagicData[i+2]
-    add     r4, r4, r12                     @ c  += in[x] + MD5MagicData[i+2]
-    eor     r8, r5, r2                      @ r8  = (d ^ a)
-    eor     r12, r8, r3                     @ r12 = (d ^ a ^ b)
-    add     r4, r4, r12                     @ c  += (d ^ a ^ b)
-    add     r4, r5, r4, ROR #(32 - 16)      @ c   = d + (c rotated left by 16 places)
-
-    add     lr, lr, r9                      @ lr  = in[x] + MD5MagicData[i+3]
-    eor     r9, r4, r8                      @ r9  = (c ^ d ^ a)
-    add     r3, r3, r9                      @ b   = (c ^ d ^ a) + b
-    add     r3, r3, lr                      @ b   = (c ^ d ^ a) + b + (in[x] + MD5MagicData[i+3])
-    add     r3, r4, r3, ROR #(32 - 23)      @ b   = c + (b rotated left by 23 places)
-
-    ldmia   r0!, { r6 - r10 }               @ load next 4 elements from MD5MagicData
-    add     pc, pc, r10                     @ and branch to next state
-
-14: ldr     r10, [r1, #-(16*4)]             @ r10 = in[ 0]
-    ldr     r11, [r1, #-( 9*4)]             @ r11 = in[ 7]
-    ldr     r12, [r1, #-( 2*4)]             @ r12 = in[14]
-    ldr     lr,  [r1, #-(11*4)]             @ lr  = in[ 5]
-    b       18f
-15: ldr     r10, [r1, #-( 4*4)]             @ r10 = in[12]
-    ldr     r11, [r1, #-(13*4)]             @ r11 = in[ 3]
-    ldr     r12, [r1, #-( 6*4)]             @ r12 = in[10]
-    ldr     lr,  [r1, #-(15*4)]             @ lr  = in[ 1]
-    b       18f
-16: ldr     r10, [r1, #-( 8*4)]             @ r10 = in[ 8]
-    ldr     r11, [r1, #-( 1*4)]             @ r11 = in[15]
-    ldr     r12, [r1, #-(10*4)]             @ r12 = in[ 6]
-    ldr     lr,  [r1, #-( 3*4)]             @ lr  = in[13]
-    b       18f
-17: ldr     r10, [r1, #-(12*4)]             @ r10 = in[ 4]
-    ldr     r11, [r1, #-( 5*4)]             @ r11 = in[11]
-    ldr     r12, [r1, #-(14*4)]             @ r12 = in[ 2]
-    ldr     lr,  [r1, #-( 7*4)]             @ lr  = in[ 9]
-
-18: add     r10, r10, r6                    @ r10 = in[x] + MD5MagicData[i]
-    add     r2, r2, r10                     @ a  += in[x] + MD5MagicData[i]
-    mvn     r6, r5                          @ r6  =      (    ~d)
-    orr     r6, r6, r3                      @ r6  =      (b | ~d)
-    eor     r6, r6, r4                      @ r6  = (c ^ (b | ~d))
-    add     r2, r2, r6                      @ a  += (c ^ (b | ~d))
-    add     r2, r3, r2, ROR #(32 -  6)      @ a   = b + (a rotated left by  6 places)
-
-    add     r11, r11, r7                    @ r11 = in[x] + MD5MagicData[i]
-    add     r5, r5, r11                     @ d  += in[x] + MD5MagicData[i]
-    mvn     r7, r4                          @ r7  =      (    ~c)
-    orr     r7, r7, r2                      @ r7  =      (a | ~c)
-    eor     r7, r7, r3                      @ r7  = (b ^ (a | ~c))
-    add     r5, r5, r7                      @ d  += (b ^ (a | ~c))
-    add     r5, r2, r5, ROR #(32 - 10)      @ d   = a + (d rotated left by 10 places)
-
-    add     r12, r12, r8                    @ r12 = in[x] + MD5MagicData[i]
-    add     r4, r4, r12                     @ c  += in[x] + MD5MagicData[i]
-    mvn     r8, r3                          @ r8  =      (    ~b)
-    orr     r8, r8, r5                      @ r8  =      (d | ~b)
-    eor     r8, r8, r2                      @ r8  = (a ^ (d | ~b))
-    add     r4, r4, r8                      @ c  += (a ^ (d | ~b))
-    add     r4, r5, r4, ROR #(32 - 15)      @ c   = d + (c rotated left by 15 places)
-
-    add     lr, lr, r9                      @ lr  = in[x] + MD5MagicData[i]
-    add     r3, r3, lr                      @ b  += in[x] + MD5MagicData[i]
-    mvn     r9, r2                          @ r9  =      (    ~a)
-    orr     r9, r9, r4                      @ r9  =      (c | ~a)
-    eor     r9, r9, r5                      @ r9  = (d ^ (c | ~a))
-    add     r3, r3, r9                      @ b  += (d ^ (c | ~a))
-    add     r3, r4, r3, ROR #(32 - 21)      @ b   = c + (b rotated left by 21 places)
-
-    ldmia   r0!, { r6 - r10 }               @ load next 4 elements from MD5MagicData
-    add     pc, pc, r10                     @ and branch to next state
-
-19: ldmia   sp, { r0, r10 }                 @ fetch 'buf' and 'repeat' from the stack
-    ldmia   r0, { r6 - r9 }                 @ r6 = buf[0], r7 = buf[1], r8 = buf[2], r9 = buf[3] (original values..)
-    subs    r10, r10, #1
-    strne   r10, [sp, #4]
-    add     r2, r6, r2
-    add     r3, r7, r3
-    add     r4, r8, r4
-    add     r5, r9, r5
-    stmia   r0, { r2 - r5 }
-    bne     2b
-    ldmia   sp!, { r0, r2, r4 - r11, pc }   @ restore all callee saved registers and return
-
-
-    @ --
-    @ static void __UnalignedMD5Transform (uint32_t *buf, const uint8_t *in, int repeat);
-    @ --
-
-__UnalignedMD5Transform:
-
-    stmdb   sp!, { r4 - r7, lr }
-    movs    r4, r2, lsl #6                  @ r4 = (repeat * 64)
-    ldmeqia sp!, { r4 - r7, pc }            @ if  ((repeat * 64) == 0) return;
-    mov     r5, r0                          @ r5 = state
-    mov     r6, r1                          @ r6 = in
-    sub     sp, sp, #256                    @ create 256 byte temp buffer
-1:  cmp     r4, #256
-    mov     r0, sp
-    movcc   r7, r4
-    movcs   r7, #256                        @ r7 = (blockCount * 64) = min((repeat * 64), (4 * 64))
-    mov     r1, r6
-    mov     r2, r7
-    bl      memcpy                          @ memcpy (blockBuffer, in, (blockCount * 64));
-    mov     r0, r5
-    mov     r1, sp
-    mov     r2, r7, lsr #6
-    bl      __MD5Transform                  @ __MD5Transform (state, blockBuffer, blockCount);
-    subs    r4, r4, #256                    @ (repeat * 64) -= (4 * 64);
-    add     r6, r6, #256                    @ in += (4 * 64);
-    bgt     1b                              @ loop while (repeat > 0)
-    add     sp, sp, #256                    @ return temp buffer to stack
-    ldmia   sp!, { r4 - r7, pc }            @ return
-
-
-#endif   /* __BYTE_ORDER == __LITTLE_ENDIAN */
-
-
+#include "arm-features.h"
+
+/*****************************************************************************
+* Copyright (C) 2002 Andre McCurdy  <armccurdy@yahoo.co.uk>
+*
+* "derived from the RSA Data Security, Inc. MD5 Message-Digest Algorithm"
+*
+* This program is free software. you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY, without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+*
+******************************************************************************
+*
+* History:
+*
+* 2002/02/12:  Andre McCurdy <armccurdy@yahoo.co.uk>
+*   - Original created.
+*
+* 2002/02/13:  Andre McCurdy <armccurdy@yahoo.co.uk>
+*   - Rewrote MD5Update in assembler (saves 52 bytes).
+*   - Added guard so we don't compile anything for Big-Endian targets.
+*
+* 2002/02/22:  Andre McCurdy <armccurdy@yahoo.co.uk>
+*   - Added new function MD5Update (a wrapper for the original version) which
+*     checks for correct 32bit alignment of the input data pointer.
+*   - Original MD5Update function renamed __MD5Update.
+*   - __MD5Transform symbol no longer exported.
+*
+* 2002/02/25:  Andre McCurdy <armccurdy@yahoo.co.uk>
+*   - MD5Update re-written in assembler (saves 12 bytes + lots of cycles :-)
+*
+* 2002/03/07:  Andre McCurdy <armccurdy@yahoo.co.uk>
+*   - _Finally_ fixed hashing from an unaligned buffer in all cases :-)
+*
+******************************************************************************
+*
+* Notes:
+*
+* This code is believed to be Position Independent (ie can be safely used
+* as part of a shared library).
+*
+*****************************************************************************/
+
+#include <endian.h>
+#include "arm-features.h"
+
+#if (__BYTE_ORDER == __LITTLE_ENDIAN)
+
+    @ --
+    @ void MD5Init (MD5_CTX* context);
+    @ --
+
+FUNC_START	MD5Init
+    adr     r1, 1f                          @ r1 = base address of MD5InitData array
+    ldmia   r1, { r1 - r3, r12 }            @ load 4 elements from MD5InitData array
+    stmia   r0, { r1 - r3, r12 }            @ store into MD5 context->state[0..3]
+    mov     r1, #0
+    str     r1, [r0, #0x10]                 @ initial count[0] = 0
+    str     r1, [r0, #0x14]                 @ initial count[1] = 0
+    RET
+
+   .align 3
+1: .word    0x67452301                      @ initial MD5 context->state[0]
+   .word    0xefcdab89                      @ initial MD5 context->state[1]
+   .word    0x98badcfe                      @ initial MD5 context->state[2]
+   .word    0x10325476                      @ initial MD5 context->state[3]
+FUNC_END	MD5Init
+
+    @ --
+    @ void MD5Update (MD5_CTX* context, const uint8_t* buf, signed int len);
+    @ --
+
+FUNC_START	MD5Update
+    stmdb   sp!, { r4 - r8, lr }
+    add     r4, r0, #(6 * 4)                @ r4 = &context->buffer[0]
+    ldmdb   r4, { r0, r3 }                  @ r0 = count[0], r3 = count[1]
+    mov     r5, r1                          @ r5 = input
+    mov     r6, r0, lsr #3                  @ r6 = (context->count[0] >> 3)
+    and     r6, r6, #0x3f                   @ r6 = byteIndex = ((context->count[0] >> 3) & 0x3f)
+    adds    r0, r0, r2, lsl #3
+    adc     r3, r3, r2, lsr #29
+    stmdb   r4, { r0, r3 }                  @ context->count += (inputBytes * 8)
+    rsb     r7, r6, #64                     @ r7 = (64 - byteIndex) == partLen
+    subs    r8, r2, r7                      @ r8 = (inputBytes - partLen)
+    add     r0, r4, r6
+    bcc     2f
+    mov     r2, r7
+    bl      memcpy                          @ memcpy (&context->buffer[byteIndex], input, partLen);
+    sub     r0, r4, #(6 * 4)
+    mov     r1, r4
+    mov     r2, #1
+    bl      __MD5Transform                  @ __MD5Transform (context->state, context->buffer, 1);
+    sub     r0, r4, #(6 * 4)
+    add     r1, r5, r7
+    mov     r2, r8, lsr #6                  @ r2 = len = ((inputBytes - partLen) / 64)
+    tst     r1, #3                          @ if (input & 0x03)
+    adr     lr, 1f
+    beq     __MD5Transform                  @ __MD5Transform (context->state, &input[partLen], len);
+    bne     __UnalignedMD5Transform         @ else __UnalignedMD5Transform (context->state, &input[partLen], len);
+1:  mov     r0, r4
+    bic     r2, r8, #0x3f
+    add     r1, r2, r7
+    add     r1, r1, r5
+    sub     r2, r8, r2
+2:  ldmia   sp!, { r4 - r8, lr }
+    b       memcpy                          @ classic tail-call optimisation...
+FUNC_END	MD5Update
+
+    @ --
+    @ static void __MD5Transform (uint32_t *buf, const uint32_t *in, int repeat);
+    @ --
+
+.align 3
+MD5MagicData:
+
+1: .word     0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee
+   .word     0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501, ( 3f- 4f-4)
+   .word     0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be, ( 3f- 4f-4)
+   .word     0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821, ( 3f- 4f-4)
+   .word     0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa, ( 4f- 4f-4)
+   .word     0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8, ( 5f- 9f-4)
+   .word     0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, ( 6f- 9f-4)
+   .word     0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a, ( 7f- 9f-4)
+   .word     0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c, ( 9f- 9f-4)
+   .word     0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70, (10f-14f-4)
+   .word     0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05, (11f-14f-4)
+   .word     0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665, (12f-14f-4)
+   .word     0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, (14f-14f-4)
+   .word     0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1, (15f-19f-4)
+   .word     0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1, (16f-19f-4)
+   .word     0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391, (17f-19f-4)
+   .word     0x6e4120A9, 0x20657264, 0x7543634d, 0x00796472, (19f-19f-4)
+
+.align 2
+__MD5Transform:
+
+    cmp     r2, #0
+    moveq   pc, lr                          @ return if (repeat == 0)
+    stmdb   sp!, { r0, r2, r4 - r11, lr }   @ stack 'buf', 'repeat' and all callee saved registers
+    ldmia   r0,  { r2 - r5 }                @ r2 = a, r3 = b, r4 = c, r5 = d
+2:  adr     r0, 1b                          @ r0 = base address of MD5MagicData
+    ldmia   r0!, { r6 - r9 }                @ load first 4 elements from MD5MagicData
+3:  ldmia   r1!, { r10 - r12, lr }          @ r10 = in[i], r11 = in[i+1], r12 = in[i+2], lr = in[i+3]
+
+    add     r10, r10, r6                    @ r10 = in[i] + MD5MagicData[i]
+    eor     r6, r4, r5                      @ r6  =   (c ^ d)
+    and     r6, r6, r3                      @ r6  =  ((c ^ d) & b)
+    eor     r6, r6, r5                      @ r6  = (((c ^ d) & b) ^ d)
+    add     r2, r2, r6                      @ a   = (((c ^ d) & b) ^ d) + a
+    add     r2, r2, r10                     @ a   = (((c ^ d) & b) ^ d) + a + (in[i] + MD5MagicData[i])
+    add     r2, r3, r2, ROR #(32 -  7)      @ a   = b + (a rotated left by  7 places)
+
+    add     r11, r11, r7                    @ r11 = in[i+1] + MD5MagicData[i+1]
+    eor     r7, r3, r4                      @ r7  =   (b ^ c)
+    and     r7, r7, r2                      @ r7  =  ((b ^ c) & a)
+    eor     r7, r7, r4                      @ r7  = (((b ^ c) & a) ^ c)
+    add     r5, r5, r7                      @ d   = (((b ^ c) & a) ^ c) + d
+    add     r5, r5, r11                     @ d   = (((b ^ c) & a) ^ c) + d + (in[i+1] + MD5MagicData[i+1])
+    add     r5, r2, r5, ROR #(32 - 12)      @ d   = a + (d rotated left by 12 places)
+
+    add     r12, r12, r8                    @ r12 = in[i+2] + MD5MagicData[i+2]
+    eor     r8, r2, r3                      @ r8  =   (a ^ b)
+    and     r8, r8, r5                      @ r8  =  ((a ^ b) & d)
+    eor     r8, r8, r3                      @ r8  = (((a ^ b) & d) ^ b)
+    add     r4, r4, r8                      @ c   = (((a ^ b) & d) ^ b) + c
+    add     r4, r4, r12                     @ c   = (((a ^ b) & d) ^ b) + c + (in[i+2] + MD5MagicData[i+2])
+    add     r4, r5, r4, ROR #(32 - 17)      @ c   = d + (c rotated left by 17 places)
+
+    add     lr, lr, r9                      @ lr  = in[i+3] + MD5MagicData[i+3]
+    eor     r9, r5, r2                      @ r9  =   (d ^ a)
+    and     r9, r9, r4                      @ r9  =  ((d ^ a) & c)
+    eor     r9, r9, r2                      @ r9  = (((d ^ a) & c) ^ a)
+    add     r3, r3, r9                      @ b   = (((d ^ a) & c) ^ a) + b
+    add     r3, r3, lr                      @ b   = (((d ^ a) & c) ^ a) + b + (in[i+3] + MD5MagicData[i+3])
+    add     r3, r4, r3, ROR #(32 - 22)      @ b   = c + (b rotated left by 22 places)
+
+    ldmia   r0!, { r6 - r10 }               @ load next 4 elements from MD5MagicData
+    add     pc, pc, r10                     @ and branch to next state
+
+4:  ldr     r10, [r1, #-(15*4)]             @ r10 = in[ 1]
+    ldr     r11, [r1, #-(10*4)]             @ r11 = in[ 6]
+    ldr     r12, [r1, #-( 5*4)]             @ r12 = in[11]
+    ldr     lr,  [r1, #-(16*4)]             @ lr  = in[ 0]
+    b       8f
+5:  ldr     r10, [r1, #-(11*4)]             @ r10 = in[ 5]
+    ldr     r11, [r1, #-( 6*4)]             @ r11 = in[10]
+    ldr     r12, [r1, #-( 1*4)]             @ r12 = in[15]
+    ldr     lr,  [r1, #-(12*4)]             @ lr  = in[ 4]
+    b       8f
+6:  ldr     r10, [r1, #-( 7*4)]             @ r10 = in[ 9]
+    ldr     r11, [r1, #-( 2*4)]             @ r11 = in[14]
+    ldr     r12, [r1, #-(13*4)]             @ r12 = in[ 3]
+    ldr     lr,  [r1, #-( 8*4)]             @ lr  = in[ 8]
+    b       8f
+7:  ldr     r10, [r1, #-( 3*4)]             @ r10 = in[13]
+    ldr     r11, [r1, #-(14*4)]             @ r11 = in[ 2]
+    ldr     r12, [r1, #-( 9*4)]             @ r12 = in[ 7]
+    ldr     lr,  [r1, #-( 4*4)]             @ lr  = in[12]
+
+8:  add     r10, r10, r6                    @ r10 = in[x] + MD5MagicData[i]
+    eor     r6, r3, r4                      @ r6  =   (b ^ c)
+    and     r6, r6, r5                      @ r6  =  ((b ^ c) & d)
+    eor     r6, r6, r4                      @ r6  = (((b ^ c) & d) ^ c)
+    add     r2, r2, r6                      @ a   = (((b ^ c) & d) ^ c) + a
+    add     r2, r2, r10                     @ a   = (((b ^ c) & d) ^ c) + a + (in[x] + MD5MagicData[i])
+    add     r2, r3, r2, ROR #(32 -  5)      @ a   = b + (a rotated left by  5 places)
+
+    add     r11, r11, r7                    @ r11 = in[x] + MD5MagicData[i+1]
+    eor     r7, r2, r3                      @ r7  =   (a ^ b)
+    and     r7, r7, r4                      @ r7  =  ((a ^ b) & c)
+    eor     r7, r7, r3                      @ r7  = (((a ^ b) & c) ^ b)
+    add     r5, r5, r7                      @ d   = (((a ^ b) & c) ^ b) + d
+    add     r5, r5, r11                     @ d   = (((a ^ b) & c) ^ b) + d + (in[x] + MD5MagicData[i+1])
+    add     r5, r2, r5, ROR #(32 -  9)      @ d   = a + (d rotated left by  9 places)
+
+    add     r12, r12, r8                    @ r12 = in[x] + MD5MagicData[i+2]
+    eor     r8, r5, r2                      @ r8  =   (d ^ a)
+    and     r8, r8, r3                      @ r8  =  ((d ^ a) & b)
+    eor     r8, r8, r2                      @ r8  = (((d ^ a) & b) ^ a)
+    add     r4, r4, r8                      @ c   = (((d ^ a) & b) ^ a) + c
+    add     r4, r4, r12                     @ c   = (((d ^ a) & b) ^ a) + c + (in[x] + MD5MagicData[i+2])
+    add     r4, r5, r4, ROR #(32 - 14)      @ c   = d + (c rotated left by 14 places)
+
+    add     lr, lr, r9                      @ lr  = in[x] + MD5MagicData[i+3]
+    eor     r9, r4, r5                      @ r9  =   (c ^ d)
+    and     r9, r9, r2                      @ r9  =  ((c ^ d) & a)
+    eor     r9, r9, r5                      @ r9  = (((c ^ d) & a) ^ d)
+    add     r3, r3, r9                      @ b   = (((c ^ d) & a) ^ d) + b
+    add     r3, r3, lr                      @ b   = (((c ^ d) & a) ^ d) + b + (in[x] + MD5MagicData[i+3])
+    add     r3, r4, r3, ROR #(32 - 20)      @ b   = c + (b rotated left by 20 places)
+
+    ldmia   r0!, { r6 - r10 }               @ load next 4 elements from MD5MagicData
+    add     pc, pc, r10                     @ and branch to next state
+
+9:  ldr     r10, [r1, #-(11*4)]             @ r10 = in[ 5]
+    ldr     r11, [r1, #-( 8*4)]             @ r11 = in[ 8]
+    ldr     r12, [r1, #-( 5*4)]             @ r12 = in[11]
+    ldr     lr,  [r1, #-( 2*4)]             @ lr  = in[14]
+    b       13f
+10: ldr     r10, [r1, #-(15*4)]             @ r10 = in[ 1]
+    ldr     r11, [r1, #-(12*4)]             @ r11 = in[ 4]
+    ldr     r12, [r1, #-( 9*4)]             @ r12 = in[ 7]
+    ldr     lr,  [r1, #-( 6*4)]             @ lr  = in[10]
+    b       13f
+11: ldr     r10, [r1, #-( 3*4)]             @ r10 = in[13]
+    ldr     r11, [r1, #-(16*4)]             @ r11 = in[ 0]
+    ldr     r12, [r1, #-(13*4)]             @ r12 = in[ 3]
+    ldr     lr,  [r1, #-(10*4)]             @ lr  = in[ 6]
+    b       13f
+12: ldr     r10, [r1, #-( 7*4)]             @ r10 = in[ 9]
+    ldr     r11, [r1, #-( 4*4)]             @ r11 = in[12]
+    ldr     r12, [r1, #-( 1*4)]             @ r12 = in[15]
+    ldr     lr,  [r1, #-(14*4)]             @ lr  = in[ 2]
+
+13: add     r10, r10, r6                    @ r10 = in[x] + MD5MagicData[i]
+    add     r2, r2, r10                     @ a  += in[x] + MD5MagicData[i]
+    eor     r6, r3, r4                      @ r6  = (b ^ c)
+    eor     r10, r6, r5                     @ r10 = (b ^ c ^ d)
+    add     r2, r2, r10                     @ a  += (b ^ c ^ d)
+    add     r2, r3, r2, ROR #(32 -  4)      @ a   = b + (a rotated left by  4 places)
+
+    add     r11, r11, r7                    @ r11 = in[x] + MD5MagicData[i+1]
+    eor     r7, r2, r6                      @ r7  = (a ^ b ^ c)
+    add     r5, r5, r7                      @ d   = (a ^ b ^ c) + d
+    add     r5, r5, r11                     @ d   = (a ^ b ^ c) + d + (in[x] + MD5MagicData[i+1])
+    add     r5, r2, r5, ROR #(32 - 11)      @ d   = a + (d rotated left by 11 places)
+
+    add     r12, r12, r8                    @ r12 = in[x] + MD5MagicData[i+2]
+    add     r4, r4, r12                     @ c  += in[x] + MD5MagicData[i+2]
+    eor     r8, r5, r2                      @ r8  = (d ^ a)
+    eor     r12, r8, r3                     @ r12 = (d ^ a ^ b)
+    add     r4, r4, r12                     @ c  += (d ^ a ^ b)
+    add     r4, r5, r4, ROR #(32 - 16)      @ c   = d + (c rotated left by 16 places)
+
+    add     lr, lr, r9                      @ lr  = in[x] + MD5MagicData[i+3]
+    eor     r9, r4, r8                      @ r9  = (c ^ d ^ a)
+    add     r3, r3, r9                      @ b   = (c ^ d ^ a) + b
+    add     r3, r3, lr                      @ b   = (c ^ d ^ a) + b + (in[x] + MD5MagicData[i+3])
+    add     r3, r4, r3, ROR #(32 - 23)      @ b   = c + (b rotated left by 23 places)
+
+    ldmia   r0!, { r6 - r10 }               @ load next 4 elements from MD5MagicData
+    add     pc, pc, r10                     @ and branch to next state
+
+14: ldr     r10, [r1, #-(16*4)]             @ r10 = in[ 0]
+    ldr     r11, [r1, #-( 9*4)]             @ r11 = in[ 7]
+    ldr     r12, [r1, #-( 2*4)]             @ r12 = in[14]
+    ldr     lr,  [r1, #-(11*4)]             @ lr  = in[ 5]
+    b       18f
+15: ldr     r10, [r1, #-( 4*4)]             @ r10 = in[12]
+    ldr     r11, [r1, #-(13*4)]             @ r11 = in[ 3]
+    ldr     r12, [r1, #-( 6*4)]             @ r12 = in[10]
+    ldr     lr,  [r1, #-(15*4)]             @ lr  = in[ 1]
+    b       18f
+16: ldr     r10, [r1, #-( 8*4)]             @ r10 = in[ 8]
+    ldr     r11, [r1, #-( 1*4)]             @ r11 = in[15]
+    ldr     r12, [r1, #-(10*4)]             @ r12 = in[ 6]
+    ldr     lr,  [r1, #-( 3*4)]             @ lr  = in[13]
+    b       18f
+17: ldr     r10, [r1, #-(12*4)]             @ r10 = in[ 4]
+    ldr     r11, [r1, #-( 5*4)]             @ r11 = in[11]
+    ldr     r12, [r1, #-(14*4)]             @ r12 = in[ 2]
+    ldr     lr,  [r1, #-( 7*4)]             @ lr  = in[ 9]
+
+18: add     r10, r10, r6                    @ r10 = in[x] + MD5MagicData[i]
+    add     r2, r2, r10                     @ a  += in[x] + MD5MagicData[i]
+    mvn     r6, r5                          @ r6  =      (    ~d)
+    orr     r6, r6, r3                      @ r6  =      (b | ~d)
+    eor     r6, r6, r4                      @ r6  = (c ^ (b | ~d))
+    add     r2, r2, r6                      @ a  += (c ^ (b | ~d))
+    add     r2, r3, r2, ROR #(32 -  6)      @ a   = b + (a rotated left by  6 places)
+
+    add     r11, r11, r7                    @ r11 = in[x] + MD5MagicData[i]
+    add     r5, r5, r11                     @ d  += in[x] + MD5MagicData[i]
+    mvn     r7, r4                          @ r7  =      (    ~c)
+    orr     r7, r7, r2                      @ r7  =      (a | ~c)
+    eor     r7, r7, r3                      @ r7  = (b ^ (a | ~c))
+    add     r5, r5, r7                      @ d  += (b ^ (a | ~c))
+    add     r5, r2, r5, ROR #(32 - 10)      @ d   = a + (d rotated left by 10 places)
+
+    add     r12, r12, r8                    @ r12 = in[x] + MD5MagicData[i]
+    add     r4, r4, r12                     @ c  += in[x] + MD5MagicData[i]
+    mvn     r8, r3                          @ r8  =      (    ~b)
+    orr     r8, r8, r5                      @ r8  =      (d | ~b)
+    eor     r8, r8, r2                      @ r8  = (a ^ (d | ~b))
+    add     r4, r4, r8                      @ c  += (a ^ (d | ~b))
+    add     r4, r5, r4, ROR #(32 - 15)      @ c   = d + (c rotated left by 15 places)
+
+    add     lr, lr, r9                      @ lr  = in[x] + MD5MagicData[i]
+    add     r3, r3, lr                      @ b  += in[x] + MD5MagicData[i]
+    mvn     r9, r2                          @ r9  =      (    ~a)
+    orr     r9, r9, r4                      @ r9  =      (c | ~a)
+    eor     r9, r9, r5                      @ r9  = (d ^ (c | ~a))
+    add     r3, r3, r9                      @ b  += (d ^ (c | ~a))
+    add     r3, r4, r3, ROR #(32 - 21)      @ b   = c + (b rotated left by 21 places)
+
+    ldmia   r0!, { r6 - r10 }               @ load next 4 elements from MD5MagicData
+    add     pc, pc, r10                     @ and branch to next state
+
+19: ldmia   sp, { r0, r10 }                 @ fetch 'buf' and 'repeat' from the stack
+    ldmia   r0, { r6 - r9 }                 @ r6 = buf[0], r7 = buf[1], r8 = buf[2], r9 = buf[3] (original values..)
+    subs    r10, r10, #1
+    strne   r10, [sp, #4]
+    add     r2, r6, r2
+    add     r3, r7, r3
+    add     r4, r8, r4
+    add     r5, r9, r5
+    stmia   r0, { r2 - r5 }
+    bne     2b
+    ldmia   sp!, { r0, r2, r4 - r11, pc }   @ restore all callee saved registers and return
+
+
+    @ --
+    @ static void __UnalignedMD5Transform (uint32_t *buf, const uint8_t *in, int repeat);
+    @ --
+
+__UnalignedMD5Transform:
+
+    stmdb   sp!, { r4 - r7, lr }
+    movs    r4, r2, lsl #6                  @ r4 = (repeat * 64)
+    ldmeqia sp!, { r4 - r7, pc }            @ if  ((repeat * 64) == 0) return;
+    mov     r5, r0                          @ r5 = state
+    mov     r6, r1                          @ r6 = in
+    sub     sp, sp, #256                    @ create 256 byte temp buffer
+1:  cmp     r4, #256
+    mov     r0, sp
+    movcc   r7, r4
+    movcs   r7, #256                        @ r7 = (blockCount * 64) = min((repeat * 64), (4 * 64))
+    mov     r1, r6
+    mov     r2, r7
+    bl      memcpy                          @ memcpy (blockBuffer, in, (blockCount * 64));
+    mov     r0, r5
+    mov     r1, sp
+    mov     r2, r7, lsr #6
+    bl      __MD5Transform                  @ __MD5Transform (state, blockBuffer, blockCount);
+    subs    r4, r4, #256                    @ (repeat * 64) -= (4 * 64);
+    add     r6, r6, #256                    @ in += (4 * 64);
+    bgt     1b                              @ loop while (repeat > 0)
+    add     sp, sp, #256                    @ return temp buffer to stack
+    ldmia   sp!, { r4 - r7, pc }            @ return
+
+
+#endif   /* __BYTE_ORDER == __LITTLE_ENDIAN */
+
+
diff -urN -x .git dietlibc-0.33/arm/mmap.S dietlibc/arm/mmap.S
--- dietlibc-0.33/arm/mmap.S	2008-12-10 20:00:58.000000000 +0000
+++ dietlibc/arm/mmap.S	2015-01-01 12:14:43.454938895 +0000
@@ -1,3 +1,5 @@
+#include "arm-features.h"
+
 #include <errno.h>
 #include "syscalls.h"
 
@@ -28,7 +30,7 @@
 	ldr     r4, [sp], #4
 	ldr     r5, [sp], #4
 	cmn	r0, #4096
-	mov	pc, lr			@ return
+	RET
 
 #else	
 		
diff -urN -x .git dietlibc-0.33/arm/setjmp.S dietlibc/arm/setjmp.S
--- dietlibc-0.33/arm/setjmp.S	2008-12-10 20:00:58.000000000 +0000
+++ dietlibc/arm/setjmp.S	2015-01-01 12:14:43.454938895 +0000
@@ -1,17 +1,41 @@
-.text
-.weak setjmp
-setjmp:
-.global __setjmp
-__setjmp:
+#include "arm-features.h"
+
+FUNC_START_WEAK	setjmp
+FUNC_START	__setjmp
 	mov	r1, #0
-.global __sigsetjmp
-__sigsetjmp:
-.weak sigsetjmp
-sigsetjmp:
-#ifndef	__SOFTFP__
-	sfm	f4, 4, [r0], #48
+FUNC_END	__setjmp
+FUNC_END	setjmp
+
+FUNC_START_WEAK	sigsetjmp
+FUNC_START	__sigsetjmp
+
+#ifdef DIET_HAVE_COPROC_REGS
+	/* we have to work on a copy of 'r0' (jmpbuf *) */
+	mov	ip, r0
+#endif
+
+#ifndef __SOFTFP__
+# if __ARM_ARCH__ >= 7
+	vstmia	ip!, {d0-d15}
+#   ifdef __ARM_NEON__
+	vstmia	ip!, {d16-d31}
+#   endif
+# else
+	sfm	f4, 4, [ip]!
+# endif
+#endif
+
+#ifdef __IWMMXT__
+#  warning "setjmp will not save iwmmxt coprocessor registers"
 #endif
+
+#ifndef DIET_HAVE_COPROC_REGS
 	stmia	r0, {r4-r11, sp, lr}
-	sub	r0, r0, #48
-	b	__sigjmp_save
 
+#else
+	stmia	ip!, {r4-r11, sp, lr}
+#endif
+
+	b	__sigjmp_save
+FUNC_END	__sigsetjmp
+FUNC_END	sigsetjmp
diff -urN -x .git dietlibc-0.33/arm/start.S dietlibc/arm/start.S
--- dietlibc-0.33/arm/start.S	2012-01-24 18:24:24.000000000 +0000
+++ dietlibc/arm/start.S	2015-01-01 12:14:43.454938895 +0000
@@ -1,23 +1,10 @@
-
 #include "dietfeatures.h"
 #include "syscalls.h"
-
-	.text
-#ifdef __ARM_EABI__
-	.align 4
-#else
-	.align 2
-#endif
-	
-	.global _start
-	.weak 	exit
-	.global _exit
-
+#include "arm-features.h"
 
 #ifdef __ARM_EABI__
 
-_start:
-
+FUNC_START	_start
 	mov	fp, #0			@ clear the frame pointer
 	ldr	a1, [sp]		@ argc
 	add	a2, sp, #4		@ argv
@@ -25,27 +12,40 @@
 	add	a3, a2, a1, lsl #2	@ &argv[argc]
 	add	a3, a3, #4		@ envp	
 	str	a3, [ip, #0]		@ environ = envp
-	bl	main
-		
+
+#ifdef WANT_ELFINFO
+	mov	r6, a3			@ work on a copy of a3 so that common
+					@ 'main(argc, argv, envp)' function
+					@ stays valid
+1:	ldr	r5, [r6], #4		@ load *envp and increment it
+	cmp	r5, #0			@ read value==0?
+	bne	1b
+	str	r6, [ip, #4]		@ __elfinfo = envp
+#endif
+
+	bl	CALL_IN_STARTCODE
+
 @
 @ The exit status from main() is already in r0.
 @ We need to branch to 'exit' in case we have linked with 'atexit'.
 @
 	bl	exit
+FUNC_END	_start
 
-exit:
-_exit:
-
+FUNC_START	_exit
+FUNC_START_WEAK	exit
 	mov	r7, #__NR_exit		
 	swi	0			@ never returns.
 
+	.align	2
 .L3:	.word 	environ
 
-	
-#else	
+FUNC_END	exit
+FUNC_END	_exit
+
+#else
 
-	
-_start:
+FUNC_START	_start
 
 #ifdef WANT_DYNAMIC
 	mov	a4, a1			@ save dynamic ld.so _fini
@@ -59,11 +59,25 @@
 #ifdef __DYN_LIB
 	ldr	sl, .L4
 1:	add	sl, pc, sl
-	str	a3, [sl, ip]		@ environ = envp
+	str	a3, [ip, sl]!		@ environ = envp; ip = GOT(environ)
 #else
 	str	a3, [ip, #0]		@ environ = envp
 #endif
 
+#ifdef WANT_ELFINFO
+	mov	r6, a3			@ work on a copy of a3 so that common
+					@ 'main(argc, argv, envp)' function
+					@ stays valid
+1:	ldr	r5, [r6], #4		@ load *envp and increment it
+	cmp	r5, #0			@ read value==0?
+	bne	1b
+#ifdef __DYN_LIB
+	str	r6, [ip, sl]		@ __elfinfo = envp
+#else
+	str	r6, [ip, #4]		@ __elfinfo = envp
+#endif
+#endif
+
 #ifdef PROFILING
 	stmdb	sp!, { r0 - r3 }
 	ldr	r0, .L5
@@ -83,18 +97,20 @@
 @ We need to branch to 'exit' in case we have linked with 'atexit'.
 @
 	bl	exit
+FUNC_END	_start
 
-exit:
-_exit:
-
+FUNC_START	_exit
+FUNC_START_WEAK	exit
 #ifdef PROFILING
 	mov	r4, r0			@ save a copy of exit status
 	bl	_stop_monitor
 	mov	r0, r4
 #endif
 	swi	$__NR_exit		@ never returns.
+FUNC_END	exit
+FUNC_END	_exit
 
-
+	.align	2
 #ifdef __DYN_LIB
 .L3:	.word 	environ(GOT)
 .L4:	.word 	_GLOBAL_OFFSET_TABLE_-(1b+8)
diff -urN -x .git dietlibc-0.33/arm/strcpy.S dietlibc/arm/strcpy.S
--- dietlibc-0.33/arm/strcpy.S	2005-08-05 00:29:18.000000000 +0000
+++ dietlibc/arm/strcpy.S	2015-01-01 12:14:43.454938895 +0000
@@ -1,10 +1,7 @@
 #include "dietfeatures.h"
+#include "arm-features.h"
 
-.text
-	.align	2
-	.global	strcpy
-
-strcpy:
+FUNC_START	strcpy
 #ifndef WANT_SMALL_STRING_ROUTINES
 	mov	ip, r0
 	ands	r2, r1, #3
@@ -61,6 +58,5 @@
 	ldrneb	r2, [r1], #1
 #endif
 	bne	.Lloop
-	mov	pc, lr
-.Lfe1:
-	.size	 strcpy,.Lfe1-strcpy
+	RET
+FUNC_END	strcpy
diff -urN -x .git dietlibc-0.33/arm/strlen.S dietlibc/arm/strlen.S
--- dietlibc-0.33/arm/strlen.S	2005-08-05 00:29:18.000000000 +0000
+++ dietlibc/arm/strlen.S	2015-01-01 12:14:43.454938895 +0000
@@ -1,12 +1,7 @@
 #include "dietfeatures.h"
+#include "arm-features.h"
 
-	.text
-	.align	2
-
-	.global	strlen
-
-strlen:
-
+FUNC_START	strlen
 #if 0
 	teq	a1, #0			@ is string pointer NULL ??
 	moveq	pc, lr			@ if so, return 0
@@ -61,12 +56,10 @@
 	sub	a1, a1, a2
 #endif
 
-	mov	pc, lr
+	RET
 
 #ifndef WANT_SMALL_STRING_ROUTINES
 .Lmagic:
 	.word	0x01010101
 #endif
-
-.Lstrlen:
-	.size	strlen,.Lstrlen-strlen
+FUNC_END	strlen
diff -urN -x .git dietlibc-0.33/arm/syscalls.h dietlibc/arm/syscalls.h
--- dietlibc-0.33/arm/syscalls.h	2012-01-24 18:24:24.000000000 +0000
+++ dietlibc/arm/syscalls.h	2015-01-01 12:14:43.454938895 +0000
@@ -365,6 +365,38 @@
 #define __NR_fallocate			(__NR_SYSCALL_BASE+352)
 #define __NR_timerfd_settime		(__NR_SYSCALL_BASE+353)
 #define __NR_timerfd_gettime		(__NR_SYSCALL_BASE+354)
+#define __NR_signalfd4			(__NR_SYSCALL_BASE+355)
+#define __NR_eventfd2			(__NR_SYSCALL_BASE+356)
+#define __NR_epoll_create1		(__NR_SYSCALL_BASE+357)
+#define __NR_dup3			(__NR_SYSCALL_BASE+358)
+#define __NR_pipe2			(__NR_SYSCALL_BASE+359)
+#define __NR_inotify_init1		(__NR_SYSCALL_BASE+360)
+#define __NR_preadv			(__NR_SYSCALL_BASE+361)
+#define __NR_pwritev			(__NR_SYSCALL_BASE+362)
+#define __NR_rt_tgsigqueueinfo		(__NR_SYSCALL_BASE+363)
+#define __NR_perf_event_open		(__NR_SYSCALL_BASE+364)
+#define __NR_recvmmsg			(__NR_SYSCALL_BASE+365)
+#define __NR_accept4			(__NR_SYSCALL_BASE+366)
+#define __NR_fanotify_init		(__NR_SYSCALL_BASE+367)
+#define __NR_fanotify_mark		(__NR_SYSCALL_BASE+368)
+#define __NR_prlimit64			(__NR_SYSCALL_BASE+369)
+#define __NR_name_to_handle_at		(__NR_SYSCALL_BASE+370)
+#define __NR_open_by_handle_at		(__NR_SYSCALL_BASE+371)
+#define __NR_clock_adjtime		(__NR_SYSCALL_BASE+372)
+#define __NR_syncfs			(__NR_SYSCALL_BASE+373)
+#define __NR_sendmmsg			(__NR_SYSCALL_BASE+374)
+#define __NR_setns			(__NR_SYSCALL_BASE+375)
+#define __NR_process_vm_readv		(__NR_SYSCALL_BASE+376)
+#define __NR_process_vm_writev		(__NR_SYSCALL_BASE+377)
+#define __NR_kcmp			(__NR_SYSCALL_BASE+378)
+#define __NR_finit_module		(__NR_SYSCALL_BASE+379)
+#define __NR_sched_setattr		(__NR_SYSCALL_BASE+380)
+#define __NR_sched_getattr		(__NR_SYSCALL_BASE+381)
+#define __NR_renameat2			(__NR_SYSCALL_BASE+382)
+#define __NR_seccomp			(__NR_SYSCALL_BASE+383)
+#define __NR_getrandom			(__NR_SYSCALL_BASE+384)
+#define __NR_memfd_create		(__NR_SYSCALL_BASE+385)
+
 
 /*
  * The following SWIs are ARM private.
@@ -700,9 +732,9 @@
 #define __ARGS_getpeername		0
 #define __ARGS_socketpair		0
 #define __ARGS_send			0
-#define __ARGS_sendto			0
+#define __ARGS_sendto			6
 #define __ARGS_recv			0
-#define __ARGS_recvfrom			0
+#define __ARGS_recvfrom			6
 #define __ARGS_shutdown			0
 #define __ARGS_setsockopt		0
 #define __ARGS_getsockopt		0
@@ -768,73 +800,59 @@
 #define __ARGS_timerfd_settime		0
 #define __ARGS_timerfd_gettime		0
 
+#define __ARGS_signalfd4		0
+#define __ARGS_eventfd2			0
+#define __ARGS_epoll_create1		0
+#define __ARGS_dup3			0
+#define __ARGS_pipe2			0
+#define __ARGS_inotify_init1		0
+#define __ARGS_preadv			0
+#define __ARGS_pwritev			0
+#define __ARGS_rt_tgsigqueueinfo	0
+#define __ARGS_perf_event_open		1
+#define __ARGS_recvmmsg			1
+#define __ARGS_accept4			0
+#define __ARGS_fanotify_init		0
+#define __ARGS_fanotify_mark		1
+#define __ARGS_prlimit64		0
+#define __ARGS_name_to_handle_at	1
+#define __ARGS_open_by_handle_at	0
+#define __ARGS_clock_adjtime		0
+#define __ARGS_syncfs			0
+#define __ARGS_sendmmsg			0
+#define __ARGS_setns			0
+#define __ARGS_process_vm_readv		1
+#define __ARGS_process_vm_writev	1
+#define __ARGS_kcmp			1
+#define __ARGS_finit_module		0
+
 
 #ifdef __ASSEMBLER__
 
-#ifdef __ARM_EABI__
+#include "arm-features.h"
 
 #define syscall_weak(name,wsym,sym) __syscall_weak __NR_##name, wsym, sym, __ARGS_##name
 .macro __syscall_weak name wsym sym typ
-.text
-.type \wsym,function
-.weak \wsym
-\wsym:
-.type \sym,function
-.global \sym
-\sym:
-        stmfd	sp!,{r4,r5,r7,lr}
-	ldr	r4, [sp,#16]
-	ldr	r5, [sp,#20]
-        ldr     r7, =\name
-	swi	0
-	b	__unified_syscall
+FUNC_START_WEAK	\wsym
+__syscall	\name, \sym, \typ
+FUNC_END	\wsym
 .endm
 
+#ifdef __ARM_EABI__
 
 #define syscall(name,sym) __syscall __NR_##name, sym, __ARGS_##name
 .macro __syscall name sym typ
-.text
-.type \sym,function
-.global \sym
-\sym:
-        stmfd	sp!,{r4,r5,r7,lr}
-	ldr	r4, [sp,#16]
-	ldr	r5, [sp,#20]
-        ldr     r7, =\name
-	swi	0
-	b	__unified_syscall
+FUNC_START	\sym
+        ldr     ip, =\name
+	b	__unified_syscall_swi
+FUNC_END	\sym
 .endm
 
 #else
 
-#define syscall_weak(name,wsym,sym) __syscall_weak $__NR_##name, wsym, sym, __ARGS_##name
-.macro __syscall_weak name wsym sym typ
-.text
-.type \wsym,function
-.weak \wsym
-\wsym:
-.type \sym,function
-.global \sym
-\sym:
-.ifgt \typ
-	mov	ip, sp
-	stmfd	sp!,{r4, r5, r6}
-	ldmia	ip, {r4, r5, r6}
-.endif
-	swi	\name
-.ifgt \typ
-	b	__unified_syscall4
-.else
-	b	__unified_syscall
-.endif
-.endm
-
 #define syscall(name,sym) __syscall $__NR_##name, sym, __ARGS_##name
 .macro __syscall name sym typ
-.text
-.type \sym,function
-.global \sym
-\sym:
+FUNC_START	\sym
 .ifgt \typ
 	mov	ip, sp
 	stmfd	sp!,{r4, r5, r6}
@@ -846,6 +864,7 @@
 .else
 	b	__unified_syscall
 .endif
+FUNC_END	\sym
 .endm
 
 #endif
diff -urN -x .git dietlibc-0.33/arm/__testandset.S dietlibc/arm/__testandset.S
--- dietlibc-0.33/arm/__testandset.S	2001-03-09 19:30:52.000000000 +0000
+++ dietlibc/arm/__testandset.S	2015-01-01 12:14:43.454938895 +0000
@@ -1,7 +1,15 @@
-.text
-.global __testandset
-__testandset:
+#include "arm-features.h"
+
+FUNC_START	__testandset
 	mov	r2, r0
 	mov	r1, #1
+# if __ARM_ARCH__ < 6
 	swp	r0, r1, [r2]
-	mov	pc, lr
+# else
+1:	ldrex	r0, [r2]
+	strex	r3, r1, [r2]
+	cmp	r3, #0
+	bne	1b
+# endif
+	RET
+FUNC_END	__testandset
diff -urN -x .git dietlibc-0.33/arm/unified.S dietlibc/arm/unified.S
--- dietlibc-0.33/arm/unified.S	2012-01-24 18:24:24.000000000 +0000
+++ dietlibc/arm/unified.S	2015-01-01 12:14:43.454938895 +0000
@@ -1,22 +1,29 @@
-
 #include <dietfeatures.h>
-
-	.text
-#ifdef __ARM_EABI__
-	.align 4
-#else
-	.align 2
-#endif 	
-	.global __unified_syscall
-	.global __unified_syscall4
-
+#include "arm-features.h"
 
 #ifdef __ARM_EABI__
 
-__unified_syscall4:
-__unified_syscall:
-	
+/* expects:
+ * r0-r3 ... syscall arguments 0-3
+ * ip    ... syscall number
+ */
+FUNC_START	__unified_syscall_swi
+	.hidden	__unified_syscall_swi
+        stmfd	sp!,{r4,r5,r7,lr}
+	mov	r7, ip
+	LOAD_ARG4_5
+	swi	0
+	/* fallthrough to __unified4_syscall */
+FUNC_END	__unified_syscall_swi
+
+/* expects:
+ * r0    ... syscall return value
+ * original r4-r7 + lr on stack
+ */
+FUNC_START	__unified_syscall
+	.hidden	__unified_syscall
         cmn     r0, #4096
+#ifndef WANT_THREAD_SAFE
         rsbcs   r2, r0, #0
         ldrcs   r3, 1f
         mvncs   r0, #0
@@ -25,17 +32,28 @@
 	.balign 4
 1:
         .word   errno
-	
+#else
+	bcc	1f
+	rsb	r4, r0, #0
+	bl	__errno_location
+	str	r4, [r0]
+	mvn	r0, #0
+1:
+        ldmfd   sp!,{r4,r5,r7,pc}
+#endif
+FUNC_END	__unified_syscall
+
 /* here we go and "reuse" the return for weak-void functions */
 #include "dietuglyweaks.h"
 
-	mov	pc, lr			@ return
+	RET
 
-#else	
-	
-__unified_syscall4:
+#else
+
+FUNC_START	__unified_syscall4
 	ldmia	sp!, {r4, r5, r6}
-__unified_syscall:
+
+FUNC_START	__unified_syscall
 	cmn	r0, #4096
 	movcc	pc, lr			@ return value comes direct from kernel.
 
@@ -53,10 +71,13 @@
 /* here we go and "reuse" the return for weak-void functions */
 #include "dietuglyweaks.h"
 
-	mov	pc, lr			@ return
+	RET
 
 #ifndef WANT_THREAD_SAFE
+.align 2
 .L0:	.long 	errno
 #endif
+FUNC_END	__unified_syscall
+FUNC_END	__unified_syscall4
 
 #endif
diff -urN -x .git dietlibc-0.33/arm/waitpid.S dietlibc/arm/waitpid.S
--- dietlibc-0.33/arm/waitpid.S	2008-12-10 20:00:58.000000000 +0000
+++ dietlibc/arm/waitpid.S	2015-01-01 12:14:43.454938895 +0000
@@ -1,15 +1,8 @@
-.text
-#ifdef __ARM_EABI__
-.align	4
-#else	
-.align	2
-#endif
-.weak	waitpid
-.type	waitpid, %function
-waitpid:
-.global	__libc_waitpid
-.type	__libc_waitpid, %function
-__libc_waitpid:
-	mov	r3, #0
-	b	wait4
-	.size	waitpid, .-waitpid
+#include "arm-features.h"
+
+FUNC_START_WEAK	waitpid
+FUNC_START	__libc_waitpid
+ 	mov	r3, #0
+ 	b	wait4
+FUNC_END	__libc_waitpid
+FUNC_END	waitpid
diff -urN -x .git dietlibc-0.33/CHANGES dietlibc/CHANGES
--- dietlibc-0.33/CHANGES	2012-11-02 11:17:28.000000000 +0000
+++ dietlibc/CHANGES	2015-01-01 12:14:43.451605563 +0000
@@ -1,3 +1,19 @@
+0.34:
+  move stpcpy from libcompat to lib as it is now part of POSIX (Enrico Scholz)
+  add linux/seccomp.h linux/prctl.h linux/audit.h linux/elf-em.h linux/filter.h
+  SECURITY: make sure all assembler files mark the stack non-executable so
+    the kernel can map the stack of the whole program as non-executable
+  support compiling with clang (no cross compiling yet, and the resulting
+    binary code is significantly larger than with gcc)
+  implement experimental C11 threads
+  fix fgets (Andreas Frster)
+  add eventfd, inotify_init1, epoll_init1, accept4, recvmmsg, sendmmsg
+  add dup3, fanotify_init, fanotify_mark, signalfd4, timerfd_settime
+  add timerfd_gettime, setns, memfd_create, getrandom, syncfs
+  add preadv, pwritev
+  add getcontext, setcontext, makecontext, swapcontext (i386 and x86_64 only for now)
+  add implementation of hsearch and friends
+
 0.33:
   first stab at getting TLS to work in actual threads
   use fs: to find current thread on x86_64
diff -urN -x .git dietlibc-0.33/contrib/dnsd.c dietlibc/contrib/dnsd.c
--- dietlibc-0.33/contrib/dnsd.c	2010-09-25 17:03:25.000000000 +0000
+++ dietlibc/contrib/dnsd.c	2015-01-01 12:14:43.458272230 +0000
@@ -281,55 +281,54 @@
 }
 
 static void init_sockets(int* sock6,int* sock4,int port,char* v6ip,char* v4ip) {
-  int s4,s6;
+  int _s4,_s6;
   int one=1;
   *sock6=-1; *sock4=-1;
-  s6=socket(PF_INET6,SOCK_DGRAM,IPPROTO_UDP);
-  s4=socket(PF_INET,SOCK_DGRAM,IPPROTO_UDP);
-  if (s4==-1 && s6==-1) {
+  _s6=socket(PF_INET6,SOCK_DGRAM,IPPROTO_UDP);
+  _s4=socket(PF_INET,SOCK_DGRAM,IPPROTO_UDP);
+  if (_s4==-1 && _s6==-1) {
     perror("socket");
     return;
   }
-  if (s6!=-1) {
-    setsockopt(s6,SOL_SOCKET,SO_REUSEADDR,&one,sizeof(one));
+  if (_s6!=-1) {
+    setsockopt(_s6,SOL_SOCKET,SO_REUSEADDR,&one,sizeof(one));
     memset(&sa6,0,sizeof(sa6));
     sa6.sin6_family=PF_INET6;
     sa6.sin6_port=htons(port);
-    if (bind(s6,(struct sockaddr*)&sa6,sizeof(struct sockaddr_in6))==-1) {
+    if (bind(_s6,(struct sockaddr*)&sa6,sizeof(struct sockaddr_in6))==-1) {
       perror("bind IPv6");
-      close(s6);
-      s6=-1;
+      close(_s6);
+      _s6=-1;
     }
   }
-  if (s4!=-1) {
-    setsockopt(s4,SOL_SOCKET,SO_REUSEADDR,&one,sizeof(one));
+  if (_s4!=-1) {
+    setsockopt(_s4,SOL_SOCKET,SO_REUSEADDR,&one,sizeof(one));
     memset(&sa4,0,sizeof(sa4));
     sa4.sin_family=PF_INET;
     sa4.sin_port=htons(port);
-    if (bind(s4,(struct sockaddr*)&sa4,sizeof(struct sockaddr_in))==-1) {
-      if (errno!=EADDRINUSE || s6==-1)
+    if (bind(_s4,(struct sockaddr*)&sa4,sizeof(struct sockaddr_in))==-1) {
+      if (errno!=EADDRINUSE || _s6==-1)
 	perror("bind IPv4");
-      close(s4);
-      s4=-1;
+      close(_s4);
+      _s4=-1;
     }
   }
-  if (s4==-1 && s6==-1) return;
+  if (_s4==-1 && _s6==-1) return;
 
   {
     int val=255;
-    int one=1;
-    if (s6!=-1) {
+    if (_s6!=-1) {
       struct ipv6_mreq opt;
-      setsockopt(s6,IPPROTO_IPV6,IPV6_UNICAST_HOPS,&val,sizeof(val));
-      setsockopt(s6,IPPROTO_IPV6,IPV6_MULTICAST_LOOP,&one,sizeof(one));
+      setsockopt(_s6,IPPROTO_IPV6,IPV6_UNICAST_HOPS,&val,sizeof(val));
+      setsockopt(_s6,IPPROTO_IPV6,IPV6_MULTICAST_LOOP,&one,sizeof(one));
       memcpy(&opt.ipv6mr_multiaddr,v6ip,16);
       opt.ipv6mr_interface=0;
-      setsockopt(s6,IPPROTO_IPV6,IPV6_ADD_MEMBERSHIP,&opt,sizeof opt);
-      setsockopt(s6,IPPROTO_IPV6,IPV6_PKTINFO,&one,sizeof one);
+      setsockopt(_s6,IPPROTO_IPV6,IPV6_ADD_MEMBERSHIP,&opt,sizeof opt);
+      setsockopt(_s6,IPPROTO_IPV6,IPV6_PKTINFO,&one,sizeof one);
     }
     {
       struct ip_mreq opt;
-      int s=(s4==-1?s6:s4);
+      int s=(_s4==-1?_s6:_s4);
       setsockopt(s,SOL_IP,IP_TTL,&val,sizeof(val));
       memcpy(&opt.imr_multiaddr.s_addr,v4ip,4);
       opt.imr_interface.s_addr=0;
@@ -338,8 +337,8 @@
     }
   }
 
-  *sock4=s4;
-  *sock6=s6;
+  *sock4=_s4;
+  *sock6=_s6;
 }
 
 int main() {
diff -urN -x .git dietlibc-0.33/.cvsignore dietlibc/.cvsignore
--- dietlibc-0.33/.cvsignore	2007-03-09 13:42:12.000000000 +0000
+++ dietlibc/.cvsignore	2015-01-01 12:14:43.451605563 +0000
@@ -28,3 +28,5 @@
 bin-x86_64
 pic-x86_64
 cycles
+include/errno_definition.h
+bin-x32
diff -urN -x .git dietlibc-0.33/diet.c dietlibc/diet.c
--- dietlibc-0.33/diet.c	2012-11-02 11:17:28.000000000 +0000
+++ dietlibc/diet.c	2015-01-01 12:14:43.461605562 +0000
@@ -25,10 +25,11 @@
 }
 
 static const char* Os[] = {
-  "i386","-Os","-mpreferred-stack-boundary=2",
+  "i386","-Os","-mpreferred-stack-boundary=4",
 	 "-falign-functions=1","-falign-jumps=1",
 	 "-falign-loops=1","-fomit-frame-pointer",0,
   "x86_64","-Os",0,
+  "x32","-Os",0,
   "sparc","-Os","-mcpu=supersparc",0,
   "sparc64","-Os","-m64","-mhard-quad-float",0,
   "alpha","-Os","-fomit-frame-pointer",0,
@@ -41,7 +42,6 @@
   "s390x","-Os","-fomit-frame-pointer",0,
   "sh","-Os","-fomit-frame-pointer",0,
   "ia64","-Os","-fno-omit-frame-pointer",0,
-  "x86_64","-Os","-fstrict-aliasing","-momit-leaf-frame-pointer","-mfancy-math-387",0,
   0};
 
 static void usage(void) {
@@ -120,7 +120,6 @@
     } else break;
   } while (1);
   {
-    int i;
     m=0;
     for (i=1; i<argc; ++i) {
       if (!strcmp(argv[i],"-m32")) m=32; else
@@ -144,6 +143,10 @@
       memmove(shortplatform,argv[1],(size_t)(tmp2-cc));
       platform[tmp2-cc+len]=0;
       if (shortplatform[0]=='i' && shortplatform[2]=='8' && shortplatform[3]=='6') shortplatform[1]='3';
+      else if (strcmp(shortplatform, "powerpc") == 0)
+        strcpy(shortplatform, "ppc");
+      else if (strcmp(shortplatform, "powerpc64") == 0)
+        strcpy(shortplatform, "ppc64");
     } else {
 #ifdef __sparc__
 #ifdef __arch64__
@@ -193,15 +196,14 @@
       shortplatform="ia64";
 #endif
       {
-	char *tmp=platform+strlen(platform);
-	strcpy(tmp,shortplatform);
-	shortplatform=tmp;
+	char *tmp4=platform+strlen(platform);
+	strcpy(tmp4,shortplatform);
+	shortplatform=tmp4;
       }
     }
     /* MIPS needs special handling.  If argv contains -EL, change
      * platform name to mipsel */
     if (!strcmp(shortplatform,"mips")) {
-      int i;
       for (i=1; i<argc; ++i)
 	if (!strcmp(argv[i],"-EL"))
 	  strcpy(shortplatform,"mipsel");
@@ -328,7 +330,7 @@
 	}
 	if (mangleopts)
 	  if (argv[i][0]=='-' && (argv[i][1]=='O' || argv[i][1]=='f' ||
-				  (argv[i][1]=='m' && argv[i][2]!='3' && argv[i][2]!='6'))) {
+				  (argv[i][1]=='m' && argv[i][2]!='3' && argv[i][2]!='6' && argv[i][2]!='x'))) {
 	    if (strcmp(argv[i],"-fpic") && strcmp(argv[i],"-fno-pic"))
 	      continue;
 	  }
@@ -351,7 +353,7 @@
 
 	{
 	  int fd;
-	  char* tmp=getenv("HOME");
+	  tmp=getenv("HOME");
 	  if (tmp) {
 	    if (strlen(tmp)+strlen(cc)<900) {
 	      strcpy(manglebuf,tmp);
@@ -362,7 +364,6 @@
 	      if ((fd=open(manglebuf,O_RDONLY))>=0) {
 		int len=read(fd,manglebuf,1023);
 		if (len>0) {
-		  int i;
 		  manglebuf[len]=0;
 		  *dest++=manglebuf;
 		  for (i=1; i<len; ++i) {
@@ -416,7 +417,6 @@
 #endif
       *dest=0;
       if (verbose) {
-	int i;
 	for (i=0; newargv[i]; i++) {
 	  __write2(newargv[i]);
 	  __write2(" ");
diff -urN -x .git dietlibc-0.33/dietdirent.h dietlibc/dietdirent.h
--- dietlibc-0.33/dietdirent.h	2002-07-03 20:33:37.000000000 +0000
+++ dietlibc/dietdirent.h	2015-01-01 12:14:43.461605562 +0000
@@ -1,8 +1,28 @@
 #include <sys/shm.h>
 
+#include "dietpagesize.h"
+
 struct __dirstream {
   int fd;
-  char buf[PAGE_SIZE-(sizeof (int)*3)];
   unsigned int num;
   unsigned int cur;
+  unsigned char is_64;
+  char buf[] __attribute__((__aligned__(8)));
 };				/* stream data from opendir() */
+
+struct linux_dirent {
+  unsigned long   d_ino;
+  unsigned long   d_off;
+  unsigned short  d_reclen;
+  char            d_name[1];
+};
+
+struct linux_dirent64 {
+  uint64_t        d_ino;
+  int64_t         d_off;
+  unsigned short  d_reclen;
+  unsigned char   d_type;
+  char            d_name[0];
+};
+
+#define __DIRSTREAM_BUF_SIZE	(__DIET_PAGE_SIZE - offsetof(struct __dirstream, buf))
diff -urN -x .git dietlibc-0.33/dietelfinfo.h dietlibc/dietelfinfo.h
--- dietlibc-0.33/dietelfinfo.h	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/dietelfinfo.h	2015-01-01 12:14:43.461605562 +0000
@@ -0,0 +1,20 @@
+#include "dietfeatures.h"
+
+#ifdef WANT_ELFINFO
+#include <elf.h>
+#include <endian.h>
+#include <stdint.h>
+
+/* TODO: exported interface from <linux/elf.h> has been changed in 2.6.25 so
+ * the 'elf_addr_t' type is not available anymore. Hence, derive it from
+ * __WORDSIZE__. */
+
+#if __WORDSIZE == 64
+typedef uint64_t	__diet_elf_addr_t;
+#elif __WORDSIZE == 32
+typedef uint32_t	__diet_elf_addr_t;
+#endif
+
+__diet_elf_addr_t const *	__get_elf_aux_value(unsigned int tag)
+	__attribute__((__visibility__("hidden"),__const__)) __pure;
+#endif
diff -urN -x .git dietlibc-0.33/dietfeatures.h dietlibc/dietfeatures.h
--- dietlibc-0.33/dietfeatures.h	2012-11-02 11:17:28.000000000 +0000
+++ dietlibc/dietfeatures.h	2015-01-01 12:14:43.461605562 +0000
@@ -29,7 +29,7 @@
 #define WANT_TLS
 
 /* make the startcode, etc. dynamic aware ({con,de}structors) */
-/* #define WANT_DYNAMIC */
+// #define WANT_DYNAMIC
 
 /* GDB support in the dynamic linker */
 #define WANT_LD_SO_GDB_SUPPORT
@@ -142,6 +142,16 @@
 #define WANT_SSP
 #endif
 
+/* Some platforms like x86_64, ppc* or mips do not have a fixed PAGE_SIZE.
+ * Select WANT_DYN_PAGESIZE to detect the current PAGE_SIZE at runtime. Else,
+ * define WANT_STATIC_PAGESIZE to a proper value (must be a power of 2)
+ * matching the configured pagesize of the kernel where your binaries are
+ * running on.
+ *
+ * Selecting WANT_DYN_PAGESIZE enlarges the startup code by around 1-3
+ * instructions and might add an additional __elfinfo symbol */
+#define WANT_DYN_PAGESIZE
+/* #define WANT_STATIC_PAGESIZE 0x10000UL */
 
 
 /* stop uncommenting here ;-) */
@@ -161,13 +171,6 @@
 #define WANT_SMALL_STRING_ROUTINES
 #endif
 
-#ifdef WANT_THREAD_SAFE
-#ifndef __ASSEMBLER__
-#define errno (*__errno_location())
-#define _REENTRANT
-#endif
-#endif
-
 #ifdef __DYN_LIB
 /* with shared libraries you MUST have a dynamic aware startcode */
 #ifndef WANT_DYNAMIC
@@ -179,4 +182,12 @@
 #endif
 #endif
 
+#if defined(__x86_64__) && defined(__ILP32__)
+#undef WANT_LARGEFILE_BACKCOMPAT
+#endif
+
+#ifdef WANT_DYN_PAGESIZE
+#define WANT_ELFINFO
+#endif
+
 #endif
diff -urN -x .git dietlibc-0.33/dietpagesize.h dietlibc/dietpagesize.h
--- dietlibc-0.33/dietpagesize.h	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/dietpagesize.h	2015-01-01 12:14:43.461605562 +0000
@@ -0,0 +1,31 @@
+#ifndef H_DIETLIBC_DIETPAGESIZE_H
+#define H_DIETLIBC_DIETPAGESIZE_H
+
+#include <strings.h>
+#include "dietfeatures.h"
+
+extern size_t __libc_getpagesize(void) __attribute__((__const__)) __pure;
+
+#if defined(WANT_STATIC_PAGESIZE)
+#  define __DIET_PAGE_SIZE_PREDEF	(WANT_STATIC_PAGESIZE)
+#  define __DIET_PAGE_SHIFT_PREDEF	(ffs(__DIET_PAGE_SIZE_PREDEF)-1)
+#elif defined(__alpha__) || defined(__sparc__)
+#  define __DIET_PAGE_SIZE_PREDEF	(8192UL)
+#  define __DIET_PAGE_SHIFT_PREDEF	(13)
+#elif defined(__powerpc64__)
+#  define __DIET_PAGE_SIZE_PREDEF	(65536UL)
+#  define __DIET_PAGE_SHIFT_PREDEF	(16)
+#else
+#  define __DIET_PAGE_SIZE_PREDEF	(4096UL)
+#  define __DIET_PAGE_SHIFT_PREDEF	(12)
+#endif
+
+#ifdef WANT_DYN_PAGESIZE
+#  define __DIET_PAGE_SIZE	(__libc_getpagesize())
+#  define __DIET_PAGE_SHIFT	(ffs(__DIET_PAGE_SIZE)-1)
+#else
+#  define __DIET_PAGE_SIZE	__DIET_PAGE_SIZE_PREDEF
+#  define __DIET_PAGE_SHIFT	__DIET_PAGE_SHIFT_PREDEF
+#endif
+
+#endif	/* H_DIETLIBC_DIETPAGESIZE_H */
diff -urN -x .git dietlibc-0.33/dietuglyweaks.h dietlibc/dietuglyweaks.h
--- dietlibc-0.33/dietuglyweaks.h	2004-06-30 05:52:30.000000000 +0000
+++ dietlibc/dietuglyweaks.h	2015-01-01 12:14:43.461605562 +0000
@@ -4,6 +4,18 @@
 /* if you change something here ... KNOW what you're doing !
  * it'll effect ALL platforms ! */
 
+#ifdef __clang__
+.macro DEF_G name
+.global \name
+.type \name,@function
+\name:
+.endm
+.macro DEF_W name
+.weak \name
+.type \name,@function
+\name:
+.endm
+#else
 .macro DEF_G name
 .global \name
 .type \name,function
@@ -14,6 +26,7 @@
 .type \name,function
 \name:
 .endm
+#endif
 
 DEF_W __fflush_stderr
 DEF_W __fflush_stdin
diff -urN -x .git dietlibc-0.33/dietunaligned.h dietlibc/dietunaligned.h
--- dietlibc-0.33/dietunaligned.h	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/dietunaligned.h	2015-01-01 12:14:43.461605562 +0000
@@ -0,0 +1,35 @@
+#ifndef H_DIETLIBC_UNALIGNED_H
+#define H_DIETLIBC_UNALIGNED_H
+
+#include <string.h>
+#include <inttypes.h>
+
+#define read_unaligned(_src)						\
+	({								\
+		struct {						\
+			__typeof__(*(_src))	a;			\
+		} __attribute__((__packed__)) *_tmp = (void *)(_src);	\
+		_tmp->a;						\
+	})
+
+#define read_unaligned_s(_src, _type, _attr)				\
+	read_unaligned((__typeof__(&((_type *)(0))->_attr))(		\
+			       (uintptr_t)(_src) +			\
+			       __builtin_offsetof(_type, _attr)))	\
+
+
+#define write_unaligned(_v, _dst)		\
+	({								\
+		struct {						\
+			__typeof__(*(_dst))	a;			\
+		} __attribute__((__packed__)) *_tmp = (void *)(_dst);	\
+		_tmp->a = (_v);						\
+	})
+
+#define write_unaligned_s(_v, _dst, _type, _attr)			\
+	write_unaligned(_v,						\
+			(__typeof__(&((_type *)(0))->_attr))(		\
+				(uintptr_t)(_dst) +			\
+				__builtin_offsetof(_type, _attr)))	\
+
+#endif	/* H_DIETLIBC_UNALIGNED_H */
diff -urN -x .git dietlibc-0.33/dynlinker/ldso_start.S dietlibc/dynlinker/ldso_start.S
--- dietlibc-0.33/dynlinker/ldso_start.S	2007-03-09 13:42:12.000000000 +0000
+++ dietlibc/dynlinker/ldso_start.S	2015-01-01 12:14:43.464938896 +0000
@@ -86,6 +86,15 @@
 	.long 0
 #endif
 
+/* __elfinfo must follow __environ immediately */
+.global __elfinfo
+__elfinfo:
+#if __WORDSIZE == 64
+	.quad 0
+#else
+	.long 0
+#endif
+
 .global fini_entry
 fini_entry:
 	.long 0
diff -urN -x .git dietlibc-0.33/dyn_start.c dietlibc/dyn_start.c
--- dietlibc-0.33/dyn_start.c	2008-05-06 17:18:34.000000000 +0000
+++ dietlibc/dyn_start.c	2015-01-01 12:14:43.464938896 +0000
@@ -54,10 +54,6 @@
     __deregister_frame_info(__EH_FRAME_BEGIN__);
 }
 
-#ifdef WANT_STACKGAP
-int stackgap(int argc,char* argv[],char* envp[]);
-#endif
-
 #ifndef __DYN_LIB_SHARED
 /* pre main, post _start */
 extern __attribute__((section(".init"))) void _init(void);
@@ -65,7 +61,7 @@
 int _dyn_start(int argc, char **argv, char **envp, structor dl_init);
 int _dyn_start(int argc, char **argv, char **envp, structor dl_init)
 {
-  int main(int argc, char **argv, char **envp);
+  int CALL_IN_STARTCODE(int argc, char **argv, char **envp);
 
 #ifndef __arm__
   /* GT: segfaults on arm, don't know why (for now) */
@@ -82,11 +78,7 @@
     __register_frame_info(__EH_FRAME_BEGIN__, &ob);
   }
 
-#ifdef WANT_STACKGAP
-  return stackgap(argc, argv, envp);
-#else
-  return main(argc, argv, envp);
-#endif
+  return CALL_IN_STARTCODE(argc, argv, envp);
 }
 #endif
 #endif
diff -urN -x .git dietlibc-0.33/FAQ dietlibc/FAQ
--- dietlibc-0.33/FAQ	2010-11-09 18:38:34.000000000 +0000
+++ dietlibc/FAQ	2015-01-01 12:14:43.451605563 +0000
@@ -246,7 +246,7 @@
    code.  Unfortunately, these options have been renamed on gcc 3.  You
    can fix this by creating a file ~/.diet/gcc containing this line:
 
-     -Os -fomit-frame-pointer -falign-jumps=1 -falign-loops=1 -mpreferred-stack-boundary=2
+     -Os -fomit-frame-pointer -falign-jumps=1 -falign-loops=1 -mpreferred-stack-boundary=4
 
    If you get this options not for diet -Os gcc but for diet -Os
    i386-linux-gcc, put this in ~/.diet/i386-linux-gcc instead.
diff -urN -x .git dietlibc-0.33/findcflags.sh dietlibc/findcflags.sh
--- dietlibc-0.33/findcflags.sh	2005-05-08 15:33:38.000000000 +0000
+++ dietlibc/findcflags.sh	2015-01-01 12:14:43.464938896 +0000
@@ -3,6 +3,6 @@
 case $version in
   2.9*) echo -march=i386 -Os -fomit-frame-pointer -malign-functions=1 -malign-jumps=1 -malign-loops=1 -mpreferred-stack-boundary=2 ;;
   3.0*) echo -march=i386 -Os -fomit-frame-pointer -malign-functions=1 -malign-jumps=1 -malign-loops=1 -mpreferred-stack-boundary=2 ;;
-  [34]*) echo -Os -fomit-frame-pointer -falign-functions=1 -falign-jumps=1 -falign-loops=1 -mpreferred-stack-boundary=2;;
+  [34]*) echo -Os -fomit-frame-pointer -falign-functions=1 -falign-jumps=1 -falign-loops=1 -mpreferred-stack-boundary=4;;
   *) echo -O2 -pipe -fomit-frame-pointer ;;
 esac
diff -urN -x .git dietlibc-0.33/.gitignore dietlibc/.gitignore
--- dietlibc-0.33/.gitignore	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/.gitignore	2015-01-01 12:14:43.451605563 +0000
@@ -0,0 +1,2 @@
+/.cvsps
+/include/errno_definition.h
diff -urN -x .git dietlibc-0.33/i386/accept4.S dietlibc/i386/accept4.S
--- dietlibc-0.33/i386/accept4.S	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/i386/accept4.S	2015-01-01 12:14:43.464938896 +0000
@@ -0,0 +1,4 @@
+#include <linuxnet.h>
+#include <syscalls.h>
+
+__socketcall(accept4,ACCEPT4)
diff -urN -x .git dietlibc-0.33/i386/dyn_syscalls.S dietlibc/i386/dyn_syscalls.S
--- dietlibc-0.33/i386/dyn_syscalls.S	2012-01-24 18:24:24.000000000 +0000
+++ dietlibc/i386/dyn_syscalls.S	2015-01-01 12:14:43.464938896 +0000
@@ -191,7 +191,6 @@
 #include "../syscalls.s/n_sigpending.S"
 #include "../syscalls.s/n_sigprocmask.S"
 #include "../syscalls.s/n_sigsuspend.S"
-#include "../syscalls.s/nice.S"
 #include "../syscalls.s/pause.S"
 #include "../syscalls.s/personality.S"
 #include "../syscalls.s/query_module.S"
diff -urN -x .git dietlibc-0.33/i386/getcontext.S dietlibc/i386/getcontext.S
--- dietlibc-0.33/i386/getcontext.S	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/i386/getcontext.S	2015-01-01 12:14:43.464938896 +0000
@@ -0,0 +1,45 @@
+#include "syscalls.h"
+
+.text
+.global getcontext
+.type getcontext,@function
+/* store current CPU context into struct ucontext* */
+getcontext:
+  movl 4(%esp),%eax	/* load ucontext* */
+  /* the registers are in uc_mcontext, which starts at offset 20 */
+  movw %gs,20(%eax)
+  movw %fs,24(%eax)
+  movw %es,28(%eax)
+  movw %ds,32(%eax)
+  movl %edi,36(%eax)
+  movl %esi,40(%eax)
+  movl %ebp,44(%eax)
+  /* skip esp until we stored ecx */
+  movl %ebx,52(%eax)
+  movl %edx,56(%eax)
+  movl %ecx,60(%eax)
+  lea 4(%esp),%ecx	/* store esp+4 to esp */
+  mov %ecx,48(%eax)
+  movl $0,64(%eax)	/* eax */
+  /* not touching trapno and err, no idea what do store there */
+  movl (%esp),%ecx
+  movl %ecx,76(%eax)	/* store return value from stack into eip of struct */
+  movw %cs,80(%eax)
+  /* 84: eflags */
+  /* 88: esp_at_signal */
+  movw %ss,92(%eax)
+
+  lea 236(%eax),%ecx
+  movl %ecx,96(%eax)
+  fnstenv (%ecx)
+  fldenv (%ecx)
+  mov %ebx,%edi
+  xor %ebx,%ebx
+  xor %ecx,%ecx
+  lea 108(%eax),%edx
+  mov $__NR_sigprocmask,%eax
+  int $0x80
+  mov %edi,%ebx
+  xor %eax,%eax
+  ret
+.size getcontext, .-getcontext
diff -urN -x .git dietlibc-0.33/i386/Makefile.add dietlibc/i386/Makefile.add
--- dietlibc-0.33/i386/Makefile.add	2012-01-24 18:24:24.000000000 +0000
+++ dietlibc/i386/Makefile.add	2015-01-01 12:14:43.464938896 +0000
@@ -1,7 +1,7 @@
 
 M:=$(shell ./findcflags.sh $(CC))
 LIBOBJ+=$(OBJDIR)/__ten.o $(OBJDIR)/md5asm.o $(OBJDIR)/__restore_rt.o \
-$(OBJDIR)/__CAS.o
+$(OBJDIR)/__CAS.o $(OBJDIR)/getcontext.o $(OBJDIR)/setcontext.o
 LIBMATH+=acos.o asin.o atan.o ceil.o cos.o exp.o exp10.o exp2.o expm1.o fabs.o floor.o hypot.o log.o log2.o log10.o sin.o sqrt.o copysign.o sincos.o __half.o ldexp.o ilogb.o cbrt.o log1p.o fmod.o libm2.o atan2.o tan.o
 LIBMATH:=$(filter-out acosh.o asinh.o atanh.o cbrt.o copysign.o exp10.o exp2.o expm1.o ilogb.o log2.o,$(LIBMATH))
 #CFLAGS+=-march=i386 -Os -fomit-frame-pointer -malign-functions=0 -malign-jumps=0 -malign-loops=0 -mpreferred-stack-boundary=2
diff -urN -x .git dietlibc-0.33/i386/recvmmsg.S dietlibc/i386/recvmmsg.S
--- dietlibc-0.33/i386/recvmmsg.S	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/i386/recvmmsg.S	2015-01-01 12:14:43.468272228 +0000
@@ -0,0 +1,4 @@
+#include <linuxnet.h>
+#include <syscalls.h>
+
+__socketcall(recvmmsg,RECVMMSG)
diff -urN -x .git dietlibc-0.33/i386/sendmmsg.S dietlibc/i386/sendmmsg.S
--- dietlibc-0.33/i386/sendmmsg.S	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/i386/sendmmsg.S	2015-01-01 12:14:43.468272228 +0000
@@ -0,0 +1,4 @@
+#include <linuxnet.h>
+#include <syscalls.h>
+
+__socketcall(sendmmsg,SENDMMSG)
diff -urN -x .git dietlibc-0.33/i386/setcontext.S dietlibc/i386/setcontext.S
--- dietlibc-0.33/i386/setcontext.S	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/i386/setcontext.S	2015-01-01 12:14:43.468272228 +0000
@@ -0,0 +1,48 @@
+#include "syscalls.h"
+
+.text
+.global __setcontext_trampoline
+.type __setcontext_trampoline,@function
+__setcontext_trampoline:
+  mov %ebx,4(%esp)
+  /* fall through */
+.size __setcontext_trampoline,.-__setcontext_trampoline
+
+.global setcontext
+.type setcontext,@function
+/* switch to stored CPU context from struct ucontext* */
+setcontext:
+  movl 4(%esp),%eax	/* load ucontext* */
+  /* first, load the signal mask */
+  movl %ebx,%edi
+  xorl %edx,%edx
+  movl $2,%ebx	/* SIG_SETMASK */
+  lea 108(%eax),%ecx
+  movl $__NR_sigprocmask,%eax
+  int $0x80
+  cmp $-4095,%eax
+  jb .Lnoerror
+  jmp __error_unified_syscall
+.Lnoerror:
+  movl 4(%esp),%eax	/* load ucontext* */
+  mov %edi,%ebx
+  lea 236(%eax),%ecx
+  fldenv (%ecx)
+
+  /* the registers are in uc_mcontext, which starts at offset 20 */
+  /* do not restore gs because it's thread-specific */
+  movw 24(%eax),%fs
+  movw 28(%eax),%es
+  movw 32(%eax),%ds
+  movl 36(%eax),%edi
+  movl 40(%eax),%esi
+  movl 44(%eax),%ebp
+  movl 48(%eax),%esp
+  movw 92(%eax),%ss
+  movl 52(%eax),%ebx
+  movl 56(%eax),%edx
+  movl 60(%eax),%ecx
+
+  movl 76(%eax),%eax
+  jmp *%eax
+.size setcontext, .-setcontext
diff -urN -x .git dietlibc-0.33/i386/start.S dietlibc/i386/start.S
--- dietlibc-0.33/i386/start.S	2012-01-24 18:24:24.000000000 +0000
+++ dietlibc/i386/start.S	2015-01-01 12:14:43.468272228 +0000
@@ -20,12 +20,18 @@
 	PIC_INIT			/* non-PIC: this is an empty line */
 	PUT_VAR %esi, environ, %ecx	/* non-PIC: movl %esi,environ */
 
-#ifdef WANT_SYSENTER
+#if defined(WANT_ELFINFO) || defined(WANT_SYSENTER)
 /* skip environment, scan for NULL */
 1:
 	lodsl
 	testl	%eax,%eax
 	jnz	1b
+#  ifdef WANT_ELFINFO
+	PUT_VAR %esi, __elfinfo, %ecx
+#  endif
+#endif
+
+#ifdef WANT_SYSENTER
 /* The ELF auxvec follows the environment, consists of key/value pairs.
    We are looking for key 32, which stands for the vsyscall page */
 1:
diff -urN -x .git dietlibc-0.33/i386/syscalls.h dietlibc/i386/syscalls.h
--- dietlibc-0.33/i386/syscalls.h	2012-01-24 18:24:24.000000000 +0000
+++ dietlibc/i386/syscalls.h	2015-01-01 12:14:43.468272228 +0000
@@ -339,6 +339,23 @@
 #define __NR_fanotify_init	338
 #define __NR_fanotify_mark	339
 #define __NR_prlimit64		340
+#define __NR_name_to_handle_at 341
+#define __NR_open_by_handle_at 342
+#define __NR_clock_adjtime 343
+#define __NR_syncfs 344
+#define __NR_sendmmsg 345
+#define __NR_setns 346
+#define __NR_process_vm_readv 347
+#define __NR_process_vm_writev 348
+#define __NR_kcmp 349
+#define __NR_finit_module 350
+#define __NR_sched_setattr 351
+#define __NR_sched_getattr 352
+#define __NR_renameat2 353
+#define __NR_seccomp 354
+#define __NR_getrandom 355
+#define __NR_memfd_create 356
+
 
 #define syscall_weak(name,wsym,sym) \
 .text; \
@@ -368,7 +385,6 @@
 .Lend##sym: ; \
 .size sym,.Lend##sym-sym
 
-#ifndef __PIC__
 #define __socketcall(name,NAME) \
 .text; \
 .type name,@function; \
@@ -381,6 +397,3 @@
 	jmp socketcall; \
 .Lend##name:; \
 .size name,.Lend##name-name
-#else
-#define __socketcall(name,NAME)
-#endif
diff -urN -x .git dietlibc-0.33/ia64/clone.S dietlibc/ia64/clone.S
--- dietlibc-0.33/ia64/clone.S	2006-06-23 17:29:33.000000000 +0000
+++ dietlibc/ia64/clone.S	2015-01-01 12:14:43.468272228 +0000
@@ -1,4 +1,4 @@
-/* This is untested code which probably wont work out of the box! */
+/* This is untested code which probably won't work out of the box! */
 
 #include "syscalls.h"
 #include <errno.h>
@@ -43,4 +43,5 @@
 	br.call.dptk.few b0=__error_unified_syscall
 	br.ret.sptk.few b0
 .endp __clone
+.endp __clone2
 .size __clone, . - __clone
diff -urN -x .git dietlibc-0.33/ia64/Makefile.add dietlibc/ia64/Makefile.add
--- dietlibc-0.33/ia64/Makefile.add	2012-01-24 18:24:24.000000000 +0000
+++ dietlibc/ia64/Makefile.add	2015-01-01 12:14:43.468272228 +0000
@@ -1,2 +1,2 @@
 VPATH:=ia64:syscalls.s:$(VPATH)
-LIBOBJ+=$(OBJDIR)/__time.o $(OBJDIR)/__waitpid.o $(OBJDIR)/__nice.o $(OBJDIR)/__alarm.o $(OBJDIR)/__CAS.o
+LIBOBJ+=$(OBJDIR)/__time.o $(OBJDIR)/__waitpid.o $(OBJDIR)/__alarm.o $(OBJDIR)/__CAS.o $(OBJDIR)/__pause.o
diff -urN -x .git dietlibc-0.33/ia64/__pause.c dietlibc/ia64/__pause.c
--- dietlibc-0.33/ia64/__pause.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/ia64/__pause.c	2015-01-01 12:14:43.468272228 +0000
@@ -0,0 +1,10 @@
+#include <unistd.h>
+#include <signal.h>
+
+int pause(void)
+{
+  sigset_t set;
+  sigemptyset(&set);
+  sigprocmask(SIG_BLOCK, NULL, &set);
+  return sigsuspend(&set);
+}
diff -urN -x .git dietlibc-0.33/ia64/start.S dietlibc/ia64/start.S
--- dietlibc-0.33/ia64/start.S	2006-05-29 16:30:53.000000000 +0000
+++ dietlibc/ia64/start.S	2015-01-01 12:14:43.468272228 +0000
@@ -40,6 +40,16 @@
 	;;
 	st8  [r14] = out2           /* store envp in environ */
 
+#ifdef WANT_ELFINFO
+#  warning "MAKE ME IE64 CODE!"
+1:	ld8	r9 = [out2], 8	    /* load *envp and increment it */
+	orr	r9 = r9, r9	    /* test for NULL */
+	bne	1b
+
+	adds r14 = 8, r14	    /* __elfinfo = environ + 8 */
+	st8  [r14] = out2           /* store envp in __elfinfo */
+#endif
+
 #ifdef WANT_DYNAMIC
 /* FIXME: dl_init parameter ??? */
 	br.call.sptk.few rp = _dyn_start
diff -urN -x .git dietlibc-0.33/ia64/syscalls.h dietlibc/ia64/syscalls.h
--- dietlibc-0.33/ia64/syscalls.h	2008-12-10 20:00:58.000000000 +0000
+++ dietlibc/ia64/syscalls.h	2015-01-01 12:14:43.468272228 +0000
@@ -289,6 +289,34 @@
 #define __NR_timerfd_create		1310
 #define __NR_timerfd_settime		1311
 #define __NR_timerfd_gettime		1312
+#define __NR_signalfd4			1313
+#define __NR_eventfd2			1314
+#define __NR_epoll_create1		1315
+#define __NR_dup3			1316
+#define __NR_pipe2			1317
+#define __NR_inotify_init1		1318
+#define __NR_preadv			1319
+#define __NR_pwritev			1320
+#define __NR_rt_tgsigqueueinfo		1321
+#define __NR_recvmmsg			1322
+#define __NR_fanotify_init		1323
+#define __NR_fanotify_mark		1324
+#define __NR_prlimit64			1325
+#define __NR_name_to_handle_at		1326
+#define __NR_open_by_handle_at  	1327
+#define __NR_clock_adjtime		1328
+#define __NR_syncfs			1329
+#define __NR_setns			1330
+#define __NR_sendmmsg			1331
+#define __NR_process_vm_readv		1332
+#define __NR_process_vm_writev		1333
+#define __NR_accept4			1334
+#define __NR_finit_module		1335
+#define __NR_sched_setattr		1336
+#define __NR_sched_getattr		1337
+#define __NR_renameat2			1338
+#define __NR_getrandom			1339
+#define __NR_memfd_create		1340
 
 #define syscall(name, sym) \
 .text; \
diff -urN -x .git dietlibc-0.33/ia64/unified.S dietlibc/ia64/unified.S
--- dietlibc-0.33/ia64/unified.S	2006-06-23 17:29:33.000000000 +0000
+++ dietlibc/ia64/unified.S	2015-01-01 12:14:43.468272228 +0000
@@ -16,9 +16,7 @@
 .text
 
 .globl __unified_syscall
-.proc  __unified_syscall
 .globl __error_unified_syscall
-.proc  __error_unified_syscall
 .globl _exit
 .proc  _exit
 
@@ -27,11 +25,16 @@
 .endp _exit
 .size _exit, . - _exit
 
+.proc  __unified_syscall
 __unified_syscall:
 	break.i 0x100000
 	movl r2=errno
 	cmp.eq p6,p0=-1,r10
 	;;
+.endp __unified_syscall
+.size __unified_syscall, . - __unified_syscall
+
+.proc  __error_unified_syscall
 __error_unified_syscall:
 (p6)    st4 [r2]=r8
 (p6)    mov r8=-1
@@ -39,6 +42,6 @@
 #include "dietuglyweaks.h"
 
 	br.ret.sptk.few rp
+.endp __error_unified_syscall
 
-.size __unified_syscall, __error_unified_syscall - __unified_syscall
 .size __error_unified_syscall, . - __error_unified_syscall
diff -urN -x .git dietlibc-0.33/include/asm/posix_types.h dietlibc/include/asm/posix_types.h
--- dietlibc-0.33/include/asm/posix_types.h	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/include/asm/posix_types.h	2015-01-01 12:14:43.471605562 +0000
@@ -0,0 +1,7 @@
+#ifndef _ASM_POSIX_TYPES_H
+#define _ASM_POSIX_TYPES_H
+
+typedef long __kernel_long_t;
+typedef unsigned long __kernel_ulong_t;
+
+#endif
diff -urN -x .git dietlibc-0.33/include/asm/prctl.h dietlibc/include/asm/prctl.h
--- dietlibc-0.33/include/asm/prctl.h	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/include/asm/prctl.h	2015-01-01 12:14:43.471605562 +0000
@@ -0,0 +1,18 @@
+#ifndef _ASM_PRCTL_H
+#define _ASM_PRCTL_H
+
+#if defined(__x86_64__)
+
+#define ARCH_SET_GS 0x1001
+#define ARCH_SET_FS 0x1002
+#define ARCH_GET_FS 0x1003
+#define ARCH_GET_GS 0x1004
+
+#elif defined(__i386__)
+
+#else
+
+#warning "need asm/prctl.h for this platform"
+#endif
+
+#endif
diff -urN -x .git dietlibc-0.33/include/dirent.h dietlibc/include/dirent.h
--- dietlibc-0.33/include/dirent.h	2012-11-02 11:17:28.000000000 +0000
+++ dietlibc/include/dirent.h	2015-01-01 12:14:43.471605562 +0000
@@ -42,8 +42,8 @@
 #endif
 struct dirent64 *readdir64 (DIR *__dirp) __THROW;
 void rewinddir (DIR *__dirp) __THROW;
-void seekdir (DIR *__dirp, long int __pos) __THROW;
-long int telldir (DIR *__dirp) __THROW;
+void seekdir (DIR *__dirp, long __pos) __THROW;
+long telldir (DIR *__dirp) __THROW;
 
 int scandir(const char *dir, struct dirent ***namelist,
       int (*selection)(const struct dirent *),
diff -urN -x .git dietlibc-0.33/include/dlfcn.h dietlibc/include/dlfcn.h
--- dietlibc-0.33/include/dlfcn.h	2005-01-31 12:53:33.000000000 +0000
+++ dietlibc/include/dlfcn.h	2015-01-01 12:14:43.471605562 +0000
@@ -14,10 +14,10 @@
 
 __BEGIN_DECLS
 
-void *dlopen (const char *filename, int flag);
-const char *dlerror(void);
-void *dlsym(void *handle, const char *symbol);
-int dlclose (void *handle);
+void *dlopen (const char *filename, int flag) __THROWNL;
+const char *dlerror(void) __THROW;
+void *dlsym(void *handle, const char *symbol) __THROW;
+int dlclose (void *handle) __THROWNL;
 
 #ifdef _GNU_SOURCE
 typedef struct
diff -urN -x .git dietlibc-0.33/include/elf.h dietlibc/include/elf.h
--- dietlibc-0.33/include/elf.h	2010-09-25 17:03:25.000000000 +0000
+++ dietlibc/include/elf.h	2015-01-01 12:14:43.471605562 +0000
@@ -954,6 +954,15 @@
 
 #define	AT_SECURE	23		/* Boolean, was exec setuid-like?  */
 
+#define AT_BASE_PLATFORM 24		/* String identifying real platforms.*/
+
+#define AT_RANDOM	25		/* Address of 16 random bytes.  */
+
+#define AT_HWCAP2	26		/* More machine-dependent hints about
+					   processor capabilities.  */
+
+#define AT_EXECFN	31		/* Filename of executable.  */
+
 /* Pointer to the global system page used for system calls and other
    nice things.  */
 #define AT_SYSINFO	32
diff -urN -x .git dietlibc-0.33/include/endian.h dietlibc/include/endian.h
--- dietlibc-0.33/include/endian.h	2006-05-29 16:30:53.000000000 +0000
+++ dietlibc/include/endian.h	2015-01-01 12:14:43.471605562 +0000
@@ -39,10 +39,18 @@
 # define __LONG_LONG_PAIR(HI, LO) HI, LO
 #endif
 
-#if defined(__alpha__) || defined(__mips64__) || defined(__sparc_v9__) || defined(__x86_64__) || defined(__ia64__) || defined(__powerpc64__) || defined(__s390x__)
+#if defined(__alpha__) || defined(__mips64__) || defined(__sparc_v9__) || defined(__ia64__) || defined(__powerpc64__) || defined(__s390x__)
 #define __WORDSIZE 64
 #endif
 
+#if defined(__x86_64__)
+#if defined(__ILP32__)
+#define __OFF_T_MATCHES_OFF64_T
+#else
+#define __WORDSIZE 64
+#endif
+#endif
+
 #if defined(__x86_64__) || defined(__powerpc64__) || defined(__sparc_v9__)
 #define __WORDSIZE_COMPAT32 1
 #endif
@@ -51,7 +59,9 @@
 #define __WORDSIZE 64
 #endif
 
-#ifndef __WORDSIZE
+#ifdef __WORDSIZE
+#define __OFF_T_MATCHES_OFF64_T
+#else
 #define __WORDSIZE 32
 #endif
 
diff -urN -x .git dietlibc-0.33/include/errno.h dietlibc/include/errno.h
--- dietlibc-0.33/include/errno.h	2010-09-25 17:03:26.000000000 +0000
+++ dietlibc/include/errno.h	2015-01-01 12:14:43.471605562 +0000
@@ -704,11 +704,7 @@
 
 __BEGIN_DECLS
 
-#ifndef _REENTRANT
-extern int errno;
-#else
-#define errno (*__errno_location())
-#endif
+#include <errno_definition.h>
 
 extern int *__errno_location(void);
 
diff -urN -x .git dietlibc-0.33/include/fcntl.h dietlibc/include/fcntl.h
--- dietlibc-0.33/include/fcntl.h	2012-11-02 11:17:28.000000000 +0000
+++ dietlibc/include/fcntl.h	2015-01-01 12:14:43.471605562 +0000
@@ -14,8 +14,6 @@
 
 #if defined(__i386__) || defined(__s390__) || defined(__x86_64__) || defined(__ia64__)
 
-/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
-   located on an ext2 file system */
 #define O_ACCMODE	   0003
 #define O_RDONLY	     00
 #define O_WRONLY	     01
@@ -27,13 +25,17 @@
 #define O_APPEND	  02000
 #define O_NONBLOCK	  04000
 #define O_NDELAY	O_NONBLOCK
-#define O_SYNC		 010000
+#define O_DSYNC		 010000
 #define FASYNC		 020000	/* fcntl, for BSD compatibility */
 #define O_DIRECT	 040000	/* direct disk access hint - currently ignored */
 #define O_LARGEFILE	0100000
 #define O_DIRECTORY	0200000	/* must be a directory */
 #define O_NOFOLLOW	0400000 /* don't follow links */
 #define O_NOATIME	01000000
+#define O_CLOEXEC	02000000
+#define O_SYNC		(O_DSYNC|04000000)
+#define O_PATH		010000000
+#define O_TMPFILE	020000000
 
 #define F_DUPFD		0	/* dup */
 #define F_GETFD		1	/* get close_on_exec */
@@ -96,8 +98,6 @@
 
 #elif defined(__alpha__)
 
-/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
-   located on an ext2 file system */
 #define O_ACCMODE	  0003
 #define O_RDONLY	    00
 #define O_WRONLY	    01
@@ -110,13 +110,17 @@
 #define O_NONBLOCK	 00004
 #define O_APPEND	 00010
 #define O_NDELAY	O_NONBLOCK
-#define O_SYNC		040000
+#define O_DSYNC		040000
 #define FASYNC		020000	/* fcntl, for BSD compatibility */
 #define O_DIRECTORY	0100000	/* must be a directory */
 #define O_NOFOLLOW	0200000 /* don't follow links */
 #define O_LARGEFILE	0400000 /* will be set by the kernel on every open */
 #define O_DIRECT	02000000	/* direct disk access - should check with OSF/1 */
 #define O_NOATIME	04000000
+#define O_CLOEXEC	010000000
+#define O_SYNC		(020000000|O_DSYNC)
+#define O_PATH		040000000
+#define O_TMPFILE	0100000000
 
 #define F_DUPFD		0	/* dup */
 #define F_GETFD		1	/* get close_on_exec */
@@ -167,14 +171,12 @@
 
 #elif defined(__mips__)
 
-/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
-   located on an ext2 file system */
 #define O_ACCMODE	0x0003
 #define O_RDONLY	0x0000
 #define O_WRONLY	0x0001
 #define O_RDWR		0x0002
 #define O_APPEND	0x0008
-#define O_SYNC		0x0010
+#define O_DSYNC		0x0010
 #define O_NONBLOCK	0x0080
 #define O_CREAT         0x0100	/* not fcntl */
 #define O_TRUNC		0x0200	/* not fcntl */
@@ -182,10 +184,14 @@
 #define O_NOCTTY	0x0800	/* not fcntl */
 #define FASYNC		0x1000	/* fcntl, for BSD compatibility */
 #define O_LARGEFILE	0x2000	/* allow large file opens - currently ignored */
+#define O_SYNC		(0x4000|O_DSYNC)
 #define O_DIRECT	0x8000	/* direct disk access hint - currently ignored */
 #define O_DIRECTORY	0x10000	/* must be a directory */
 #define O_NOFOLLOW	0x20000	/* don't follow links */
 #define O_NOATIME	0x40000
+#define O_CLOEXEC	0x80000
+#define O_PATH		040000000
+#define O_TMPFILE	0100000000
 
 #define O_NDELAY	O_NONBLOCK
 
@@ -266,8 +272,6 @@
 
 #elif defined(__sparc__)
 
-/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
-   located on an ext2 file system */
 #define O_RDONLY	0x0000
 #define O_WRONLY	0x0001
 #define O_RDWR		0x0002
@@ -277,7 +281,7 @@
 #define O_CREAT		0x0200	/* not fcntl */
 #define O_TRUNC		0x0400	/* not fcntl */
 #define O_EXCL		0x0800	/* not fcntl */
-#define O_SYNC		0x2000
+#define O_DSYNC		0x2000
 #define O_NONBLOCK	0x4000
 #define O_NDELAY	(0x0004 | O_NONBLOCK)
 #define O_NOCTTY	0x8000	/* not fcntl */
@@ -286,6 +290,10 @@
 #define O_LARGEFILE	0x40000
 #define O_DIRECT        0x100000 /* direct disk access hint */
 #define O_NOATIME	0x200000
+#define O_CLOEXEC	0x400000
+#define O_SYNC		(0x800000|O_DSYNC)
+#define O_PATH		0x1000000
+#define O_TMPFILE	0x2000000
 
 #define F_DUPFD		0	/* dup */
 #define F_GETFD		1	/* get close_on_exec */
@@ -355,8 +363,6 @@
 
 #elif defined(__powerpc__) || defined(__powerpc64__)
 
-/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
-   located on an ext2 file system */
 #define O_ACCMODE	   0003
 #define O_RDONLY	     00
 #define O_WRONLY	     01
@@ -368,13 +374,17 @@
 #define O_APPEND	  02000
 #define O_NONBLOCK	  04000
 #define O_NDELAY	O_NONBLOCK
-#define O_SYNC		 010000
+#define O_DSYNC		 010000
 #define FASYNC		 020000	/* fcntl, for BSD compatibility */
 #define O_DIRECTORY      040000	/* must be a directory */
 #define O_NOFOLLOW      0100000	/* don't follow links */
 #define O_LARGEFILE     0200000
 #define O_DIRECT	0400000	/* direct disk access hint - currently ignored */
 #define O_NOATIME	01000000
+#define O_CLOEXEC	02000000
+#define O_SYNC		(O_DSYNC|04000000)
+#define O_PATH		010000000
+#define O_TMPFILE	020000000
 
 #define F_DUPFD		0	/* dup */
 #define F_GETFD		1	/* get close_on_exec */
@@ -439,8 +449,6 @@
 
 #elif defined (__arm__)
 
-/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
-   located on an ext2 file system */
 #define O_ACCMODE	   0003
 #define O_RDONLY	     00
 #define O_WRONLY	     01
@@ -452,13 +460,17 @@
 #define O_APPEND	  02000
 #define O_NONBLOCK	  04000
 #define O_NDELAY	O_NONBLOCK
-#define O_SYNC		 010000
+#define O_DSYNC		 010000
 #define FASYNC		 020000	/* fcntl, for BSD compatibility */
 #define O_DIRECTORY	 040000	/* must be a directory */
 #define O_NOFOLLOW	0100000	/* don't follow links */
 #define O_DIRECT	0200000	/* direct disk access hint - currently ignored */
 #define O_LARGEFILE	0400000
 #define O_NOATIME	01000000
+#define O_CLOEXEC	02000000
+#define O_SYNC		(O_DSYNC|04000000)
+#define O_PATH		010000000
+#define O_TMPFILE	020000000
 
 #define F_DUPFD		0	/* dup */
 #define F_GETFD		1	/* get close_on_exec */
@@ -536,19 +548,24 @@
 #define O_EXCL      00002000 /* not fcntl */
 #define O_LARGEFILE 00004000
 #define O_ASYNC     00020000
-#define O_SYNC      00100000
+#define __O_SYNC      00100000
 #define O_NONBLOCK  00200004 /* HPUX has separate NDELAY & NONBLOCK */
 #define O_NDELAY    O_NONBLOCK
 #define O_NOCTTY    00400000 /* not fcntl */
 #define O_DSYNC     01000000 /* HPUX only */
 #define O_RSYNC     02000000 /* HPUX only */
 #define O_NOATIME   04000000
+#define O_CLOEXEC   010000000
 #define O_DIRECTORY  00010000
 
 #define O_DIRECT    00040000 /* direct disk access hint - currently ignored */
 #define O_NOFOLLOW  00000200 /* don't follow links */
 #define O_INVISIBLE 04000000 /* invisible I/O, for DMAPI/XDSM */
 
+#define O_PATH		020000000
+#define O_TMPFILE	040000000
+#define O_SYNC		(__O_SYNC|O_DSYNC)
+
 #define F_DUPFD     0   /* Duplicate file descriptor.  */
 #define F_GETFD     1   /* Get file descriptor flags.  */
 #define F_SETFD     2   /* Set file descriptor flags.  */
@@ -611,11 +628,55 @@
 
 #endif
 
+#ifdef _GNU_SOURCE
+
+#define F_SETLEASE	(F_LINUX_SPECIFIC_BASE + 0)
+#define F_GETLEASE	(F_LINUX_SPECIFIC_BASE + 1)
+
+/*
+ * Cancel a blocking posix lock; internal use only until we expose an
+ * asynchronous lock api to userspace:
+ */
+#define F_CANCELLK	(F_LINUX_SPECIFIC_BASE + 5)
+
+/* Create a file descriptor with FD_CLOEXEC set. */
+#define F_DUPFD_CLOEXEC	(F_LINUX_SPECIFIC_BASE + 6)
+
+/*
+ * Request nofications on a directory.
+ * See below for events that may be notified.
+ */
+#define F_NOTIFY	(F_LINUX_SPECIFIC_BASE+2)
+
+/*
+ * Set and get of pipe page size array
+ */
+#define F_SETPIPE_SZ	(F_LINUX_SPECIFIC_BASE + 7)
+#define F_GETPIPE_SZ	(F_LINUX_SPECIFIC_BASE + 8)
+
+/*
+ * Set/Get seals
+ */
+#define F_ADD_SEALS	(F_LINUX_SPECIFIC_BASE + 9)
+#define F_GET_SEALS	(F_LINUX_SPECIFIC_BASE + 10)
+
+/*
+ * Types of seals
+ */
+#define F_SEAL_SEAL	0x0001	/* prevent further seals from being set */
+#define F_SEAL_SHRINK	0x0002	/* prevent file from shrinking */
+#define F_SEAL_GROW	0x0004	/* prevent file from growing */
+#define F_SEAL_WRITE	0x0008	/* prevent writes */
+/* (1U << 31) is reserved for signed error codes */
+#endif
+
 extern int fcntl (int __fd, int __cmd, ...) __THROW;
 #ifndef __NO_STAT64
 extern int fcntl64 (int __fd, int __cmd, ...) __THROW;
+extern int fstatat64(int dirfd, const char *pathname, struct stat *buf, int flags) __THROW;
 #if defined _FILE_OFFSET_BITS && _FILE_OFFSET_BITS == 64
 #define fcntl fcntl64
+#define fstatat fstatat64
 #endif
 #endif
 
@@ -628,37 +689,73 @@
 #endif
 
 #ifdef _GNU_SOURCE
-#define SPLICE_F_MOVE	(0x01)	/* move pages instead of copying */
-#define SPLICE_F_NONBLOCK (0x02) /* don't block on the pipe splicing (but */
-				 /* we may still block on the fd we splice */
-				 /* from/to, of course */
-#define SPLICE_F_MORE	(0x04)	/* expect more data */
-#define SPLICE_F_GIFT	(0x08)	/* pages passed in are a gift */
+enum {
+  SPLICE_F_MOVE=1,	/* move pages instead of copying */
+#define SPLICE_F_MOVE SPLICE_F_MOVE
+  SPLICE_F_NONBLOCK=2,	/* don't block on splicing (may still block on fd we splice */
+#define SPLICE_F_NONBLOCK SPLICE_F_NONBLOCK
+  SPLICE_F_MORE=4,	/* expect more data */
+#define SPLICE_F_MORE SPLICE_F_MORE
+  SPLICE_F_GIFT=8	/* pages passed in are a gift */
+#define SPLICE_F_GIFT SPLICE_F_GIFT
+};
 
-long tee(int fd_in, int fd_out, size_t len, unsigned int flags) __THROW;
+ssize_t tee(int fd_in, int fd_out, size_t len, unsigned int flags) __THROW;
 
 #include <sys/uio.h>
 
-long vmsplice(int fd, const struct iovec *iov, unsigned long nr_segs, unsigned int flags) __THROW;
-long splice(int fd_in, loff_t *off_in, int fd_out, loff_t *off_out, size_t len, unsigned int flags) __THROW;
+ssize_t splice(int fd_in, loff_t *off_in, int fd_out, loff_t *off_out, size_t len, unsigned int flags) __THROW;
+ssize_t vmsplice(int fd, const struct iovec *iov, unsigned long nr_segs, unsigned int flags) __THROW;
 
 int sync_file_range(int fd, off64_t offset, off64_t nbytes, unsigned int flags) __THROW;
 
 #define FALLOC_FL_KEEP_SIZE 1
 
 int fallocate(int fd, int mode, loff_t offset, loff_t len) __THROW;
+
+/*
+ * Types of directory notifications that may be requested.
+ */
+#define DN_ACCESS	0x00000001	/* File accessed */
+#define DN_MODIFY	0x00000002	/* File modified */
+#define DN_CREATE	0x00000004	/* File created */
+#define DN_DELETE	0x00000008	/* File removed */
+#define DN_RENAME	0x00000010	/* File renamed */
+#define DN_ATTRIB	0x00000020	/* File changed attibutes */
+#define DN_MULTISHOT	0x80000000	/* Don't remove notifier */
+
 #endif
 
-#if defined(_ATFILE_SOURCE) || ((_XOPEN_SOURCE + 0) >= 700) || ((_POSIX_C_SOURCE + 0) >= 200809L)
+#define F_SETOWN_EX	15
+#define F_GETOWN_EX	16
+#define F_GETOWNER_UIDS	17
+
+#define F_OFD_GETLK	36
+#define F_OFD_SETLK	37
+#define F_OFD_SETLKW	38
+
+#define F_OWNER_TID	0
+#define F_OWNER_PID	1
+#define F_OWNER_PGRP	2
+
+struct f_owner_ex {
+	int	type;
+	int	pid;
+};
+
 #define AT_FDCWD		-100    /* Special value used to indicate openat should use the current working directory. */
 #define AT_SYMLINK_NOFOLLOW	0x100   /* Do not follow symbolic links.  */
 #define AT_REMOVEDIR		0x200   /* Remove directory instead of unlinking file.  */
 #define AT_SYMLINK_FOLLOW	0x400   /* Follow symbolic links.  */
+#define AT_NO_AUTOMOUNT		0x800	/* Suppress terminal automount traversal */
+#define AT_EMPTY_PATH		0x1000	/* Allow empty relative pathname */
+
+/* for faccessat */
+#define AT_EACCESS		0x200	/* using euid, not uid for accessat */
 
 int openat(int dirfd, const char *pathname, int flags, ...) __THROW;
 int futimesat(int dirfd, const char *pathname, const struct timeval times[2]) __THROW;
 int unlinkat(int dirfd, const char *pathname, int flags) __THROW;
-#endif
 
 #if defined(_XOPEN_SOURCE) && (_XOPEN_SOURCE - 0) >= 600
 #include "linux/fadvise.h"
diff -urN -x .git dietlibc-0.33/include/inttypes.h dietlibc/include/inttypes.h
--- dietlibc-0.33/include/inttypes.h	2012-01-24 18:24:25.000000000 +0000
+++ dietlibc/include/inttypes.h	2015-01-01 12:14:43.471605562 +0000
@@ -258,8 +258,8 @@
 #if __WORDSIZE == 64
 typedef signed long int64_t;
 typedef unsigned long uint64_t;
-typedef signed long int intmax_t;
-typedef unsigned long int uintmax_t;
+typedef signed long intmax_t;
+typedef unsigned long uintmax_t;
 #else
 __extension__ typedef signed long long int64_t;
 __extension__ typedef unsigned long long uint64_t;
diff -urN -x .git dietlibc-0.33/include/linux/audit.h dietlibc/include/linux/audit.h
--- dietlibc-0.33/include/linux/audit.h	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/include/linux/audit.h	2015-01-01 12:14:43.471605562 +0000
@@ -0,0 +1,432 @@
+/* audit.h -- Auditing support
+ *
+ * Copyright 2003-2004 Red Hat Inc., Durham, North Carolina.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Written by Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+#ifndef _UAPI_LINUX_AUDIT_H_
+#define _UAPI_LINUX_AUDIT_H_
+
+#include <inttypes.h>
+
+#include <linux/elf-em.h>
+
+/* The netlink messages for the audit system is divided into blocks:
+ * 1000 - 1099 are for commanding the audit system
+ * 1100 - 1199 user space trusted application messages
+ * 1200 - 1299 messages internal to the audit daemon
+ * 1300 - 1399 audit event messages
+ * 1400 - 1499 SE Linux use
+ * 1500 - 1599 kernel LSPP events
+ * 1600 - 1699 kernel crypto events
+ * 1700 - 1799 kernel anomaly records
+ * 1800 - 1899 kernel integrity events
+ * 1900 - 1999 future kernel use
+ * 2000 is for otherwise unclassified kernel audit messages (legacy)
+ * 2001 - 2099 unused (kernel)
+ * 2100 - 2199 user space anomaly records
+ * 2200 - 2299 user space actions taken in response to anomalies
+ * 2300 - 2399 user space generated LSPP events
+ * 2400 - 2499 user space crypto events
+ * 2500 - 2999 future user space (maybe integrity labels and related events)
+ *
+ * Messages from 1000-1199 are bi-directional. 1200-1299 & 2100 - 2999 are
+ * exclusively user space. 1300-2099 is kernel --> user space 
+ * communication.
+ */
+#define AUDIT_GET		1000	/* Get status */
+#define AUDIT_SET		1001	/* Set status (enable/disable/auditd) */
+#define AUDIT_LIST		1002	/* List syscall rules -- deprecated */
+#define AUDIT_ADD		1003	/* Add syscall rule -- deprecated */
+#define AUDIT_DEL		1004	/* Delete syscall rule -- deprecated */
+#define AUDIT_USER		1005	/* Message from userspace -- deprecated */
+#define AUDIT_LOGIN		1006	/* Define the login id and information */
+#define AUDIT_WATCH_INS		1007	/* Insert file/dir watch entry */
+#define AUDIT_WATCH_REM		1008	/* Remove file/dir watch entry */
+#define AUDIT_WATCH_LIST	1009	/* List all file/dir watches */
+#define AUDIT_SIGNAL_INFO	1010	/* Get info about sender of signal to auditd */
+#define AUDIT_ADD_RULE		1011	/* Add syscall filtering rule */
+#define AUDIT_DEL_RULE		1012	/* Delete syscall filtering rule */
+#define AUDIT_LIST_RULES	1013	/* List syscall filtering rules */
+#define AUDIT_TRIM		1014	/* Trim junk from watched tree */
+#define AUDIT_MAKE_EQUIV	1015	/* Append to watched tree */
+#define AUDIT_TTY_GET		1016	/* Get TTY auditing status */
+#define AUDIT_TTY_SET		1017	/* Set TTY auditing status */
+#define AUDIT_SET_FEATURE	1018	/* Turn an audit feature on or off */
+#define AUDIT_GET_FEATURE	1019	/* Get which features are enabled */
+#define AUDIT_FEATURE_CHANGE	1020	/* audit log listing feature changes */
+
+#define AUDIT_FIRST_USER_MSG	1100	/* Userspace messages mostly uninteresting to kernel */
+#define AUDIT_USER_AVC		1107	/* We filter this differently */
+#define AUDIT_USER_TTY		1124	/* Non-ICANON TTY input meaning */
+#define AUDIT_LAST_USER_MSG	1199
+#define AUDIT_FIRST_USER_MSG2	2100	/* More user space messages */
+#define AUDIT_LAST_USER_MSG2	2999
+ 
+#define AUDIT_DAEMON_START      1200    /* Daemon startup record */
+#define AUDIT_DAEMON_END        1201    /* Daemon normal stop record */
+#define AUDIT_DAEMON_ABORT      1202    /* Daemon error stop record */
+#define AUDIT_DAEMON_CONFIG     1203    /* Daemon config change */
+
+#define AUDIT_SYSCALL		1300	/* Syscall event */
+/* #define AUDIT_FS_WATCH	1301	 * Deprecated */
+#define AUDIT_PATH		1302	/* Filename path information */
+#define AUDIT_IPC		1303	/* IPC record */
+#define AUDIT_SOCKETCALL	1304	/* sys_socketcall arguments */
+#define AUDIT_CONFIG_CHANGE	1305	/* Audit system configuration change */
+#define AUDIT_SOCKADDR		1306	/* sockaddr copied as syscall arg */
+#define AUDIT_CWD		1307	/* Current working directory */
+#define AUDIT_EXECVE		1309	/* execve arguments */
+#define AUDIT_IPC_SET_PERM	1311	/* IPC new permissions record type */
+#define AUDIT_MQ_OPEN		1312	/* POSIX MQ open record type */
+#define AUDIT_MQ_SENDRECV	1313	/* POSIX MQ send/receive record type */
+#define AUDIT_MQ_NOTIFY		1314	/* POSIX MQ notify record type */
+#define AUDIT_MQ_GETSETATTR	1315	/* POSIX MQ get/set attribute record type */
+#define AUDIT_KERNEL_OTHER	1316	/* For use by 3rd party modules */
+#define AUDIT_FD_PAIR		1317    /* audit record for pipe/socketpair */
+#define AUDIT_OBJ_PID		1318	/* ptrace target */
+#define AUDIT_TTY		1319	/* Input on an administrative TTY */
+#define AUDIT_EOE		1320	/* End of multi-record event */
+#define AUDIT_BPRM_FCAPS	1321	/* Information about fcaps increasing perms */
+#define AUDIT_CAPSET		1322	/* Record showing argument to sys_capset */
+#define AUDIT_MMAP		1323	/* Record showing descriptor and flags in mmap */
+#define AUDIT_NETFILTER_PKT	1324	/* Packets traversing netfilter chains */
+#define AUDIT_NETFILTER_CFG	1325	/* Netfilter chain modifications */
+#define AUDIT_SECCOMP		1326	/* Secure Computing event */
+
+#define AUDIT_AVC		1400	/* SE Linux avc denial or grant */
+#define AUDIT_SELINUX_ERR	1401	/* Internal SE Linux Errors */
+#define AUDIT_AVC_PATH		1402	/* dentry, vfsmount pair from avc */
+#define AUDIT_MAC_POLICY_LOAD	1403	/* Policy file load */
+#define AUDIT_MAC_STATUS	1404	/* Changed enforcing,permissive,off */
+#define AUDIT_MAC_CONFIG_CHANGE	1405	/* Changes to booleans */
+#define AUDIT_MAC_UNLBL_ALLOW	1406	/* NetLabel: allow unlabeled traffic */
+#define AUDIT_MAC_CIPSOV4_ADD	1407	/* NetLabel: add CIPSOv4 DOI entry */
+#define AUDIT_MAC_CIPSOV4_DEL	1408	/* NetLabel: del CIPSOv4 DOI entry */
+#define AUDIT_MAC_MAP_ADD	1409	/* NetLabel: add LSM domain mapping */
+#define AUDIT_MAC_MAP_DEL	1410	/* NetLabel: del LSM domain mapping */
+#define AUDIT_MAC_IPSEC_ADDSA	1411	/* Not used */
+#define AUDIT_MAC_IPSEC_DELSA	1412	/* Not used  */
+#define AUDIT_MAC_IPSEC_ADDSPD	1413	/* Not used */
+#define AUDIT_MAC_IPSEC_DELSPD	1414	/* Not used */
+#define AUDIT_MAC_IPSEC_EVENT	1415	/* Audit an IPSec event */
+#define AUDIT_MAC_UNLBL_STCADD	1416	/* NetLabel: add a static label */
+#define AUDIT_MAC_UNLBL_STCDEL	1417	/* NetLabel: del a static label */
+
+#define AUDIT_FIRST_KERN_ANOM_MSG   1700
+#define AUDIT_LAST_KERN_ANOM_MSG    1799
+#define AUDIT_ANOM_PROMISCUOUS      1700 /* Device changed promiscuous mode */
+#define AUDIT_ANOM_ABEND            1701 /* Process ended abnormally */
+#define AUDIT_ANOM_LINK		    1702 /* Suspicious use of file links */
+#define AUDIT_INTEGRITY_DATA	    1800 /* Data integrity verification */
+#define AUDIT_INTEGRITY_METADATA    1801 /* Metadata integrity verification */
+#define AUDIT_INTEGRITY_STATUS	    1802 /* Integrity enable status */
+#define AUDIT_INTEGRITY_HASH	    1803 /* Integrity HASH type */
+#define AUDIT_INTEGRITY_PCR	    1804 /* PCR invalidation msgs */
+#define AUDIT_INTEGRITY_RULE	    1805 /* policy rule */
+
+#define AUDIT_KERNEL		2000	/* Asynchronous audit record. NOT A REQUEST. */
+
+/* Rule flags */
+#define AUDIT_FILTER_USER	0x00	/* Apply rule to user-generated messages */
+#define AUDIT_FILTER_TASK	0x01	/* Apply rule at task creation (not syscall) */
+#define AUDIT_FILTER_ENTRY	0x02	/* Apply rule at syscall entry */
+#define AUDIT_FILTER_WATCH	0x03	/* Apply rule to file system watches */
+#define AUDIT_FILTER_EXIT	0x04	/* Apply rule at syscall exit */
+#define AUDIT_FILTER_TYPE	0x05	/* Apply rule at audit_log_start */
+
+#define AUDIT_NR_FILTERS	6
+
+#define AUDIT_FILTER_PREPEND	0x10	/* Prepend to front of list */
+
+/* Rule actions */
+#define AUDIT_NEVER    0	/* Do not build context if rule matches */
+#define AUDIT_POSSIBLE 1	/* Build context if rule matches  */
+#define AUDIT_ALWAYS   2	/* Generate audit record if rule matches */
+
+/* Rule structure sizes -- if these change, different AUDIT_ADD and
+ * AUDIT_LIST commands must be implemented. */
+#define AUDIT_MAX_FIELDS   64
+#define AUDIT_MAX_KEY_LEN  256
+#define AUDIT_BITMASK_SIZE 64
+#define AUDIT_WORD(nr) ((uint32_t)((nr)/32))
+#define AUDIT_BIT(nr)  (1 << ((nr) - AUDIT_WORD(nr)*32))
+
+#define AUDIT_SYSCALL_CLASSES 16
+#define AUDIT_CLASS_DIR_WRITE 0
+#define AUDIT_CLASS_DIR_WRITE_32 1
+#define AUDIT_CLASS_CHATTR 2
+#define AUDIT_CLASS_CHATTR_32 3
+#define AUDIT_CLASS_READ 4
+#define AUDIT_CLASS_READ_32 5
+#define AUDIT_CLASS_WRITE 6
+#define AUDIT_CLASS_WRITE_32 7
+#define AUDIT_CLASS_SIGNAL 8
+#define AUDIT_CLASS_SIGNAL_32 9
+
+/* This bitmask is used to validate user input.  It represents all bits that
+ * are currently used in an audit field constant understood by the kernel.
+ * If you are adding a new #define AUDIT_<whatever>, please ensure that
+ * AUDIT_UNUSED_BITS is updated if need be. */
+#define AUDIT_UNUSED_BITS	0x07FFFC00
+
+/* AUDIT_FIELD_COMPARE rule list */
+#define AUDIT_COMPARE_UID_TO_OBJ_UID	1
+#define AUDIT_COMPARE_GID_TO_OBJ_GID	2
+#define AUDIT_COMPARE_EUID_TO_OBJ_UID	3
+#define AUDIT_COMPARE_EGID_TO_OBJ_GID	4
+#define AUDIT_COMPARE_AUID_TO_OBJ_UID	5
+#define AUDIT_COMPARE_SUID_TO_OBJ_UID	6
+#define AUDIT_COMPARE_SGID_TO_OBJ_GID	7
+#define AUDIT_COMPARE_FSUID_TO_OBJ_UID	8
+#define AUDIT_COMPARE_FSGID_TO_OBJ_GID	9
+
+#define AUDIT_COMPARE_UID_TO_AUID	10
+#define AUDIT_COMPARE_UID_TO_EUID	11
+#define AUDIT_COMPARE_UID_TO_FSUID	12
+#define AUDIT_COMPARE_UID_TO_SUID	13
+
+#define AUDIT_COMPARE_AUID_TO_FSUID	14
+#define AUDIT_COMPARE_AUID_TO_SUID	15
+#define AUDIT_COMPARE_AUID_TO_EUID	16
+
+#define AUDIT_COMPARE_EUID_TO_SUID	17
+#define AUDIT_COMPARE_EUID_TO_FSUID	18
+
+#define AUDIT_COMPARE_SUID_TO_FSUID	19
+
+#define AUDIT_COMPARE_GID_TO_EGID	20
+#define AUDIT_COMPARE_GID_TO_FSGID	21
+#define AUDIT_COMPARE_GID_TO_SGID	22
+
+#define AUDIT_COMPARE_EGID_TO_FSGID	23
+#define AUDIT_COMPARE_EGID_TO_SGID	24
+#define AUDIT_COMPARE_SGID_TO_FSGID	25
+
+#define AUDIT_MAX_FIELD_COMPARE		AUDIT_COMPARE_SGID_TO_FSGID
+
+/* Rule fields */
+				/* These are useful when checking the
+				 * task structure at task creation time
+				 * (AUDIT_PER_TASK).  */
+#define AUDIT_PID	0
+#define AUDIT_UID	1
+#define AUDIT_EUID	2
+#define AUDIT_SUID	3
+#define AUDIT_FSUID	4
+#define AUDIT_GID	5
+#define AUDIT_EGID	6
+#define AUDIT_SGID	7
+#define AUDIT_FSGID	8
+#define AUDIT_LOGINUID	9
+#define AUDIT_PERS	10
+#define AUDIT_ARCH	11
+#define AUDIT_MSGTYPE	12
+#define AUDIT_SUBJ_USER	13	/* security label user */
+#define AUDIT_SUBJ_ROLE	14	/* security label role */
+#define AUDIT_SUBJ_TYPE	15	/* security label type */
+#define AUDIT_SUBJ_SEN	16	/* security label sensitivity label */
+#define AUDIT_SUBJ_CLR	17	/* security label clearance label */
+#define AUDIT_PPID	18
+#define AUDIT_OBJ_USER	19
+#define AUDIT_OBJ_ROLE	20
+#define AUDIT_OBJ_TYPE	21
+#define AUDIT_OBJ_LEV_LOW	22
+#define AUDIT_OBJ_LEV_HIGH	23
+#define AUDIT_LOGINUID_SET	24
+
+				/* These are ONLY useful when checking
+				 * at syscall exit time (AUDIT_AT_EXIT). */
+#define AUDIT_DEVMAJOR	100
+#define AUDIT_DEVMINOR	101
+#define AUDIT_INODE	102
+#define AUDIT_EXIT	103
+#define AUDIT_SUCCESS   104	/* exit >= 0; value ignored */
+#define AUDIT_WATCH	105
+#define AUDIT_PERM	106
+#define AUDIT_DIR	107
+#define AUDIT_FILETYPE	108
+#define AUDIT_OBJ_UID	109
+#define AUDIT_OBJ_GID	110
+#define AUDIT_FIELD_COMPARE	111
+
+#define AUDIT_ARG0      200
+#define AUDIT_ARG1      (AUDIT_ARG0+1)
+#define AUDIT_ARG2      (AUDIT_ARG0+2)
+#define AUDIT_ARG3      (AUDIT_ARG0+3)
+
+#define AUDIT_FILTERKEY	210
+
+#define AUDIT_NEGATE			0x80000000
+
+/* These are the supported operators.
+ *	4  2  1  8
+ *	=  >  <  ?
+ *	----------
+ *	0  0  0	 0	00	nonsense
+ *	0  0  0	 1	08	&  bit mask
+ *	0  0  1	 0	10	<
+ *	0  1  0	 0	20	>
+ *	0  1  1	 0	30	!=
+ *	1  0  0	 0	40	=
+ *	1  0  0	 1	48	&=  bit test
+ *	1  0  1	 0	50	<=
+ *	1  1  0	 0	60	>=
+ *	1  1  1	 1	78	all operators
+ */
+#define AUDIT_BIT_MASK			0x08000000
+#define AUDIT_LESS_THAN			0x10000000
+#define AUDIT_GREATER_THAN		0x20000000
+#define AUDIT_NOT_EQUAL			0x30000000
+#define AUDIT_EQUAL			0x40000000
+#define AUDIT_BIT_TEST			(AUDIT_BIT_MASK|AUDIT_EQUAL)
+#define AUDIT_LESS_THAN_OR_EQUAL	(AUDIT_LESS_THAN|AUDIT_EQUAL)
+#define AUDIT_GREATER_THAN_OR_EQUAL	(AUDIT_GREATER_THAN|AUDIT_EQUAL)
+#define AUDIT_OPERATORS			(AUDIT_EQUAL|AUDIT_NOT_EQUAL|AUDIT_BIT_MASK)
+
+enum {
+	Audit_equal,
+	Audit_not_equal,
+	Audit_bitmask,
+	Audit_bittest,
+	Audit_lt,
+	Audit_gt,
+	Audit_le,
+	Audit_ge,
+	Audit_bad
+};
+
+/* Status symbols */
+				/* Mask values */
+#define AUDIT_STATUS_ENABLED		0x0001
+#define AUDIT_STATUS_FAILURE		0x0002
+#define AUDIT_STATUS_PID		0x0004
+#define AUDIT_STATUS_RATE_LIMIT		0x0008
+#define AUDIT_STATUS_BACKLOG_LIMIT	0x0010
+				/* Failure-to-log actions */
+#define AUDIT_FAIL_SILENT	0
+#define AUDIT_FAIL_PRINTK	1
+#define AUDIT_FAIL_PANIC	2
+
+/* distinguish syscall tables */
+#define __AUDIT_ARCH_64BIT 0x80000000
+#define __AUDIT_ARCH_LE	   0x40000000
+#define AUDIT_ARCH_ALPHA	(EM_ALPHA|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
+#define AUDIT_ARCH_ARM		(EM_ARM|__AUDIT_ARCH_LE)
+#define AUDIT_ARCH_ARMEB	(EM_ARM)
+#define AUDIT_ARCH_CRIS		(EM_CRIS|__AUDIT_ARCH_LE)
+#define AUDIT_ARCH_FRV		(EM_FRV)
+#define AUDIT_ARCH_I386		(EM_386|__AUDIT_ARCH_LE)
+#define AUDIT_ARCH_IA64		(EM_IA_64|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
+#define AUDIT_ARCH_M32R		(EM_M32R)
+#define AUDIT_ARCH_M68K		(EM_68K)
+#define AUDIT_ARCH_MIPS		(EM_MIPS)
+#define AUDIT_ARCH_MIPSEL	(EM_MIPS|__AUDIT_ARCH_LE)
+#define AUDIT_ARCH_MIPS64	(EM_MIPS|__AUDIT_ARCH_64BIT)
+#define AUDIT_ARCH_MIPSEL64	(EM_MIPS|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
+#define AUDIT_ARCH_OPENRISC	(EM_OPENRISC)
+#define AUDIT_ARCH_PARISC	(EM_PARISC)
+#define AUDIT_ARCH_PARISC64	(EM_PARISC|__AUDIT_ARCH_64BIT)
+#define AUDIT_ARCH_PPC		(EM_PPC)
+#define AUDIT_ARCH_PPC64	(EM_PPC64|__AUDIT_ARCH_64BIT)
+#define AUDIT_ARCH_S390		(EM_S390)
+#define AUDIT_ARCH_S390X	(EM_S390|__AUDIT_ARCH_64BIT)
+#define AUDIT_ARCH_SH		(EM_SH)
+#define AUDIT_ARCH_SHEL		(EM_SH|__AUDIT_ARCH_LE)
+#define AUDIT_ARCH_SH64		(EM_SH|__AUDIT_ARCH_64BIT)
+#define AUDIT_ARCH_SHEL64	(EM_SH|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
+#define AUDIT_ARCH_SPARC	(EM_SPARC)
+#define AUDIT_ARCH_SPARC64	(EM_SPARCV9|__AUDIT_ARCH_64BIT)
+#define AUDIT_ARCH_X86_64	(EM_X86_64|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
+
+#define AUDIT_PERM_EXEC		1
+#define AUDIT_PERM_WRITE	2
+#define AUDIT_PERM_READ		4
+#define AUDIT_PERM_ATTR		8
+
+/* MAX_AUDIT_MESSAGE_LENGTH is set in audit:lib/libaudit.h as:
+ * 8970 // PATH_MAX*2+CONTEXT_SIZE*2+11+256+1
+ * max header+body+tailer: 44 + 29 + 32 + 262 + 7 + pad
+ */
+#define AUDIT_MESSAGE_TEXT_MAX	8560
+
+struct audit_status {
+	uint32_t		mask;		/* Bit mask for valid entries */
+	uint32_t		enabled;	/* 1 = enabled, 0 = disabled */
+	uint32_t		failure;	/* Failure-to-log action */
+	uint32_t		pid;		/* pid of auditd process */
+	uint32_t		rate_limit;	/* messages rate limit (per second) */
+	uint32_t		backlog_limit;	/* waiting messages limit */
+	uint32_t		lost;		/* messages lost */
+	uint32_t		backlog;	/* messages waiting in queue */
+};
+
+struct audit_features {
+#define AUDIT_FEATURE_VERSION	1
+	uint32_t	vers;
+	uint32_t	mask;		/* which bits we are dealing with */
+	uint32_t	features;	/* which feature to enable/disable */
+	uint32_t	lock;		/* which features to lock */
+};
+
+#define AUDIT_FEATURE_ONLY_UNSET_LOGINUID	0
+#define AUDIT_FEATURE_LOGINUID_IMMUTABLE	1
+#define AUDIT_LAST_FEATURE			AUDIT_FEATURE_LOGINUID_IMMUTABLE
+
+#define audit_feature_valid(x)		((x) >= 0 && (x) <= AUDIT_LAST_FEATURE)
+#define AUDIT_FEATURE_TO_MASK(x)	(1 << ((x) & 31)) /* mask for uint32_t */
+
+struct audit_tty_status {
+	uint32_t		enabled;	/* 1 = enabled, 0 = disabled */
+	uint32_t		log_passwd;	/* 1 = enabled, 0 = disabled */
+};
+
+#define AUDIT_UID_UNSET (unsigned int)-1
+
+/* audit_rule_data supports filter rules with both integer and string
+ * fields.  It corresponds with AUDIT_ADD_RULE, AUDIT_DEL_RULE and
+ * AUDIT_LIST_RULES requests.
+ */
+struct audit_rule_data {
+	uint32_t		flags;	/* AUDIT_PER_{TASK,CALL}, AUDIT_PREPEND */
+	uint32_t		action;	/* AUDIT_NEVER, AUDIT_POSSIBLE, AUDIT_ALWAYS */
+	uint32_t		field_count;
+	uint32_t		mask[AUDIT_BITMASK_SIZE]; /* syscall(s) affected */
+	uint32_t		fields[AUDIT_MAX_FIELDS];
+	uint32_t		values[AUDIT_MAX_FIELDS];
+	uint32_t		fieldflags[AUDIT_MAX_FIELDS];
+	uint32_t		buflen;	/* total length of string fields */
+	char		buf[0];	/* string fields buffer */
+};
+
+/* audit_rule is supported to maintain backward compatibility with
+ * userspace.  It supports integer fields only and corresponds to
+ * AUDIT_ADD, AUDIT_DEL and AUDIT_LIST requests.
+ */
+struct audit_rule {		/* for AUDIT_LIST, AUDIT_ADD, and AUDIT_DEL */
+	uint32_t		flags;	/* AUDIT_PER_{TASK,CALL}, AUDIT_PREPEND */
+	uint32_t		action;	/* AUDIT_NEVER, AUDIT_POSSIBLE, AUDIT_ALWAYS */
+	uint32_t		field_count;
+	uint32_t		mask[AUDIT_BITMASK_SIZE];
+	uint32_t		fields[AUDIT_MAX_FIELDS];
+	uint32_t		values[AUDIT_MAX_FIELDS];
+};
+
+#endif /* _UAPI_LINUX_AUDIT_H_ */
diff -urN -x .git dietlibc-0.33/include/linux/elf-em.h dietlibc/include/linux/elf-em.h
--- dietlibc-0.33/include/linux/elf-em.h	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/include/linux/elf-em.h	2015-01-01 12:14:43.471605562 +0000
@@ -0,0 +1,57 @@
+#ifndef _LINUX_ELF_EM_H
+#define _LINUX_ELF_EM_H
+
+/* These constants define the various ELF target machines */
+#define EM_NONE		0
+#define EM_M32		1
+#define EM_SPARC	2
+#define EM_386		3
+#define EM_68K		4
+#define EM_88K		5
+#define EM_486		6	/* Perhaps disused */
+#define EM_860		7
+#define EM_MIPS		8	/* MIPS R3000 (officially, big-endian only) */
+				/* Next two are historical and binaries and
+				   modules of these types will be rejected by
+				   Linux.  */
+#define EM_MIPS_RS3_LE	10	/* MIPS R3000 little-endian */
+#define EM_MIPS_RS4_BE	10	/* MIPS R4000 big-endian */
+
+#define EM_PARISC	15	/* HPPA */
+#define EM_SPARC32PLUS	18	/* Sun's "v8plus" */
+#define EM_PPC		20	/* PowerPC */
+#define EM_PPC64	21	 /* PowerPC64 */
+#define EM_SPU		23	/* Cell BE SPU */
+#define EM_ARM		40	/* ARM 32 bit */
+#define EM_SH		42	/* SuperH */
+#define EM_SPARCV9	43	/* SPARC v9 64-bit */
+#define EM_IA_64	50	/* HP/Intel IA-64 */
+#define EM_X86_64	62	/* AMD x86-64 */
+#define EM_S390		22	/* IBM S/390 */
+#define EM_CRIS		76	/* Axis Communications 32-bit embedded processor */
+#define EM_V850		87	/* NEC v850 */
+#define EM_M32R		88	/* Renesas M32R */
+#define EM_MN10300	89	/* Panasonic/MEI MN10300, AM33 */
+#define EM_BLACKFIN     106     /* ADI Blackfin Processor */
+#define EM_TI_C6000	140	/* TI C6X DSPs */
+#define EM_AARCH64	183	/* ARM 64 bit */
+#define EM_FRV		0x5441	/* Fujitsu FR-V */
+#define EM_AVR32	0x18ad	/* Atmel AVR32 */
+
+/*
+ * This is an interim value that we will use until the committee comes
+ * up with a final number.
+ */
+#define EM_ALPHA	0x9026
+
+/* Bogus old v850 magic number, used by old tools. */
+#define EM_CYGNUS_V850	0x9080
+/* Bogus old m32r magic number, used by old tools. */
+#define EM_CYGNUS_M32R	0x9041
+/* This is the old interim value for S/390 architecture */
+#define EM_S390_OLD	0xA390
+/* Also Panasonic/MEI MN10300, AM33 */
+#define EM_CYGNUS_MN10300 0xbeef
+
+
+#endif /* _LINUX_ELF_EM_H */
diff -urN -x .git dietlibc-0.33/include/linux/filter.h dietlibc/include/linux/filter.h
--- dietlibc-0.33/include/linux/filter.h	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/include/linux/filter.h	2015-01-01 12:14:43.471605562 +0000
@@ -0,0 +1,137 @@
+/*
+ * Linux Socket Filter Data Structures
+ */
+
+#ifndef _UAPI__LINUX_FILTER_H__
+#define _UAPI__LINUX_FILTER_H__
+
+#include <inttypes.h>
+
+
+/*
+ * Current version of the filter code architecture.
+ */
+#define BPF_MAJOR_VERSION 1
+#define BPF_MINOR_VERSION 1
+
+/*
+ *	Try and keep these values and structures similar to BSD, especially
+ *	the BPF code definitions which need to match so you can share filters
+ */
+ 
+struct sock_filter {	/* Filter block */
+	uint16_t	code;   /* Actual filter code */
+	uint8_t	jt;	/* Jump true */
+	uint8_t	jf;	/* Jump false */
+	uint32_t	k;      /* Generic multiuse field */
+};
+
+struct sock_fprog {	/* Required for SO_ATTACH_FILTER. */
+	unsigned short		len;	/* Number of filter blocks */
+	struct sock_filter	*filter;
+};
+
+/*
+ * Instruction classes
+ */
+
+#define BPF_CLASS(code) ((code) & 0x07)
+#define         BPF_LD          0x00
+#define         BPF_LDX         0x01
+#define         BPF_ST          0x02
+#define         BPF_STX         0x03
+#define         BPF_ALU         0x04
+#define         BPF_JMP         0x05
+#define         BPF_RET         0x06
+#define         BPF_MISC        0x07
+
+/* ld/ldx fields */
+#define BPF_SIZE(code)  ((code) & 0x18)
+#define         BPF_W           0x00
+#define         BPF_H           0x08
+#define         BPF_B           0x10
+#define BPF_MODE(code)  ((code) & 0xe0)
+#define         BPF_IMM         0x00
+#define         BPF_ABS         0x20
+#define         BPF_IND         0x40
+#define         BPF_MEM         0x60
+#define         BPF_LEN         0x80
+#define         BPF_MSH         0xa0
+
+/* alu/jmp fields */
+#define BPF_OP(code)    ((code) & 0xf0)
+#define         BPF_ADD         0x00
+#define         BPF_SUB         0x10
+#define         BPF_MUL         0x20
+#define         BPF_DIV         0x30
+#define         BPF_OR          0x40
+#define         BPF_AND         0x50
+#define         BPF_LSH         0x60
+#define         BPF_RSH         0x70
+#define         BPF_NEG         0x80
+#define		BPF_MOD		0x90
+#define		BPF_XOR		0xa0
+
+#define         BPF_JA          0x00
+#define         BPF_JEQ         0x10
+#define         BPF_JGT         0x20
+#define         BPF_JGE         0x30
+#define         BPF_JSET        0x40
+#define BPF_SRC(code)   ((code) & 0x08)
+#define         BPF_K           0x00
+#define         BPF_X           0x08
+
+/* ret - BPF_K and BPF_X also apply */
+#define BPF_RVAL(code)  ((code) & 0x18)
+#define         BPF_A           0x10
+
+/* misc */
+#define BPF_MISCOP(code) ((code) & 0xf8)
+#define         BPF_TAX         0x00
+#define         BPF_TXA         0x80
+
+#ifndef BPF_MAXINSNS
+#define BPF_MAXINSNS 4096
+#endif
+
+/*
+ * Macros for filter block array initializers.
+ */
+#ifndef BPF_STMT
+#define BPF_STMT(code, k) { (unsigned short)(code), 0, 0, k }
+#endif
+#ifndef BPF_JUMP
+#define BPF_JUMP(code, k, jt, jf) { (unsigned short)(code), jt, jf, k }
+#endif
+
+/*
+ * Number of scratch memory words for: BPF_ST and BPF_STX
+ */
+#define BPF_MEMWORDS 16
+
+/* RATIONALE. Negative offsets are invalid in BPF.
+   We use them to reference ancillary data.
+   Unlike introduction new instructions, it does not break
+   existing compilers/optimizers.
+ */
+#define SKF_AD_OFF    (-0x1000)
+#define SKF_AD_PROTOCOL 0
+#define SKF_AD_PKTTYPE 	4
+#define SKF_AD_IFINDEX 	8
+#define SKF_AD_NLATTR	12
+#define SKF_AD_NLATTR_NEST	16
+#define SKF_AD_MARK 	20
+#define SKF_AD_QUEUE	24
+#define SKF_AD_HATYPE	28
+#define SKF_AD_RXHASH	32
+#define SKF_AD_CPU	36
+#define SKF_AD_ALU_XOR_X	40
+#define SKF_AD_VLAN_TAG	44
+#define SKF_AD_VLAN_TAG_PRESENT 48
+#define SKF_AD_PAY_OFFSET	52
+#define SKF_AD_MAX	56
+#define SKF_NET_OFF   (-0x100000)
+#define SKF_LL_OFF    (-0x200000)
+
+
+#endif /* _UAPI__LINUX_FILTER_H__ */
diff -urN -x .git dietlibc-0.33/include/linux/prctl.h dietlibc/include/linux/prctl.h
--- dietlibc-0.33/include/linux/prctl.h	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/include/linux/prctl.h	2015-01-01 12:14:43.474938895 +0000
@@ -0,0 +1,152 @@
+#ifndef _LINUX_PRCTL_H
+#define _LINUX_PRCTL_H
+
+/* Values to pass as first argument to prctl() */
+
+#define PR_SET_PDEATHSIG  1  /* Second arg is a signal */
+#define PR_GET_PDEATHSIG  2  /* Second arg is a ptr to return the signal */
+
+/* Get/set current->mm->dumpable */
+#define PR_GET_DUMPABLE   3
+#define PR_SET_DUMPABLE   4
+
+/* Get/set unaligned access control bits (if meaningful) */
+#define PR_GET_UNALIGN	  5
+#define PR_SET_UNALIGN	  6
+# define PR_UNALIGN_NOPRINT	1	/* silently fix up unaligned user accesses */
+# define PR_UNALIGN_SIGBUS	2	/* generate SIGBUS on unaligned user access */
+
+/* Get/set whether or not to drop capabilities on setuid() away from
+ * uid 0 (as per security/commoncap.c) */
+#define PR_GET_KEEPCAPS   7
+#define PR_SET_KEEPCAPS   8
+
+/* Get/set floating-point emulation control bits (if meaningful) */
+#define PR_GET_FPEMU  9
+#define PR_SET_FPEMU 10
+# define PR_FPEMU_NOPRINT	1	/* silently emulate fp operations accesses */
+# define PR_FPEMU_SIGFPE	2	/* don't emulate fp operations, send SIGFPE instead */
+
+/* Get/set floating-point exception mode (if meaningful) */
+#define PR_GET_FPEXC	11
+#define PR_SET_FPEXC	12
+# define PR_FP_EXC_SW_ENABLE	0x80	/* Use FPEXC for FP exception enables */
+# define PR_FP_EXC_DIV		0x010000	/* floating point divide by zero */
+# define PR_FP_EXC_OVF		0x020000	/* floating point overflow */
+# define PR_FP_EXC_UND		0x040000	/* floating point underflow */
+# define PR_FP_EXC_RES		0x080000	/* floating point inexact result */
+# define PR_FP_EXC_INV		0x100000	/* floating point invalid operation */
+# define PR_FP_EXC_DISABLED	0	/* FP exceptions disabled */
+# define PR_FP_EXC_NONRECOV	1	/* async non-recoverable exc. mode */
+# define PR_FP_EXC_ASYNC	2	/* async recoverable exception mode */
+# define PR_FP_EXC_PRECISE	3	/* precise exception mode */
+
+/* Get/set whether we use statistical process timing or accurate timestamp
+ * based process timing */
+#define PR_GET_TIMING   13
+#define PR_SET_TIMING   14
+# define PR_TIMING_STATISTICAL  0       /* Normal, traditional,
+                                                   statistical process timing */
+# define PR_TIMING_TIMESTAMP    1       /* Accurate timestamp based
+                                                   process timing */
+
+#define PR_SET_NAME    15		/* Set process name */
+#define PR_GET_NAME    16		/* Get process name */
+
+/* Get/set process endian */
+#define PR_GET_ENDIAN	19
+#define PR_SET_ENDIAN	20
+# define PR_ENDIAN_BIG		0
+# define PR_ENDIAN_LITTLE	1	/* True little endian mode */
+# define PR_ENDIAN_PPC_LITTLE	2	/* "PowerPC" pseudo little endian */
+
+/* Get/set process seccomp mode */
+#define PR_GET_SECCOMP	21
+#define PR_SET_SECCOMP	22
+
+/* Get/set the capability bounding set (as per security/commoncap.c) */
+#define PR_CAPBSET_READ 23
+#define PR_CAPBSET_DROP 24
+
+/* Get/set the process' ability to use the timestamp counter instruction */
+#define PR_GET_TSC 25
+#define PR_SET_TSC 26
+# define PR_TSC_ENABLE		1	/* allow the use of the timestamp counter */
+# define PR_TSC_SIGSEGV		2	/* throw a SIGSEGV instead of reading the TSC */
+
+/* Get/set securebits (as per security/commoncap.c) */
+#define PR_GET_SECUREBITS 27
+#define PR_SET_SECUREBITS 28
+
+/*
+ * Get/set the timerslack as used by poll/select/nanosleep
+ * A value of 0 means "use default"
+ */
+#define PR_SET_TIMERSLACK 29
+#define PR_GET_TIMERSLACK 30
+
+#define PR_TASK_PERF_EVENTS_DISABLE		31
+#define PR_TASK_PERF_EVENTS_ENABLE		32
+
+/*
+ * Set early/late kill mode for hwpoison memory corruption.
+ * This influences when the process gets killed on a memory corruption.
+ */
+#define PR_MCE_KILL	33
+# define PR_MCE_KILL_CLEAR   0
+# define PR_MCE_KILL_SET     1
+
+# define PR_MCE_KILL_LATE    0
+# define PR_MCE_KILL_EARLY   1
+# define PR_MCE_KILL_DEFAULT 2
+
+#define PR_MCE_KILL_GET 34
+
+/*
+ * Tune up process memory map specifics.
+ */
+#define PR_SET_MM		35
+# define PR_SET_MM_START_CODE		1
+# define PR_SET_MM_END_CODE		2
+# define PR_SET_MM_START_DATA		3
+# define PR_SET_MM_END_DATA		4
+# define PR_SET_MM_START_STACK		5
+# define PR_SET_MM_START_BRK		6
+# define PR_SET_MM_BRK			7
+# define PR_SET_MM_ARG_START		8
+# define PR_SET_MM_ARG_END		9
+# define PR_SET_MM_ENV_START		10
+# define PR_SET_MM_ENV_END		11
+# define PR_SET_MM_AUXV			12
+# define PR_SET_MM_EXE_FILE		13
+
+/*
+ * Set specific pid that is allowed to ptrace the current task.
+ * A value of 0 mean "no process".
+ */
+#define PR_SET_PTRACER 0x59616d61
+# define PR_SET_PTRACER_ANY ((unsigned long)-1)
+
+#define PR_SET_CHILD_SUBREAPER	36
+#define PR_GET_CHILD_SUBREAPER	37
+
+/*
+ * If no_new_privs is set, then operations that grant new privileges (i.e.
+ * execve) will either fail or not grant them.  This affects suid/sgid,
+ * file capabilities, and LSMs.
+ *
+ * Operations that merely manipulate or drop existing privileges (setresuid,
+ * capset, etc.) will still work.  Drop those privileges if you want them gone.
+ *
+ * Changing LSM security domain is considered a new privilege.  So, for example,
+ * asking selinux for a specific new context (e.g. with runcon) will result
+ * in execve returning -EPERM.
+ *
+ * See Documentation/prctl/no_new_privs.txt for more details.
+ */
+#define PR_SET_NO_NEW_PRIVS	38
+#define PR_GET_NO_NEW_PRIVS	39
+
+#define PR_GET_TID_ADDRESS	40
+
+#endif /* _LINUX_PRCTL_H */
diff -urN -x .git dietlibc-0.33/include/linux/random.h dietlibc/include/linux/random.h
--- dietlibc-0.33/include/linux/random.h	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/include/linux/random.h	2015-01-01 12:14:43.474938895 +0000
@@ -0,0 +1,27 @@
+/*
+ * include/linux/random.h
+ *
+ * Include file for the random number generator.
+ */
+
+#ifndef _LINUX_RANDOM_H
+#define _LINUX_RANDOM_H
+
+#include <sys/cdefs.h>
+
+__BEGIN_DECLS
+
+#ifndef GRND_NONBLOCK
+enum {
+  GRND_NONBLOCK=1,
+#define GRND_NONBLOCK GRND_NONBLOCK
+  GRND_RANDOM=2
+#define GRND_RANDOM GRND_RANDOM
+};
+
+int getrandom(void* buf, size_t buflen, unsigned int flags) __THROW;
+#endif
+
+__END_DECLS
+
+#endif /* _LINUX_RANDOM_H */
diff -urN -x .git dietlibc-0.33/include/linux/seccomp.h dietlibc/include/linux/seccomp.h
--- dietlibc-0.33/include/linux/seccomp.h	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/include/linux/seccomp.h	2015-01-01 12:14:43.474938895 +0000
@@ -0,0 +1,45 @@
+#ifndef _UAPI_LINUX_SECCOMP_H
+#define _UAPI_LINUX_SECCOMP_H
+
+#include <inttypes.h>
+
+/* Valid values for seccomp.mode and prctl(PR_SET_SECCOMP, <mode>) */
+#define SECCOMP_MODE_DISABLED	0 /* seccomp is not in use. */
+#define SECCOMP_MODE_STRICT	1 /* uses hard-coded filter. */
+#define SECCOMP_MODE_FILTER	2 /* uses user-supplied filter. */
+
+/*
+ * All BPF programs must return a 32-bit value.
+ * The bottom 16-bits are for optional return data.
+ * The upper 16-bits are ordered from least permissive values to most.
+ *
+ * The ordering ensures that a min_t() over composed return values always
+ * selects the least permissive choice.
+ */
+#define SECCOMP_RET_KILL	0x00000000U /* kill the task immediately */
+#define SECCOMP_RET_TRAP	0x00030000U /* disallow and force a SIGSYS */
+#define SECCOMP_RET_ERRNO	0x00050000U /* returns an errno */
+#define SECCOMP_RET_TRACE	0x7ff00000U /* pass to a tracer or disallow */
+#define SECCOMP_RET_ALLOW	0x7fff0000U /* allow */
+
+/* Masks for the return value sections. */
+#define SECCOMP_RET_ACTION	0x7fff0000U
+#define SECCOMP_RET_DATA	0x0000ffffU
+
+/**
+ * struct seccomp_data - the format the BPF program executes over.
+ * @nr: the system call number
+ * @arch: indicates system call convention as an AUDIT_ARCH_* value
+ *        as defined in <linux/audit.h>.
+ * @instruction_pointer: at the time of the system call.
+ * @args: up to 6 system call arguments always stored as 64-bit values
+ *        regardless of the architecture.
+ */
+struct seccomp_data {
+	int nr;
+	uint32_t arch;
+	uint64_t instruction_pointer;
+	uint64_t args[6];
+};
+
+#endif /* _UAPI_LINUX_SECCOMP_H */
diff -urN -x .git dietlibc-0.33/include/linux/sysinfo.h dietlibc/include/linux/sysinfo.h
--- dietlibc-0.33/include/linux/sysinfo.h	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/include/linux/sysinfo.h	2015-01-01 12:14:43.474938895 +0000
@@ -0,0 +1,24 @@
+#ifndef _LINUX_SYSINFO_H
+#define _LINUX_SYSINFO_H
+
+#include <linux/types.h>
+
+#define SI_LOAD_SHIFT	16
+struct sysinfo {
+	__kernel_long_t uptime;		/* Seconds since boot */
+	__kernel_ulong_t loads[3];	/* 1, 5, and 15 minute load averages */
+	__kernel_ulong_t totalram;	/* Total usable main memory size */
+	__kernel_ulong_t freeram;	/* Available memory size */
+	__kernel_ulong_t sharedram;	/* Amount of shared memory */
+	__kernel_ulong_t bufferram;	/* Memory used by buffers */
+	__kernel_ulong_t totalswap;	/* Total swap space size */
+	__kernel_ulong_t freeswap;	/* swap space still available */
+	__u16 procs;		   	/* Number of current processes */
+	__u16 pad;		   	/* Explicit padding for m68k */
+	__kernel_ulong_t totalhigh;	/* Total high memory size */
+	__kernel_ulong_t freehigh;	/* Available high memory size */
+	__u32 mem_unit;			/* Memory unit size in bytes */
+	char _f[20-2*sizeof(__kernel_ulong_t)-sizeof(__u32)];	/* Padding: libc5 uses this.. */
+};
+
+#endif /* _LINUX_SYSINFO_H */
diff -urN -x .git dietlibc-0.33/include/linux/types.h dietlibc/include/linux/types.h
--- dietlibc-0.33/include/linux/types.h	2001-07-30 13:34:41.000000000 +0000
+++ dietlibc/include/linux/types.h	2015-01-01 12:14:43.474938895 +0000
@@ -2,5 +2,6 @@
 #define _LINUX_TYPES_H
 
 #include <asm/types.h>
+#include <asm/posix_types.h>
 
 #endif
diff -urN -x .git dietlibc-0.33/include/netinet/tcp.h dietlibc/include/netinet/tcp.h
--- dietlibc-0.33/include/netinet/tcp.h	2003-08-19 16:58:18.000000000 +0000
+++ dietlibc/include/netinet/tcp.h	2015-01-01 12:14:43.474938895 +0000
@@ -3,6 +3,7 @@
 
 #include <inttypes.h>
 #include <endian.h>
+#include <sys/socket.h> /* for sockaddr_storage */
 
 __BEGIN_DECLS
 
@@ -94,6 +95,12 @@
 #endif
 };
 
+/*
+ * TCP general constants
+ */
+#define TCP_MSS_DEFAULT		 536U	/* IPv4 (RFC1122, RFC2581) */
+#define TCP_MSS_DESIRED		1220U	/* IPv6 (tunneled), EDNS0 (RFC3226) */
+
 /* TCP socket options */
 #define TCP_NODELAY		1	/* Turn off Nagle's algorithm. */
 #define TCP_MAXSEG		2	/* Limit MSS */
@@ -107,11 +114,25 @@
 #define TCP_WINDOW_CLAMP	10	/* Bound advertised window */
 #define TCP_INFO		11	/* Information about this connection. */
 #define TCP_QUICKACK		12	/* Block/reenable quick acks */
+#define TCP_CONGESTION		13	/* Congestion control algorithm */
+#define TCP_MD5SIG		14	/* TCP MD5 Signature (RFC2385) */
+#define TCP_THIN_LINEAR_TIMEOUTS 16      /* Use linear timeouts for thin streams*/
+#define TCP_THIN_DUPACK         17      /* Fast retrans. after 1 dupack */
+#define TCP_USER_TIMEOUT	18	/* How long for loss retry before timeout */
+#define TCP_REPAIR		19	/* TCP sock is under repair right now */
+#define TCP_REPAIR_QUEUE	20
+#define TCP_QUEUE_SEQ		21
+#define TCP_REPAIR_OPTIONS	22
+#define TCP_FASTOPEN		23	/* Enable FastOpen on listeners */
+#define TCP_TIMESTAMP		24
+#define TCP_NOTSENT_LOWAT	25	/* limit number of unsent bytes in write queue */
 
 #define TCPI_OPT_TIMESTAMPS	1
 #define TCPI_OPT_SACK		2
 #define TCPI_OPT_WSCALE		4
 #define TCPI_OPT_ECN		8
+#define TCPI_OPT_ECN_SEEN	16 /* we received at least one packet with ECT */
+#define TCPI_OPT_SYN_DATA	32 /* SYN-ACK acked data in SYN sent or rcvd */
 
 enum tcp_ca_state {
   TCP_CA_Open = 0,
@@ -161,6 +182,24 @@
   uint32_t tcpi_snd_cwnd;
   uint32_t tcpi_advmss;
   uint32_t tcpi_reordering;
+  uint32_t tcpi_rcv_rtt;
+  uint32_t tcpi_rcv_space;
+
+  uint32_t tcpi_total_retrans;
+
+  uint64_t tcpi_pacing_rate;
+  uint64_t tcpi_max_pacing_rate;
+};
+
+/* for TCP_MD5SIG socket option */
+#define TCP_MD5SIG_MAXKEYLEN	80
+
+struct tcp_md5sig {
+  struct sockaddr_storage tcpm_addr;	/* address associated */
+  uint16_t __tcpm_pad1;				/* zero */
+  uint16_t tcpm_keylen;				/* key length */
+  uint32_t __tcpm_pad2;				/* zero */
+  uint8_t tcpm_key[TCP_MD5SIG_MAXKEYLEN];	/* key (binary) */
 };
 
 __END_DECLS
diff -urN -x .git dietlibc-0.33/include/netpacket/packet.h dietlibc/include/netpacket/packet.h
--- dietlibc-0.33/include/netpacket/packet.h	2003-08-19 16:58:18.000000000 +0000
+++ dietlibc/include/netpacket/packet.h	2015-01-01 12:14:43.474938895 +0000
@@ -5,6 +5,13 @@
 
 __BEGIN_DECLS
 
+struct sockaddr_pkt {
+  unsigned short int spkt_family;
+  unsigned char spkt_device[14];
+  unsigned short int spkt_protocol;
+};
+
+
 struct sockaddr_ll {
   unsigned short int sll_family;
   unsigned short int sll_protocol;
@@ -21,6 +28,9 @@
 #define PACKET_OTHERHOST	3		/* To someone else.  */
 #define PACKET_OUTGOING		4		/* Originated by us. */
 #define PACKET_LOOPBACK		5
+#define PACKET_USER		6		/* To user space	*/
+#define PACKET_KERNEL		7		/* To kernel space	*/
+/* Unused, PACKET_FASTROUTE and PACKET_LOOPBACK are invisible to user space */
 #define PACKET_FASTROUTE	6
 
 /* Packet socket options.  */
@@ -30,6 +40,240 @@
 #define PACKET_RECV_OUTPUT		3
 #define PACKET_RX_RING			5
 #define PACKET_STATISTICS		6
+#define PACKET_COPY_THRESH		7
+#define PACKET_AUXDATA			8
+#define PACKET_ORIGDEV			9
+#define PACKET_VERSION			10
+#define PACKET_HDRLEN			11
+#define PACKET_RESERVE			12
+#define PACKET_TX_RING			13
+#define PACKET_LOSS			14
+#define PACKET_VNET_HDR			15
+#define PACKET_TX_TIMESTAMP		16
+#define PACKET_TIMESTAMP		17
+#define PACKET_FANOUT			18
+#define PACKET_TX_HAS_OFF		19
+#define PACKET_QDISC_BYPASS		20
+
+#define PACKET_FANOUT_HASH		0
+#define PACKET_FANOUT_LB		1
+#define PACKET_FANOUT_CPU		2
+#define PACKET_FANOUT_ROLLOVER		3
+#define PACKET_FANOUT_RND		4
+#define PACKET_FANOUT_QM		5
+#define PACKET_FANOUT_FLAG_ROLLOVER	0x1000
+#define PACKET_FANOUT_FLAG_DEFRAG	0x8000
+
+struct tpacket_stats {
+  unsigned int tp_packets;
+  unsigned int tp_drops;
+};
+
+struct tpacket_stats_v3 {
+  unsigned int tp_packets;
+  unsigned int tp_drops;
+  unsigned int tp_freeze_q_cnt;
+};
+
+union tpacket_stats_u {
+  struct tpacket_stats stats1;
+  struct tpacket_stats_v3 stats3;
+};
+
+struct tpacket_auxdata {
+  uint32_t tp_status;
+  uint32_t tp_len;
+  uint32_t tp_snaplen;
+  uint16_t tp_mac;
+  uint16_t tp_net;
+  uint16_t tp_vlan_tci;
+  uint16_t tp_vlan_tpid;
+};
+
+/* Rx ring - header status */
+#define TP_STATUS_KERNEL		      0
+#define TP_STATUS_USER			(1 << 0)
+#define TP_STATUS_COPY			(1 << 1)
+#define TP_STATUS_LOSING		(1 << 2)
+#define TP_STATUS_CSUMNOTREADY		(1 << 3)
+#define TP_STATUS_VLAN_VALID		(1 << 4) /* auxdata has valid tp_vlan_tci */
+#define TP_STATUS_BLK_TMO		(1 << 5)
+#define TP_STATUS_VLAN_TPID_VALID	(1 << 6) /* auxdata has valid tp_vlan_tpid */
+
+/* Tx ring - header status */
+#define TP_STATUS_AVAILABLE	      0
+#define TP_STATUS_SEND_REQUEST	(1 << 0)
+#define TP_STATUS_SENDING	(1 << 1)
+#define TP_STATUS_WRONG_FORMAT	(1 << 2)
+
+/* Rx and Tx ring - header status */
+#define TP_STATUS_TS_SOFTWARE		(1 << 29)
+#define TP_STATUS_TS_SYS_HARDWARE	(1 << 30)
+#define TP_STATUS_TS_RAW_HARDWARE	(1 << 31)
+
+/* Rx ring - feature request bits */
+#define TP_FT_REQ_FILL_RXHASH	0x1
+
+struct tpacket_hdr {
+  unsigned long tp_status;
+  unsigned int tp_len;
+  unsigned int tp_snaplen;
+  unsigned short tp_mac;
+  unsigned short tp_net;
+  unsigned int tp_sec;
+  unsigned int tp_usec;
+};
+
+#define TPACKET_ALIGNMENT	16
+#define TPACKET_ALIGN(x)	(((x)+TPACKET_ALIGNMENT-1)&~(TPACKET_ALIGNMENT-1))
+#define TPACKET_HDRLEN		(TPACKET_ALIGN(sizeof(struct tpacket_hdr)) + sizeof(struct sockaddr_ll))
+
+struct tpacket2_hdr {
+  uint32_t tp_status;
+  uint32_t tp_len;
+  uint32_t tp_snaplen;
+  uint16_t tp_mac;
+  uint16_t tp_net;
+  uint32_t tp_sec;
+  uint32_t tp_nsec;
+  uint16_t tp_vlan_tci;
+  uint16_t tp_vlan_tpid;
+  uint8_t tp_padding[4];
+};
+
+struct tpacket_hdr_variant1 {
+  uint32_t tp_rxhash;
+  uint32_t tp_vlan_tci;
+  uint16_t tp_vlan_tpid;
+  uint16_t tp_padding;
+};
+
+struct tpacket3_hdr {
+  uint32_t tp_next_offset;
+  uint32_t tp_sec;
+  uint32_t tp_nsec;
+  uint32_t tp_snaplen;
+  uint32_t tp_len;
+  uint32_t tp_status;
+  uint16_t tp_mac;
+  uint16_t tp_net;
+  /* pkt_hdr variants */
+  union {
+    struct tpacket_hdr_variant1 hv1;
+  };
+  uint8_t tp_padding[8];
+};
+
+struct tpacket_bd_ts {
+  unsigned int ts_sec;
+  union {
+    unsigned int ts_usec;
+    unsigned int ts_nsec;
+  };
+};
+
+struct tpacket_hdr_v1 {
+  uint32_t block_status;
+  uint32_t num_pkts;
+  uint32_t offset_to_first_pkt;
+
+  /* Number of valid bytes (including padding)
+    * blk_len <= tp_block_size
+    */
+  uint32_t blk_len;
+
+  /*
+    * Quite a few uses of sequence number:
+    * 1. Make sure cache flush etc worked.
+    *    Well, one can argue - why not use the increasing ts below?
+    *    But look at 2. below first.
+    * 2. When you pass around blocks to other user space decoders,
+    *    you can see which blk[s] is[are] outstanding etc.
+    * 3. Validate kernel code.
+    */
+  uint64_t seq_num;
+
+  /*
+    * ts_last_pkt:
+    *
+    * Case 1.	Block has 'N'(N >=1) packets and TMO'd(timed out)
+    *		ts_last_pkt == 'time-stamp of last packet' and NOT the
+    *		time when the timer fired and the block was closed.
+    *		By providing the ts of the last packet we can absolutely
+    *		guarantee that time-stamp wise, the first packet in the
+    *		next block will never precede the last packet of the
+    *		previous block.
+    * Case 2.	Block has zero packets and TMO'd
+    *		ts_last_pkt = time when the timer fired and the block
+    *		was closed.
+    * Case 3.	Block has 'N' packets and NO TMO.
+    *		ts_last_pkt = time-stamp of the last pkt in the block.
+    *
+    * ts_first_pkt:
+    *		Is always the time-stamp when the block was opened.
+    *		Case a)	ZERO packets
+    *			No packets to deal with but atleast you know the
+    *			time-interval of this block.
+    *		Case b) Non-zero packets
+    *			Use the ts of the first packet in the block.
+    *
+    */
+  struct tpacket_bd_ts ts_first_pkt, ts_last_pkt;
+};
+
+union tpacket_bd_header_u {
+  struct tpacket_hdr_v1 bh1;
+};
+
+struct tpacket_block_desc {
+  uint32_t version;
+  uint32_t offset_to_priv;
+  union tpacket_bd_header_u hdr;
+};
+
+#define TPACKET2_HDRLEN		(TPACKET_ALIGN(sizeof(struct tpacket2_hdr)) + sizeof(struct sockaddr_ll))
+#define TPACKET3_HDRLEN		(TPACKET_ALIGN(sizeof(struct tpacket3_hdr)) + sizeof(struct sockaddr_ll))
+
+enum tpacket_versions {
+  TPACKET_V1,
+  TPACKET_V2,
+  TPACKET_V3
+};
+
+/*
+   Frame structure:
+
+   - Start. Frame must be aligned to TPACKET_ALIGNMENT=16
+   - struct tpacket_hdr
+   - pad to TPACKET_ALIGNMENT=16
+   - struct sockaddr_ll
+   - Gap, chosen so that packet data (Start+tp_net) alignes to TPACKET_ALIGNMENT=16
+   - Start+tp_mac: [ Optional MAC header ]
+   - Start+tp_net: Packet data, aligned to TPACKET_ALIGNMENT=16.
+   - Pad to align to TPACKET_ALIGNMENT=16
+ */
+
+struct tpacket_req {
+  unsigned int tp_block_size;	/* Minimal size of contiguous block */
+  unsigned int tp_block_nr;	/* Number of blocks */
+  unsigned int tp_frame_size;	/* Size of frame */
+  unsigned int tp_frame_nr;	/* Total number of frames */
+};
+
+struct tpacket_req3 {
+  unsigned int tp_block_size;	/* Minimal size of contiguous block */
+  unsigned int tp_block_nr;	/* Number of blocks */
+  unsigned int tp_frame_size;	/* Size of frame */
+  unsigned int tp_frame_nr;	/* Total number of frames */
+  unsigned int tp_retire_blk_tov; /* timeout in msecs */
+  unsigned int tp_sizeof_priv; /* offset to private data area */
+  unsigned int tp_feature_req_word;
+};
+
+union tpacket_req_u {
+  struct tpacket_req req;
+  struct tpacket_req3 req3;
+};
 
 struct packet_mreq {
   int mr_ifindex;
@@ -41,6 +285,7 @@
 #define PACKET_MR_MULTICAST	0
 #define PACKET_MR_PROMISC	1
 #define PACKET_MR_ALLMULTI	2
+#define PACKET_MR_UNICAST	3
 
 __END_DECLS
 
diff -urN -x .git dietlibc-0.33/include/paths.h dietlibc/include/paths.h
--- dietlibc-0.33/include/paths.h	2008-05-06 17:18:34.000000000 +0000
+++ dietlibc/include/paths.h	2015-01-01 12:14:43.474938895 +0000
@@ -2,7 +2,7 @@
 #define _PATHS_H
 
 #define _PATH_BSHELL "/bin/sh"
-#define _PATH_DEFPATH "/bin:/usr/bin:"
+#define _PATH_DEFPATH "/bin:/usr/bin"
 
 #define _PATH_DEVNULL "/dev/null"
 
diff -urN -x .git dietlibc-0.33/include/sched.h dietlibc/include/sched.h
--- dietlibc-0.33/include/sched.h	2012-01-24 18:24:25.000000000 +0000
+++ dietlibc/include/sched.h	2015-01-01 12:14:43.478272229 +0000
@@ -25,29 +25,29 @@
 
 /* END OF COPY form kernel-header */
 
-int __sched_setparam(pid_t pid, const struct sched_param* p);
-int sched_setparam(pid_t pid, const struct sched_param* p);
+int __sched_setparam(pid_t pid, const struct sched_param* p) __THROW;
+int sched_setparam(pid_t pid, const struct sched_param* p) __THROW;
 
-int __sched_getparam(pid_t pid, struct sched_param* p);
-int sched_getparam(pid_t pid, struct sched_param* p);
+int __sched_getparam(pid_t pid, struct sched_param* p) __THROW;
+int sched_getparam(pid_t pid, struct sched_param* p) __THROW;
 
-int __sched_getscheduler(pid_t pid);
-int sched_getscheduler(pid_t pid);
+int __sched_getscheduler(pid_t pid) __THROW;
+int sched_getscheduler(pid_t pid) __THROW;
 
-int __sched_setscheduler(pid_t pid, int policy, const struct sched_param* p);
-int sched_setscheduler(pid_t pid, int policy, const struct sched_param* p);
+int __sched_setscheduler(pid_t pid, int policy, const struct sched_param* p) __THROW;
+int sched_setscheduler(pid_t pid, int policy, const struct sched_param* p) __THROW;
 
-int __sched_yield(void);
-int sched_yield(void);
+int __sched_yield(void) __THROW;
+int sched_yield(void) __THROW;
 
-int __sched_get_priority_max(int policy);
-int sched_get_priority_max(int policy);
+int __sched_get_priority_max(int policy) __THROW;
+int sched_get_priority_max(int policy) __THROW;
 
-int __sched_get_priority_min(int policy);
-int sched_get_priority_min(int policy);
+int __sched_get_priority_min(int policy) __THROW;
+int sched_get_priority_min(int policy) __THROW;
 
-int __sched_rr_get_interval(pid_t pid, struct timespec* tp);
-int sched_rr_get_interval(pid_t pid, struct timespec* tp);
+int __sched_rr_get_interval(pid_t pid, struct timespec* tp) __THROW;
+int sched_rr_get_interval(pid_t pid, struct timespec* tp) __THROW;
 
 #ifdef _GNU_SOURCE
 /*
@@ -63,12 +63,28 @@
 #define CLONE_VFORK     0x00004000      /* set if the parent wants the child to wake it up on mm_release */
 #define CLONE_PARENT    0x00008000      /* set if we want to have the same parent as the cloner */
 #define CLONE_THREAD    0x00010000      /* Same thread group? */
+#define CLONE_NEWNS     0x00020000
+#define CLONE_SYSVSEM   0x00040000
+#define CLONE_SETTLS    0x00080000
+#define CLONE_PARENT_SETTID 0x00100000
+#define CLONE_CHILD_CLEARTID 0x00200000
+#define CLONE_DETACHED  0x00400000
+#define CLONE_UNTRACED  0x00800000
+#define CLONE_CHILD_SETTID 0x01000000
+#define CLONE_NEWUTS    0x04000000
+#define CLONE_NEWIPC    0x08000000
+#define CLONE_NEWUSER   0x10000000
+#define CLONE_NEWPID    0x20000000
+#define CLONE_NEWNET    0x40000000
+#define CLONE_IO        0x80000000
 
 #define CLONE_SIGNAL    (CLONE_SIGHAND | CLONE_THREAD)
 
-int clone(int *(*fn)(void*),void* stack,int flags,void* arg, ...);
+int clone(int (*fn)(void*),void* stack,int flags,void* arg, ...) __THROW;
 
-int unshare(int flags);
+int unshare(int flags) __THROW;
+
+long set_tid_address(int* tid) __THROW;
 
 /*
  * Linux CPU affinity.
@@ -112,11 +128,13 @@
 	return *s1 == *s2;
 }
 
-int sched_setaffinity(pid_t pid, size_t size, cpu_set_t *mask);
-int sched_getaffinity(pid_t pid, size_t size, cpu_set_t *mask);
+int sched_setaffinity(pid_t pid, size_t size, cpu_set_t *mask) __THROW;
+int sched_getaffinity(pid_t pid, size_t size, cpu_set_t *mask) __THROW;
 #define pthread_setaffinity_np sched_setaffinity
 #define pthread_getaffinity_np sched_getaffinity
 
+int setns(int fd,int nstype) __THROW;
+
 #endif
 
 __END_DECLS
diff -urN -x .git dietlibc-0.33/include/search.h dietlibc/include/search.h
--- dietlibc-0.33/include/search.h	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/include/search.h	2015-01-01 12:14:43.478272229 +0000
@@ -0,0 +1,40 @@
+#ifndef SEARCH_H
+#define SEARCH_H
+
+#include <sys/cdefs.h>
+#include <stddef.h>
+#include <stdint.h>
+
+typedef enum { FIND, ENTER } ACTION;
+typedef struct entry { char* key; void* data; } ENTRY;
+
+extern ENTRY* hsearch(ENTRY item, ACTION action) __THROW;
+extern int hcreate(size_t count) __THROW;
+extern void hdestroy(void) __THROW;
+
+#ifdef _GNU_SOURCE
+/* This is the internal structure of the hash table buckets.
+ * Do not use it or your program will be dietlibc-only!
+ * It's here so it's possible to write traversal code. */
+struct bucket {
+  struct bucket* next;
+  struct entry e;
+  size_t hv;
+};
+#else
+struct bucket;
+#endif
+
+struct hsearch_data {
+  struct bucket** table;
+  size_t size, filled;
+  unsigned char key[16];
+};
+
+extern int hsearch_r(ENTRY item, ACTION action, ENTRY** retval, struct hsearch_data* htab) __THROW;
+extern int hcreate_r(size_t count, struct hsearch_data* htab) __THROW;
+extern void hdestroy_r(struct hsearch_data* htab) __THROW;
+
+extern uint64_t siphash24(const unsigned char key[16], const unsigned char *in, size_t len) __THROW;
+
+#endif
diff -urN -x .git dietlibc-0.33/include/setjmp.h dietlibc/include/setjmp.h
--- dietlibc-0.33/include/setjmp.h	2005-09-28 06:18:43.000000000 +0000
+++ dietlibc/include/setjmp.h	2015-01-01 12:14:43.478272229 +0000
@@ -166,7 +166,7 @@
 #ifdef __arm__
 #define __JMP_BUF_SP            8
 #ifndef __ASSEMBLER__
-typedef int __jmp_buf[24];
+typedef int __jmp_buf[10 + 16*2 + 16*2];
 #endif
 #endif
 
@@ -222,12 +222,12 @@
 extern int __sigsetjmp(jmp_buf __env,int __savemask) __THROW;
 
 extern void longjmp(jmp_buf __env,int __val)
-     __THROW __attribute__((__noreturn__));
+     __THROWNL __attribute__((__noreturn__));
 
 typedef jmp_buf sigjmp_buf;
 
 extern void siglongjmp(sigjmp_buf __env,int __val)
-     __THROW __attribute__((__noreturn__));
+     __THROWNL __attribute__((__noreturn__));
 
 #ifdef _BSD_SOURCE
 #define setjmp(env) __sigsetjmp(env,1)
diff -urN -x .git dietlibc-0.33/include/signal.h dietlibc/include/signal.h
--- dietlibc-0.33/include/signal.h	2005-09-28 06:18:43.000000000 +0000
+++ dietlibc/include/signal.h	2015-01-01 12:14:43.478272229 +0000
@@ -431,10 +431,10 @@
 # define POLL_HUP	POLL_HUP
 };
 
-#define _NSIG_WORDS	((_NSIG/sizeof(long))>>3)
+#define _SIGSET_WORDS	(1024 / (8 * sizeof (unsigned long int)))
 
 typedef struct {
-  unsigned long sig[_NSIG_WORDS];
+  unsigned long sig[_SIGSET_WORDS];
 } sigset_t;
 
 struct sigaction {
diff -urN -x .git dietlibc-0.33/include/stdlib.h dietlibc/include/stdlib.h
--- dietlibc-0.33/include/stdlib.h	2012-01-24 18:24:25.000000000 +0000
+++ dietlibc/include/stdlib.h	2015-01-01 12:14:43.478272229 +0000
@@ -14,6 +14,9 @@
 void free(void *ptr) __THROW;
 void *realloc(void *ptr, size_t size) __THROW __attribute_malloc__;
 
+/* useful OpenBSD extension: */
+void* reallocarray(void* ptr, size_t nmemb, size_t size) __THROW __attribute_malloc__;
+
 char *getenv(const char *name) __THROW __pure;
 int putenv(const char *string) __THROW;
 int setenv(const char *name, const char *value, int overwrite) __THROW;
@@ -28,8 +31,12 @@
 long int strtol(const char *nptr, char **endptr, int base) __THROW;
 unsigned long int strtoul(const char *nptr, char **endptr, int base) __THROW;
 
+/* HACK: used flags in __dtostr
+     0x01 ... 'g'
+     0x02 ... uppercase
+   Define some constants somewhere... */
 extern int __ltostr(char *s, unsigned int size, unsigned long i, unsigned int base, int UpCase) __THROW;
-extern int __dtostr(double d,char *buf,unsigned int maxlen,unsigned int prec,unsigned int prec2,int g) __THROW;
+extern int __dtostr(double d,char *buf,unsigned int maxlen,unsigned int prec,unsigned int prec2,int flags) __THROW;
 
 #if !defined(__STRICT_ANSI__) || __STDC_VERSION__ + 0 >= 199900L
 __extension__ long long int strtoll(const char *nptr, char **endptr, int base) __THROW;
@@ -43,7 +50,7 @@
 __extension__ long long int atoll(const char *nptr);
 
 void exit(int status) __THROW __attribute__((__noreturn__));
-void abort(void) __THROW;
+void abort(void) __THROW __attribute__((__noreturn__));
 
 extern int rand(void) __THROW;
 extern int rand_r(unsigned int *seed) __THROW;
diff -urN -x .git dietlibc-0.33/include/sys/atomic.h dietlibc/include/sys/atomic.h
--- dietlibc-0.33/include/sys/atomic.h	2012-04-19 16:50:20.000000000 +0000
+++ dietlibc/include/sys/atomic.h	2015-01-01 12:14:43.478272229 +0000
@@ -15,11 +15,9 @@
 
 #define __kernel_cmpxchg (*(__kernel_cmpxchg_t *)0xffff0fc0)
 
-#define CAS(ptr,oldval,newval) __kernel_cmpxchg(oldval,newval,ptr)
+#define __CAS(ptr,oldval,newval) __kernel_cmpxchg(oldval,newval,ptr)
 
-#else
-
-#if defined(__INTEL_COMPILER) || (__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 1))
+#elif defined(__INTEL_COMPILER) || (__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 1))
 
 /* recent gcc versions and the intel compiler have built-ins for this */
 #define __CAS(ptr,oldval,newval) __sync_val_compare_and_swap(ptr,oldval,newval)
@@ -45,8 +43,6 @@
 #endif
 
 #endif
-
-#endif
 
 #if defined(__INTEL_COMPILER) || (__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 1))
 
diff -urN -x .git dietlibc-0.33/include/sys/auxv.h dietlibc/include/sys/auxv.h
--- dietlibc-0.33/include/sys/auxv.h	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/include/sys/auxv.h	2015-01-01 12:14:43.478272229 +0000
@@ -0,0 +1,40 @@
+#ifndef SYS_AUXV
+#define SYS_AUXV
+
+#include <sys/cdefs.h>
+
+unsigned long getauxval(unsigned long type);
+
+#ifndef AT_BASE
+/* don't fail if they already included elf.h */
+enum {
+  AT_BASE=7,
+  AT_BASE_PLATFORM=24,
+  AT_CLKTCK=17,
+  AT_DCACHEBSIZE=19,
+  AT_EGID=14,
+  AT_ENTRY=9,
+  AT_EUID=12,
+  AT_EXECFD=2,
+  AT_EXECFN=31,
+  AT_FLAGS=8,
+  AT_FPUCW=18,
+  AT_GID=13,
+  AT_HWCAP=16,
+  AT_HWCAP2=26,
+  AT_ICACHEBSIZE=20,
+  AT_PAGESZ=6,
+  AT_PHDR=3,
+  AT_PHENT=4,
+  AT_PHNUM=5,
+  AT_PLATFORM=15,
+  AT_RANDOM=25,
+  AT_SECURE=23,
+  AT_SYSINFO=32,
+  AT_SYSINFO_EHDR=33,
+  AT_UCACHEBSIZE=21,
+  AT_UID=11
+};
+#endif
+
+#endif
diff -urN -x .git dietlibc-0.33/include/sys/cdefs.h dietlibc/include/sys/cdefs.h
--- dietlibc-0.33/include/sys/cdefs.h	2009-07-01 00:27:26.000000000 +0000
+++ dietlibc/include/sys/cdefs.h	2015-01-01 12:14:43.478272229 +0000
@@ -16,6 +16,22 @@
 #define __extension__
 #endif
 
+#if (__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 6))
+#define __leaf , __leaf__
+#else
+#define __leaf
+#endif
+
+#if !defined(__cplusplus) && ((__GNUC__ > 3) || ((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)))
+#undef __THROW
+#define __THROW __attribute__((__nothrow__ __leaf))
+#define __THROWNL __attribute__((__nothrow__))
+#endif
+
+#ifndef __THROWNL
+#define __THROWNL __THROW
+#endif
+
 #if (__GNUC__ > 2) || ((__GNUC__ == 2) && (__GNUC_MINOR__ >= 96))
 #define __pure __attribute__ ((__pure__))
 #else
diff -urN -x .git dietlibc-0.33/include/sys/epoll.h dietlibc/include/sys/epoll.h
--- dietlibc-0.33/include/sys/epoll.h	2012-11-02 11:17:28.000000000 +0000
+++ dietlibc/include/sys/epoll.h	2015-01-01 12:14:43.478272229 +0000
@@ -5,12 +5,10 @@
 #include <sys/types.h>
 #include <poll.h>
 #include <signal.h>
+#include <fcntl.h>
 
 __BEGIN_DECLS
 
-/* Flags for epoll_create1.  */
-#define EPOLL_CLOEXEC O_CLOEXEC
-
 /* Valid opcodes ( "op" parameter ) to issue to epoll_ctl() */
 #define EPOLL_CTL_ADD 1	/* Add a file decriptor to the interface */
 #define EPOLL_CTL_DEL 2	/* Remove a file decriptor from the interface */
@@ -52,6 +50,13 @@
 #define EPOLLET EPOLLET
 };
 
+/* flags for epoll_create1 */
+enum {
+  EPOLL_CLOEXEC = O_CLOEXEC
+#define EPOLL_CLOEXEC EPOLL_CLOEXEC
+};
+
+
 typedef union epoll_data {
   void *ptr;
   int fd;
@@ -69,6 +74,7 @@
 ;
 
 int epoll_create(int size) __THROW;
+int epoll_create1(int flags) __THROW;
 int epoll_ctl(int epfd, int op, int fd, struct epoll_event* event) __THROW;
 int epoll_wait(int epfd, struct epoll_event *events, int maxevents,
 	       int timeout) __THROW;
diff -urN -x .git dietlibc-0.33/include/sys/eventfd.h dietlibc/include/sys/eventfd.h
--- dietlibc-0.33/include/sys/eventfd.h	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/include/sys/eventfd.h	2015-01-01 12:14:43.478272229 +0000
@@ -0,0 +1,25 @@
+#ifndef _SYS_EVENTFD_H
+#define _SYS_EVENTFD_H
+
+#include <sys/cdefs.h>
+#include <sys/types.h>
+#include <fcntl.h>
+
+__BEGIN_DECLS
+
+enum {
+  EFD_CLOEXEC = O_CLOEXEC,
+#define EFD_CLOEXEC EFD_CLOEXEC
+  EFD_NONBLOCK = O_NONBLOCK,
+#define EFD_NONBLOCK EFD_NONBLOCK
+  EFD_SEMAPHORE = 1
+#define EFD_SEMAPHORE EFD_SEMAPHORE
+};
+
+typedef uint64_t eventfd_t;
+
+int eventfd(unsigned int initval, int flags) __THROW;
+
+__END_DECLS
+
+#endif
diff -urN -x .git dietlibc-0.33/include/sys/fanotify.h dietlibc/include/sys/fanotify.h
--- dietlibc-0.33/include/sys/fanotify.h	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/include/sys/fanotify.h	2015-01-01 12:14:43.478272229 +0000
@@ -0,0 +1,24 @@
+#ifndef SYS_FANOITFY_H
+#define SYS_FANOITFY_H
+
+#include <sys/cdefs.h>
+#include <stdint.h>
+#include <sys/types.h>
+
+struct fanotify_event_metadata {
+  uint32_t event_len;
+  uint8_t vers, reserved;
+  uint16_t metadata_len;
+  uint64_t mask;
+  int32_t fd, pid;
+}
+
+__BEGIN_DECLS
+
+int fanotify_init(unsigned int flags, unsigned int event_f_flags);
+int fanotify_mark(int fanotify_fd, unsigned int flags,
+		  uint64_t mask, int dirfd, const char *pathname);
+
+__END_DECLS
+
+#endif
diff -urN -x .git dietlibc-0.33/include/sys/futex.h dietlibc/include/sys/futex.h
--- dietlibc-0.33/include/sys/futex.h	2005-10-04 17:47:03.000000000 +0000
+++ dietlibc/include/sys/futex.h	2015-01-01 12:14:43.478272229 +0000
@@ -1,8 +1,11 @@
 #ifndef _SYS_FUTEX_H
 #define _SYS_FUTEX_H
 
+#include <sys/types.h>
 #include <sys/time.h>
 
+__BEGIN_DECLS
+
 enum {
   FUTEX_WAIT=0,
   FUTEX_WAKE=1,
@@ -13,4 +16,6 @@
 
 long futex(int* uaddr,int op,int val,const struct timespec* timeout,int* uaddr2,int val3);
 
+__END_DECLS
+
 #endif
diff -urN -x .git dietlibc-0.33/include/sys/inotify.h dietlibc/include/sys/inotify.h
--- dietlibc-0.33/include/sys/inotify.h	2008-05-06 17:18:34.000000000 +0000
+++ dietlibc/include/sys/inotify.h	2015-01-01 12:14:43.478272229 +0000
@@ -52,12 +52,16 @@
 			 IN_MOVED_TO | IN_DELETE | IN_CREATE | IN_DELETE_SELF | \
 			 IN_MOVE_SELF)
 
+/* Flags for sys_inotify_init1.  */
+#define IN_CLOEXEC O_CLOEXEC
+#define IN_NONBLOCK O_NONBLOCK
 
 __BEGIN_DECLS
 
 int inotify_init(void) __THROW;
-int inotify_add_watch(int fd,const char* path,unsigned long mask);
-int inotify_rm_watch(int fd,int wd);
+int inotify_init1(int flags) __THROW;
+int inotify_add_watch(int fd,const char* path,unsigned long mask) __THROW;
+int inotify_rm_watch(int fd,int wd) __THROW;
 
 __END_DECLS
 
diff -urN -x .git dietlibc-0.33/include/sys/mman.h dietlibc/include/sys/mman.h
--- dietlibc-0.33/include/sys/mman.h	2007-10-17 11:47:57.000000000 +0000
+++ dietlibc/include/sys/mman.h	2015-01-01 12:14:43.478272229 +0000
@@ -13,10 +13,27 @@
 #define PROT_READ	0x1		/* page can be read */
 #define PROT_WRITE	0x2		/* page can be written */
 #define PROT_EXEC	0x4		/* page can be executed */
+#define PROT_SEM	0x8		/* page may be used for atomic ops */
 #define PROT_NONE	0x0		/* page can not be accessed */
 
+#define PROT_GROWSDOWN	0x01000000	/* mprotect flag: extend change to start of growsdown vma */
+#define PROT_GROWSUP	0x02000000	/* mprotect flag: extend change to end of growsdown vma */
+
 #define MAP_SHARED	0x01		/* Share changes */
 #define MAP_PRIVATE	0x02		/* Changes are private */
+#define MAP_TYPE	0xf		/* Mask for type of mapping */
+
+#define MADV_REMOVE		9
+#define MADV_DONTFORK		10
+#define MADV_DOFORK		11
+#define MADV_MERGEABLE		12
+#define MADV_UNMERGEABLE	13
+#define MADV_HUGEPAGE		14
+#define MADV_NOHUGEPAGE		15
+#define MADV_DONTDUMP		16
+#define MADV_DODUMP		17
+#define MADV_HWPOISON		100
+#define MADV_SOFT_OFFLINE	101
 
 #if defined(__mips__)
 #define MAP_FIXED	0x010		/* Interpret addr exactly */
@@ -27,6 +44,9 @@
 #define MAP_EXECUTABLE	0x4000		/* mark it as an executable */
 #define MAP_LOCKED	0x8000		/* pages are locked */
 #define MAP_POPULATE	0x10000
+#define MAP_NONBLOCK	0x20000
+#define MAP_STACK	0x40000
+#define MAP_HUGETLB	0x80000
 #define MS_ASYNC	0x0001		/* sync memory asynchronously */
 #define MS_INVALIDATE	0x0002		/* invalidate mappings & caches */
 #define MS_SYNC		0x0004		/* synchronous memory sync */
@@ -46,6 +66,9 @@
 #define MAP_LOCKED	0x8000		/* lock the mapping */
 #define MAP_NORESERVE	0x10000		/* don't check for reservations */
 #define MAP_POPULATE	0x20000
+#define MAP_NONBLOCK	0x40000
+#define MAP_STACK	0x80000
+#define MAP_HUGETLB	0x100000
 #define MS_ASYNC	1		/* sync memory asynchronously */
 #define MS_SYNC		2		/* synchronous memory sync */
 #define MS_INVALIDATE	4		/* invalidate the caches */
@@ -57,7 +80,8 @@
 #define MADV_WILLNEED	3		/* will need these pages */
 #define MADV_SPACEAVAIL	5		/* ensure resources are available */
 #define MADV_DONTNEED	6		/* dont need these pages */
-#elif defined(__i386__) || defined(__s390__) || defined(__x86_64__)
+
+#elif defined(__i386__) || defined(__s390__) || defined(__x86_64__) || defined(__arm__)
 #define MAP_FIXED	0x10		/* Interpret addr exactly */
 #define MAP_ANONYMOUS	0x20		/* don't use a file */
 #define MAP_GROWSDOWN	0x0100		/* stack-like segment */
@@ -66,6 +90,9 @@
 #define MAP_LOCKED	0x2000		/* pages are locked */
 #define MAP_NORESERVE	0x4000		/* don't check for reservations */
 #define MAP_POPULATE	0x8000
+#define MAP_NONBLOCK	0x10000
+#define MAP_STACK	0x20000
+#define MAP_HUGETLB	0x40000
 #define MS_ASYNC	1		/* sync memory asynchronously */
 #define MS_INVALIDATE	2		/* invalidate the caches */
 #define MS_SYNC		4		/* synchronous memory sync */
@@ -76,6 +103,7 @@
 #define MADV_SEQUENTIAL	0x2		/* read-ahead aggressively */
 #define MADV_WILLNEED	0x3		/* pre-fault pages */
 #define MADV_DONTNEED	0x4		/* discard these pages */
+
 #elif defined(__sparc__) || defined (__powerpc__) || defined (__powerpc64__)
 #define MAP_FIXED	0x10		/* Interpret addr exactly */
 #define MAP_ANONYMOUS	0x20		/* don't use a file */
@@ -88,6 +116,9 @@
 #define MAP_DENYWRITE	0x0800		/* ETXTBSY */
 #define MAP_EXECUTABLE	0x1000		/* mark it as an executable */
 #define MAP_POPULATE	0x8000
+#define MAP_NONBLOCK	0x10000
+#define MAP_STACK	0x20000
+#define MAP_HUGETLB	0x40000
 #define MS_ASYNC	1		/* sync memory asynchronously */
 #define MS_INVALIDATE	2		/* invalidate the caches */
 #define MS_SYNC		4		/* synchronous memory sync */
@@ -99,27 +130,9 @@
 #define MADV_WILLNEED	0x3		/* pre-fault pages */
 #define MADV_DONTNEED	0x4		/* discard these pages */
 #define MADV_FREE	0x5		/* (Solaris) contents can be freed */
-#elif defined (__arm__)
-#define MAP_FIXED	0x10		/* Interpret addr exactly */
-#define MAP_ANONYMOUS	0x20		/* don't use a file */
-#define MAP_GROWSDOWN	0x0100		/* stack-like segment */
-#define MAP_DENYWRITE	0x0800		/* ETXTBSY */
-#define MAP_EXECUTABLE	0x1000		/* mark it as an executable */
-#define MAP_LOCKED	0x2000		/* pages are locked */
-#define MAP_NORESERVE	0x4000		/* don't check for reservations */
-#define MAP_POPULATE	0x8000
-#define MS_ASYNC	1		/* sync memory asynchronously */
-#define MS_INVALIDATE	2		/* invalidate the caches */
-#define MS_SYNC		4		/* synchronous memory sync */
-#define MCL_CURRENT	1		/* lock all current mappings */
-#define MCL_FUTURE	2		/* lock all future mappings */
-#define MADV_NORMAL	0x0		/* default page-in behavior */
-#define MADV_RANDOM	0x1		/* page-in minimum required */
-#define MADV_SEQUENTIAL	0x2		/* read-ahead aggressively */
-#define MADV_WILLNEED	0x3		/* pre-fault pages */
-#define MADV_DONTNEED	0x4		/* discard these pages */
 
 #elif defined(__hppa__)
+#undef MAP_TYPE
 #define MAP_TYPE	0x03	/* Mask for type of mapping */
 #define MAP_FIXED	0x04	/* Interpret addr exactly */
 #define MAP_ANONYMOUS	0x10	/* don't use a file */
@@ -130,6 +143,9 @@
 #define MAP_NORESERVE	0x4000	/* don't check for reservations */
 #define MAP_GROWSDOWN	0x8000	/* stack-like segment */
 #define MAP_POPULATE	0x10000
+#define MAP_NONBLOCK	0x20000
+#define MAP_STACK	0x40000
+#define MAP_HUGETLB	0x80000
 
 #define MS_SYNC 	1	/* synchronous memory sync */
 #define MS_ASYNC	2	/* sync memory asynchronously */
@@ -154,9 +170,23 @@
 #define MADV_4M_PAGES	22	/* Use 4 Megabyte pages */
 #define MADV_16M_PAGES	24	/* Use 16 Megabyte pages */
 #define MADV_64M_PAGES	26	/* Use 64 Megabyte pages */
+
+#undef MADV_MERGEABLE
+#undef MADV_UNMERGEABLE
+#undef MADV_HUGEPAGE
+#undef MADV_NOHUGEPAGE
+#undef MADV_DONTDUMP
+#undef MADV_DODUMP
+
+#define MADV_MERGEABLE 65
+#define MADV_UNMERGEABLE 66
+#define MADV_HUGEPAGE 67
+#define MADV_NOHUGEPAGE 68
+#define MADV_DONTDUMP 69
+#define MADV_DODUMP 70
+
 #elif defined(__ia64__)
 
-#define MAP_TYPE	0x0f	/* Mask for type of mapping */
 #define MAP_FIXED	0x10	/* Interpret addr exactly */
 #define MAP_ANONYMOUS	0x20	/* don't use a file */
 
@@ -167,8 +197,9 @@
 #define MAP_LOCKED	0x2000	/* pages are locked */
 #define MAP_NORESERVE	0x4000	/* don't check for reservations */
 #define MAP_POPULATE	0x8000
-#define MAP_WRITECOMBINED 0x10000	/* write-combine the area */
-#define MAP_NONCACHED	0x20000	/* don't cache the memory */
+#define MAP_NONBLOCK	0x10000
+#define MAP_STACK	0x20000
+#define MAP_HUGETLB	0x40000
 
 #define MS_ASYNC	1	/* sync memory asynchronously */
 #define MS_INVALIDATE	2	/* invalidate the caches */
diff -urN -x .git dietlibc-0.33/include/sys/prctl.h dietlibc/include/sys/prctl.h
--- dietlibc-0.33/include/sys/prctl.h	2007-03-09 13:42:12.000000000 +0000
+++ dietlibc/include/sys/prctl.h	2015-01-01 12:14:43.478272229 +0000
@@ -2,65 +2,7 @@
 #define _SYS_PRCTL_H
 
 #include <sys/cdefs.h>
-
-/* Values to pass as first argument to prctl() */
-
-#define PR_SET_PDEATHSIG  1  /* Second arg is a signal */
-#define PR_GET_PDEATHSIG  2  /* Second arg is a ptr to return the signal */
-
-/* Get/set current->mm->dumpable */
-#define PR_GET_DUMPABLE   3
-#define PR_SET_DUMPABLE   4
-
-/* Get/set unaligned access control bits (if meaningful) */
-#define PR_GET_UNALIGN	  5
-#define PR_SET_UNALIGN	  6
-# define PR_UNALIGN_NOPRINT	1	/* silently fix up unaligned user accesses */
-# define PR_UNALIGN_SIGBUS	2	/* generate SIGBUS on unaligned user access */
-
-/* Get/set whether or not to drop capabilities on setuid() away from uid 0 */
-#define PR_GET_KEEPCAPS   7
-#define PR_SET_KEEPCAPS   8
-
-/* Get/set floating-point emulation control bits (if meaningful) */
-#define PR_GET_FPEMU  9
-#define PR_SET_FPEMU 10
-# define PR_FPEMU_NOPRINT	1	/* silently emulate fp operations accesses */
-# define PR_FPEMU_SIGFPE	2	/* don't emulate fp operations, send SIGFPE instead */
-
-/* Get/set floating-point exception mode (if meaningful) */
-#define PR_GET_FPEXC	11
-#define PR_SET_FPEXC	12
-# define PR_FP_EXC_SW_ENABLE	0x80	/* Use FPEXC for FP exception enables */
-# define PR_FP_EXC_DIV		0x010000	/* floating point divide by zero */
-# define PR_FP_EXC_OVF		0x020000	/* floating point overflow */
-# define PR_FP_EXC_UND		0x040000	/* floating point underflow */
-# define PR_FP_EXC_RES		0x080000	/* floating point inexact result */
-# define PR_FP_EXC_INV		0x100000	/* floating point invalid operation */
-# define PR_FP_EXC_DISABLED	0	/* FP exceptions disabled */
-# define PR_FP_EXC_NONRECOV	1	/* async non-recoverable exc. mode */
-# define PR_FP_EXC_ASYNC	2	/* async recoverable exception mode */
-# define PR_FP_EXC_PRECISE	3	/* precise exception mode */
-
-/* Get/set whether we use statistical process timing or accurate timestamp
- * based process timing */
-#define PR_GET_TIMING   13
-#define PR_SET_TIMING   14
-# define PR_TIMING_STATISTICAL  0       /* Normal, traditional,
-                                                   statistical process timing */
-# define PR_TIMING_TIMESTAMP    1       /* Accurate timestamp based
-                                                   process timing */
-
-#define PR_SET_NAME    15		/* Set process name */
-#define PR_GET_NAME    16		/* Get process name */
-
-/* Get/set process endian */
-#define PR_GET_ENDIAN	19
-#define PR_SET_ENDIAN	20
-# define PR_ENDIAN_BIG		0
-# define PR_ENDIAN_LITTLE	1	/* True little endian mode */
-# define PR_ENDIAN_PPC_LITTLE	2	/* "PowerPC" pseudo little endian */
-
+#include <linux/prctl.h>
 
 __BEGIN_DECLS
 
diff -urN -x .git dietlibc-0.33/include/sys/shm.h dietlibc/include/sys/shm.h
--- dietlibc-0.33/include/sys/shm.h	2005-09-28 06:18:43.000000000 +0000
+++ dietlibc/include/sys/shm.h	2015-01-01 12:14:43.478272229 +0000
@@ -60,15 +60,6 @@
   unsigned long swap_successes;
 };
 
-#if defined(__i386__) || defined(__mips__) || defined(__arm__) || defined(__powerpc__) || defined (__powerpc64__) || defined(__s390__) || defined(__hppa__) || defined(__x86_64__) || defined(__ia64__)
-#define PAGE_SIZE 4096UL
-#define PAGE_SHIFT 12
-#elif defined(__alpha__) || defined(__sparc__)
-/* sun4* has 4k except sun4 architecture, sparc64 has 8k */
-#define PAGE_SIZE 8192UL
-#define PAGE_SHIFT 13
-#endif
-
 extern int shmget(key_t key, int size, int shmflg) __THROW;
 extern void *shmat(int shmid, const void *shmaddr, int shmflg) __THROW;
 extern int shmdt (const void *shmaddr) __THROW;
diff -urN -x .git dietlibc-0.33/include/sys/signalfd.h dietlibc/include/sys/signalfd.h
--- dietlibc-0.33/include/sys/signalfd.h	2008-02-19 00:28:13.000000000 +0000
+++ dietlibc/include/sys/signalfd.h	2015-01-01 12:14:43.478272229 +0000
@@ -26,7 +26,7 @@
 __BEGIN_DECLS
 
 extern int signalfd (int __fd, const sigset_t *__mask, int __flags)
-  __nonnull ((2)) __THROW;
+  __THROW __nonnull ((2)) ;
 
 __END_DECLS
 
diff -urN -x .git dietlibc-0.33/include/sys/socket.h dietlibc/include/sys/socket.h
--- dietlibc-0.33/include/sys/socket.h	2012-11-02 11:17:28.000000000 +0000
+++ dietlibc/include/sys/socket.h	2015-01-01 12:14:43.478272229 +0000
@@ -3,44 +3,98 @@
 
 #include <sys/cdefs.h>
 #include <sys/types.h>
+#include <fcntl.h>
 
 __BEGIN_DECLS
 
 /* For setsockopt(2) */
+
 #if defined(__alpha__) || defined(__mips__)
 #define SOL_SOCKET	0xffff
 
 #define SO_DEBUG	0x0001
 #define SO_REUSEADDR	0x0004
-#define SO_TYPE		0x1008
-#define SO_ERROR	0x1007
+#define SO_KEEPALIVE	0x0008
 #define SO_DONTROUTE	0x0010
 #define SO_BROADCAST	0x0020
+#define SO_LINGER	0x0080
+#define SO_OOBINLINE	0x0100
+#define SO_REUSEPORT	0x0200
+#define SO_TYPE		0x1008
+#define SO_ERROR	0x1007
 #define SO_SNDBUF	0x1001
 #define SO_RCVBUF	0x1002
-#define SO_KEEPALIVE	0x0008
-#define SO_OOBINLINE	0x0100
+
 #define SO_NO_CHECK	11
 #define SO_PRIORITY	12
-#define SO_LINGER	0x0080
 #define SO_BSDCOMPAT	14
-/* To add :#define SO_REUSEPORT 15 */
 #define SO_PASSCRED	17
 #define SO_PEERCRED	18
-#define SO_RCVLOWAT	0x1004
-#define SO_SNDLOWAT	0x1003
-#define SO_RCVTIMEO	0x1006
-#define SO_SNDTIMEO	0x1005
-#define SO_ACCEPTCONN	0x1009
+
+/* Security levels - as per NRL IPv6 - don't actually do anything */
+#define SO_SECURITY_AUTHENTICATION		19
+#define SO_SECURITY_ENCRYPTION_TRANSPORT	20
+#define SO_SECURITY_ENCRYPTION_NETWORK		21
+
+#define SO_BINDTODEVICE	25
+#define SO_ATTACH_FILTER	26
+#define SO_DETACH_FILTER	27
+#define SO_GET_FILTER	SO_ATTACH_FILTER
+#define SO_PEERNAME	28
+#define SO_TIMESTAMP	29
+#define SCM_TIMESTAMP	SO_TIMESTAMP
+#define SO_PEERSEC	30
+#define SO_PASSSEC	34
+#define SO_TIMESTAMPNS	35
+#define SCM_TIMESTAMPNS	SO_TIMESTAMPNS
+#define SO_MARK			36
+#define SO_TIMESTAMPING		37
+#define SCM_TIMESTAMPING	SO_TIMESTAMPING
+#define SO_RXQ_OVFL             40
+#define SO_WIFI_STATUS		41
+#define SCM_WIFI_STATUS		SO_WIFI_STATUS
+#define SO_PEEK_OFF		42
+
+/* Instruct lower device to use last 4-bytes of skb data as FCS */
+#define SO_NOFCS		43
+
+#define SO_LOCK_FILTER		44
+
+#define SO_SELECT_ERR_QUEUE	45
+
+#define SO_BUSY_POLL		46
+
+#define SO_MAX_PACING_RATE	47
+
+#define SO_BPF_EXTENSIONS	48
+
 
 #ifdef __alpha__
 #define SO_SNDBUFFORCE	0x100a
 #define SO_RCVBUFFORCE	0x100b
+
+#define	SO_RCVLOWAT	0x1010
+#define	SO_SNDLOWAT	0x1011
+#define	SO_RCVTIMEO	0x1012
+#define	SO_SNDTIMEO	0x1013
+#define SO_ACCEPTCONN	0x1014
+
 #else
+/* mips */
 #define SO_SNDBUFFORCE	31
 #define SO_RCVBUFFORCE	33
+
+#define SO_RCVLOWAT	0x1004
+#define SO_SNDLOWAT	0x1003
+#define SO_RCVTIMEO	0x1006
+#define SO_SNDTIMEO	0x1005
+#define SO_ACCEPTCONN	0x1009
+
 #endif
 
+#define SO_PROTOCOL	0x1028
+#define SO_DOMAIN	0x1029
+
 #define SO_STYLE	SO_TYPE /* Synonym */
 
 #elif defined(__hppa__)
@@ -74,6 +128,8 @@
 #define SO_PEERCRED	0x4011
 #define SO_TIMESTAMP	0x4012
 #define SCM_TIMESTAMP   SO_TIMESTAMP
+#define SO_TIMESTAMPNS	0x4013
+#define SCM_TIMESTAMPNS	SO_TIMESTAMPNS
 
 /* Security levels - as per NRL IPv6 - don't actually do anything */
 #define SO_SECURITY_AUTHENTICATION	0x4016
@@ -85,9 +141,37 @@
 /* Socket filtering */
 #define SO_ATTACH_FILTER	0x401a
 #define SO_DETACH_FILTER	0x401b
+#define SO_GET_FILTER		SO_ATTACH_FILTER
 
 #define SO_ACCEPTCONN	0x401c
 
+#define SO_PEERSEC		0x401d
+#define SO_PASSSEC		0x401e
+
+#define SO_MARK			0x401f
+
+#define SO_TIMESTAMPING		0x4020
+#define SCM_TIMESTAMPING	SO_TIMESTAMPING
+
+#define SO_RXQ_OVFL             0x4021
+
+#define SO_WIFI_STATUS		0x4022
+#define SCM_WIFI_STATUS		SO_WIFI_STATUS
+#define SO_PEEK_OFF		0x4023
+
+/* Instruct lower device to use last 4-bytes of skb data as FCS */
+#define SO_NOFCS		0x4024
+
+#define SO_LOCK_FILTER		0x4025
+
+#define SO_SELECT_ERR_QUEUE	0x4026
+
+#define SO_BUSY_POLL		0x4027
+
+#define SO_MAX_PACING_RATE	0x4028
+
+#define SO_BPF_EXTENSIONS	0x4029
+
 #elif defined(__sparc__)
 #define SOL_SOCKET	0xffff
 
@@ -120,11 +204,41 @@
 
 #define SO_ATTACH_FILTER	0x001a
 #define SO_DETACH_FILTER	0x001b
+#define SO_GET_FILTER		SO_ATTACH_FILTER
 
 #define SO_PEERNAME	0x001c
 #define SO_TIMESTAMP	0x001d
 #define SCM_TIMESTAMP	SO_TIMESTAMP
 
+#define SO_PEERSEC		0x001e
+#define SO_PASSSEC		0x001f
+#define SO_TIMESTAMPNS		0x0021
+#define SCM_TIMESTAMPNS		SO_TIMESTAMPNS
+
+#define SO_MARK			0x0022
+
+#define SO_TIMESTAMPING		0x0023
+#define SCM_TIMESTAMPING	SO_TIMESTAMPING
+
+#define SO_RXQ_OVFL             0x0024
+
+#define SO_WIFI_STATUS		0x0025
+#define SCM_WIFI_STATUS		SO_WIFI_STATUS
+#define SO_PEEK_OFF		0x0026
+
+/* Instruct lower device to use last 4-bytes of skb data as FCS */
+#define SO_NOFCS		0x0027
+
+#define SO_LOCK_FILTER		0x0028
+
+#define SO_SELECT_ERR_QUEUE	0x0029
+
+#define SO_BUSY_POLL		0x0030
+
+#define SO_MAX_PACING_RATE	0x0031
+
+#define SO_BPF_EXTENSIONS	0x0032
+
 /* Security levels - as per NRL IPv6 - don't actually do anything */
 #define SO_SECURITY_AUTHENTICATION              0x5001
 #define SO_SECURITY_ENCRYPTION_TRANSPORT        0x5002
@@ -155,28 +269,63 @@
 #define SO_SNDLOWAT	19
 #define SO_RCVTIMEO	20
 #define SO_SNDTIMEO	21
-#define SO_ACCEPTCONN	30
-#define SO_SNDBUFFORCE	32
-#define SO_RCVBUFFORCE	33
 
-#endif
-
-#if !defined(__hppa__) && !defined(__sparc__)
 /* Security levels - as per NRL IPv6 - don't actually do anything */
 #define SO_SECURITY_AUTHENTICATION		22
 #define SO_SECURITY_ENCRYPTION_TRANSPORT	23
 #define SO_SECURITY_ENCRYPTION_NETWORK		24
 
 #define SO_BINDTODEVICE	25
-
-/* Socket filtering */
-#define SO_ATTACH_FILTER        26
-#define SO_DETACH_FILTER        27
-
+#define SO_ATTACH_FILTER	26
+#define SO_DETACH_FILTER	27
+#define SO_GET_FILTER		SO_ATTACH_FILTER
 #define SO_PEERNAME		28
 #define SO_TIMESTAMP		29
 #define SCM_TIMESTAMP		SO_TIMESTAMP
+
+#define SO_ACCEPTCONN	30
+#define SO_PEERSEC		31
+#define SO_SNDBUFFORCE	32
+#define SO_RCVBUFFORCE	33
+#define SO_PASSSEC		34
+#define SO_TIMESTAMPNS		35
+#define SCM_TIMESTAMPNS		SO_TIMESTAMPNS
+
+#define SO_MARK			36
+
+#define SO_TIMESTAMPING		37
+#define SCM_TIMESTAMPING	SO_TIMESTAMPING
+
+#define SO_PROTOCOL		38
+#define SO_DOMAIN		39
+
+#define SO_RXQ_OVFL             40
+
+#define SO_WIFI_STATUS		41
+#define SCM_WIFI_STATUS	SO_WIFI_STATUS
+#define SO_PEEK_OFF		42
+
+/* Instruct lower device to use last 4-bytes of skb data as FCS */
+#define SO_NOFCS		43
+
+#define SO_LOCK_FILTER		44
+
+#define SO_SELECT_ERR_QUEUE	45
+
+#define SO_BUSY_POLL		46
+
+#define SO_MAX_PACING_RATE	47
+
+#define SO_BPF_EXTENSIONS	48
+
+#endif
+
+#if defined(__hppa__) || defined(__alpha__)
+#define SOCK_NONBLOCK 0x40000000
+#else
+#define SOCK_NONBLOCK O_NONBLOCK
 #endif
+#define SOCK_CLOEXEC O_CLOEXEC
 
 /* Socket types. */
 #ifdef __mips__
@@ -189,6 +338,7 @@
 #define SOCK_RAW	3		/* raw socket			*/
 #define SOCK_RDM	4		/* reliably-delivered message	*/
 #define SOCK_SEQPACKET	5		/* sequential packet socket	*/
+#define SOCK_DCCP	6		/* Datagram Congestion Control Protocol socket */
 #define SOCK_PACKET	10		/* linux specific way of	*/
 					/* getting packets at the dev	*/
 					/* level.  For writing rarp and	*/
@@ -324,6 +474,14 @@
 #define MSG_ERRQUEUE	0x2000	/* Fetch message from error queue */
 #define MSG_NOSIGNAL	0x4000	/* Do not generate SIGPIPE */
 #define MSG_MORE	0x8000	/* Sender will send more */
+#define MSG_WAITFORONE	0x10000	/* recvmmsg(): block until 1+ packets avail */
+#define MSG_SENDPAGE_NOTLAST 0x20000 /* sendpage() internal : not the last page */
+#define MSG_EOF         MSG_FIN
+
+#define MSG_FASTOPEN	0x20000000	/* Send data in TCP SYN */
+#define MSG_CMSG_CLOEXEC 0x40000000	/* Set close_on_exit for file
+					   descriptor received through
+					   SCM_RIGHTS */
 
 /* Setsockoptions(2) level. Thanks to BSD these must match IPPROTO_xxx */
 #define SOL_IP		0
@@ -381,16 +539,6 @@
   char __ss_padding[(128  - (2 * sizeof (uint32_t ))) ];
 };
 
-#ifndef SOCK_DGRAM
-/* the Linux kernel headers suck really badly on non-x86 */
-#define SOCK_STREAM	1		/* stream (connection) socket	*/
-#define SOCK_DGRAM	2		/* datagram (conn.less) socket	*/
-#define SOCK_RAW	3		/* raw socket			*/
-#define SOCK_RDM	4		/* reliably-delivered message	*/
-#define SOCK_SEQPACKET	5		/* sequential packet socket	*/
-#define SOCK_PACKET	10		/* linux specific way of	*/
-#endif
-
 int socket(int domain, int type, int protocol) __THROW;
 int accept(int s, struct sockaddr *addr, socklen_t *addrlen) __THROW;
 int connect(int sockfd, const struct sockaddr *serv_addr, socklen_t addrlen) __THROW;
@@ -415,7 +563,19 @@
 #define SHUT_RDWR 2
 int shutdown(int s, int how) __THROW;
 
-int socketpair(int d, int type, int protocol, int sv[2]);
+int socketpair(int d, int type, int protocol, int sv[2]) __THROW;
+
+#ifdef _GNU_SOURCE
+struct mmsghdr {
+   struct msghdr msg_hdr;  /* Message header */
+   unsigned int  msg_len;  /* Number of bytes transmitted */
+};
+
+int recvmmsg(int sockfd, struct mmsghdr *msgvec, unsigned int vlen,
+	     unsigned int flags, struct timespec *timeout) __THROW;
+int sendmmsg(int sockfd, struct mmsghdr *msgvec, unsigned int vlen,
+	     unsigned int flags);
+#endif
 
 /* currently not supported: */
 #define NI_NOFQDN 1
diff -urN -x .git dietlibc-0.33/include/sys/stat.h dietlibc/include/sys/stat.h
--- dietlibc-0.33/include/sys/stat.h	2012-11-02 11:17:28.000000000 +0000
+++ dietlibc/include/sys/stat.h	2015-01-01 12:14:43.478272229 +0000
@@ -8,6 +8,7 @@
 __BEGIN_DECLS
 
 #if defined(__i386__)
+
 struct stat {
 	uint32_t	st_dev;
 	unsigned long	st_ino;
@@ -489,7 +490,7 @@
 	unsigned long long st_ino;
 };
 
-#elif defined(__x86_64__)
+#elif defined(__x86_64__) && !defined(__ILP32__)
 
 struct stat {
 	unsigned long	st_dev;
@@ -512,6 +513,24 @@
 	long		__unused[3];
 };
 
+#elif defined(__x86_64__)
+
+/* for X32 */
+
+struct stat {
+	uint64_t	st_dev, st_ino, st_nlink;
+	uint32_t	st_mode, st_uid, st_gid, __pad0;
+	uint64_t	st_rdev;
+	int64_t		st_size, st_blksize, st_blocks;
+	time_t		st_atime;
+	uint64_t	st_atime_nsec;
+	time_t		st_mtime;
+	uint64_t	st_mtime_nsec;
+	time_t		st_ctime;
+	uint64_t	st_ctime_nsec;
+	unsigned int	__unused[3]
+};
+
 #elif defined(__ia64__)
 
 struct stat {
@@ -576,7 +595,7 @@
 extern int fstat(int __fd, struct stat *__buf) __THROW;
 extern int lstat(const char *__file, struct stat *__buf) __THROW;
 
-#if __WORDSIZE == 64
+#if (__WORDSIZE == 64) || defined(__OFF_T_MATCHES_OFF64_T)
 #define __NO_STAT64
 #else
 extern int stat64(const char *__file, struct stat64 *__buf) __THROW;
diff -urN -x .git dietlibc-0.33/include/sys/time.h dietlibc/include/sys/time.h
--- dietlibc-0.33/include/sys/time.h	2008-12-10 20:00:59.000000000 +0000
+++ dietlibc/include/sys/time.h	2015-01-01 12:14:43.481605561 +0000
@@ -73,10 +73,10 @@
 #define timeradd(a,b,x) do { (x)->tv_sec=(a)->tv_sec+(b)->tv_sec; if (((x)->tv_usec=(a)->tv_usec+(b)->tv_usec)>=1000000) { ++(x)->tv_sec; (x)->tv_usec-=1000000; } } while (0)
 #define timersub(a,b,x) do { (x)->tv_sec=(a)->tv_sec-(b)->tv_sec; if (((x)->tv_usec=(a)->tv_usec-(b)->tv_usec)<0) { --(x)->tv_sec; (x)->tv_usec+=1000000; } } while (0)
 #define timerisset(x) ((x)->tv_sec || (x)->tv_usec)
-
-int utimes(const char * filename, struct timeval * tvp);
 #endif
 
+int utimes(const char * filename, struct timeval * tvp) __THROW;
+
 __END_DECLS
 
 #endif
diff -urN -x .git dietlibc-0.33/include/sys/tls.h dietlibc/include/sys/tls.h
--- dietlibc-0.33/include/sys/tls.h	2010-09-25 17:03:26.000000000 +0000
+++ dietlibc/include/sys/tls.h	2015-01-01 12:14:43.481605561 +0000
@@ -9,8 +9,7 @@
 typedef union dtv
 {
   size_t counter;
-  struct
-  {
+  struct {
     void *val;
     bool is_static;
   } pointer;
@@ -18,19 +17,18 @@
 
 typedef struct
 {
-  void *tcb;            /* Pointer to the TCB.  Not necessary the
-                           thread descriptor used by libpthread.  */
-  dtv_t *dtv;
+  void *tcb;            /* Pointer to the TCB.  Accessed as GS:[0], points to itself. */
+  dtv_t *dtv;		/* Data structure used to find thread-local storage */
   void *self;           /* Pointer to the thread descriptor.  */
-  int multiple_threads;
+  int multiple_threads;	/* Set to 0 by _start/stackgap(), set to 1 by thrd_create */
 #ifdef __x86_64__
-  int gscope_flag;
+  int gscope_flag;	/* no idea what this is for */
 #endif
-  uintptr_t sysinfo;
-  uintptr_t stack_guard;
-  uintptr_t pointer_guard;
+  uintptr_t sysinfo;		/* not sure why this is here; passed via ELF auxvec, copied here by thrd_create */
+  uintptr_t stack_guard;	/* random value used as canary value by gcc -fstack-protector, initialized by _start/stackgap()/thrd_create */
+  uintptr_t pointer_guard;	/* random value used by glibc to xor internal pointers as exploit mitigation; not used in dietlibc */
 #ifdef __i386__
-  int gscope_flag;
+  int gscope_flag;	/* no idea what this is for */
 #endif
 } tcbhead_t;
 
@@ -61,6 +59,22 @@
 
 int arch_prctl(unsigned int what, void* where);
 
+#elif defined(__ia64__) || defined(__powerpc64__)
+
+#define __ABI_TLS_REGISTER	"r13"
+
+#elif defined(__powerpc__)
+
+#define __ABI_TLS_REGISTER	"r2"
+
+#elif defined(__sparc__)
+
+#define __ABI_TLS_REGISTER	"%g7"
+
+#elif defined(__arm__)
+
+void __arm_set_tls(void *);
+
 #else
 
 #warning "need proper sys/tls.h for this platform"
diff -urN -x .git dietlibc-0.33/include/sys/types.h dietlibc/include/sys/types.h
--- dietlibc-0.33/include/sys/types.h	2010-09-25 17:03:26.000000000 +0000
+++ dietlibc/include/sys/types.h	2015-01-01 12:14:43.481605561 +0000
@@ -84,7 +84,11 @@
 typedef int32_t pid_t;			/* Used for process IDs and process group IDs. */
 typedef signed long ssize_t;		/* Used for a count of bytes or an error indication. */
 typedef signed long suseconds_t;	/* Used for time in microseconds. */
+#if defined(__x86_64__) && defined(__ILP32__)
+typedef signed long long time_t;
+#else
 typedef signed long time_t;		/* Used for time in seconds. */
+#endif
 typedef signed long useconds_t;		/* Used for time in microseconds. */
 
 /* non-susv2 types: */
@@ -94,8 +98,13 @@
 #if defined _FILE_OFFSET_BITS && _FILE_OFFSET_BITS == 64
 typedef off64_t off_t;
 #else
+
+#if defined(__x86_64__) && defined(__ILP32__)
+typedef off64_t off_t;
+#else
 typedef signed long off_t;             /* Used for file sizes. */
 #endif
+#endif
 
 __extension__ typedef unsigned long long ino64_t;
 __extension__ typedef signed long long blkcnt64_t;
diff -urN -x .git dietlibc-0.33/include/sys/ucontext.h dietlibc/include/sys/ucontext.h
--- dietlibc-0.33/include/sys/ucontext.h	2005-03-11 17:18:15.000000000 +0000
+++ dietlibc/include/sys/ucontext.h	2015-01-01 12:14:43.481605561 +0000
@@ -10,13 +10,16 @@
 typedef struct sigcontext mcontext_t;
 #endif
 
-#if defined(__i386__) || defined(__arm__) || defined(__mips__) || defined(__mips64__) || defined(__powerpc__) || defined(__powerpc64__) || defined(__hppa__)
+#if defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__mips__) || defined(__mips64__) || defined(__powerpc__) || defined(__powerpc64__) || defined(__hppa__)
 struct ucontext {
   unsigned long		uc_flags;
   struct ucontext	*uc_link;
   stack_t		uc_stack;
   struct sigcontext	uc_mcontext;
   sigset_t		uc_sigmask;	/* mask last for extensibility */
+#if defined(__i386__) || defined(__x86_64__)
+  struct _fpstate	__fpregs_mem;
+#endif
 };
 #elif defined(__alpha__)
 struct ucontext {
@@ -105,15 +108,6 @@
 #define uc_link		uc_mcontext.sc_gr[0]	/* wrong type; nobody cares */
 #define uc_sigmask	uc_mcontext.sc_sigmask
 #define uc_stack	uc_mcontext.sc_stack
-#elif defined(__x86_64__)
-
-struct ucontext {
-	unsigned long	  uc_flags;
-	struct ucontext  *uc_link;
-	stack_t		  uc_stack;
-	struct sigcontext uc_mcontext;
-	sigset_t	  uc_sigmask;	/* mask last for extensibility */
-};
 
 #else
 #error NEED TO PORT <sys/sigcontext.h>!
diff -urN -x .git dietlibc-0.33/include/sys/uio.h dietlibc/include/sys/uio.h
--- dietlibc-0.33/include/sys/uio.h	2003-08-19 16:58:18.000000000 +0000
+++ dietlibc/include/sys/uio.h	2015-01-01 12:14:43.481605561 +0000
@@ -6,8 +6,11 @@
 __BEGIN_DECLS
 
 /* I have no idea why susv3 specifies count as int instead of size_t */
-ssize_t readv(int filedes, const struct iovec *vector, int count);
-ssize_t writev(int filedes, const struct iovec *vector, int count);
+ssize_t readv(int filedes, const struct iovec *vector, int count) __THROW;
+ssize_t writev(int filedes, const struct iovec *vector, int count) __THROW;
+
+ssize_t preadv(int fd, const struct iovec *iov, int iovcnt, off_t offset) __THROW;
+ssize_t pwritev(int fd, const struct iovec *iov, int iovcnt, off_t offset) __THROW;
 
 __END_DECLS
 
diff -urN -x .git dietlibc-0.33/include/sys/wait.h dietlibc/include/sys/wait.h
--- dietlibc-0.33/include/sys/wait.h	2006-05-29 16:30:53.000000000 +0000
+++ dietlibc/include/sys/wait.h	2015-01-01 12:14:43.481605561 +0000
@@ -41,12 +41,12 @@
 #define W_STOPCODE(sig) ((sig) << 8 | 0x7f)
 #endif
 
-pid_t wait(int *status) __THROW;
-pid_t waitpid(pid_t pid, int *status, int options) __THROW;
+pid_t wait(int *status);
+pid_t waitpid(pid_t pid, int *status, int options);
 
-pid_t wait3(int *status, int options, struct rusage *rusage) __THROW;
+pid_t wait3(int *status, int options, struct rusage *rusage) __THROWNL;
 
-pid_t wait4(pid_t pid, int *status, int options, struct rusage *rusage) __THROW;
+pid_t wait4(pid_t pid, int *status, int options, struct rusage *rusage) __THROWNL;
 
 typedef enum {
   P_ALL,		/* Wait for any child.  */
diff -urN -x .git dietlibc-0.33/include/threads.h dietlibc/include/threads.h
--- dietlibc-0.33/include/threads.h	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/include/threads.h	2015-01-01 12:14:43.481605561 +0000
@@ -0,0 +1,95 @@
+#ifndef THREAD_H
+#define THREAD_H
+
+#include <sys/types.h>
+#include <sys/time.h>
+
+typedef struct __thrd_t {
+  char* memstart;	// points to beginning of guard page
+  size_t memsize;	// this includes the guard page, the stack, the thread local storage but not tcb and thrd_t data
+  pid_t tid;
+  /* the thread function and the argument it was called with */
+  int (*func)(void*);
+  void* arg;
+  /* the return value of the function, so it can be read with pthread_join */
+  int res;
+  /* 1: the thread was detached
+   * 2: the thread already exited, stack and thread local data freed
+   * 4: being torn down (calls to thrd_detach and thrd_join fail) */
+  int flags;
+  int join_futex,join_wait_futex;
+}* thrd_t;
+
+enum {
+  thrd_success = 0,
+  thrd_timedout,
+  thrd_busy,
+  thrd_nomem,
+  thrd_error
+};
+
+typedef int (*thrd_start_t)(void* arg);
+
+int thrd_create(thrd_t *thr, thrd_start_t func, void *arg);
+thrd_t thrd_current(void);
+int thrd_detach(thrd_t thr);
+int thrd_equal(thrd_t thr0, thrd_t thr1);
+void thrd_exit(int res);
+int thrd_join(thrd_t thr, int* res);
+int thrd_sleep(const struct timespec* time_point, struct timespec* remaining);
+void thrd_yield(void);
+
+typedef struct __mtx_t {
+  int lock, type;
+  thrd_t owner;
+} mtx_t;
+
+enum {
+  mtx_plain = 0,
+  mtx_timed = 1,
+  mtx_recursive = 2
+};
+
+int mtx_init(mtx_t* mutex, int type);
+int mtx_lock(mtx_t* mutex);
+int mtx_timedlock(mtx_t *restrict mutex, const struct timespec *restrict time_point);
+int mtx_trylock(mtx_t* mutex);
+int mtx_unlock(mtx_t* mutex);
+void mtx_destroy(mtx_t* mutex);
+
+#ifdef _DIETLIBC_SOURCE
+int __mtx_trylock(mtx_t* mutex,int* lockval);
+#endif
+
+typedef int once_flag;
+#define ONCE_FLAG_INIT 0
+
+void call_once(once_flag* flag, void (*func)(void));
+
+typedef struct __cnd_t {
+  int sem;
+} cnd_t;
+
+int cnd_init(cnd_t* cond);
+int cnd_signal(cnd_t *cond);
+int cnd_broadcast(cnd_t *cond);
+int cnd_wait(cnd_t* cond, mtx_t* mutex);
+int cnd_timedwait(cnd_t* restrict cond, mtx_t* restrict mutex, const struct timespec* restrict time_point);
+void cnd_destroy(cnd_t* cond);
+
+#define thread_local __thread
+
+typedef void (*tss_dtor_t)(void*);
+typedef struct __tss_t {
+  void* data;
+  tss_dtor_t dtor;
+  struct __tss_t* next;
+}* tss_t;
+
+#define TSS_DTOR_ITERATIONS 1
+int tss_create(tss_t* tss_id, tss_dtor_t destructor);
+void *tss_get(tss_t tss_id);
+int tss_set(tss_t tss_id, void *val);
+void tss_delete(tss_t tss_id);
+
+#endif
diff -urN -x .git dietlibc-0.33/include/ucontext.h dietlibc/include/ucontext.h
--- dietlibc-0.33/include/ucontext.h	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/include/ucontext.h	2015-01-01 12:14:43.481605561 +0000
@@ -0,0 +1,17 @@
+#ifndef _UCONTEXT_H
+#define _UCONTEXT_H
+
+#include <sys/ucontext.h>
+
+__BEGIN_DECLS
+
+extern int getcontext (ucontext_t *c) __THROW;
+extern int setcontext (const ucontext_t *c) __THROW;
+extern int swapcontext (ucontext_t *__restrict o,
+			const ucontext_t *__restrict n) __THROWNL;
+extern void makecontext (ucontext_t *c, void (*__func) (void),
+			 int argc, ...) __THROW;
+
+__END_DECLS
+
+#endif
diff -urN -x .git dietlibc-0.33/include/unistd.h dietlibc/include/unistd.h
--- dietlibc-0.33/include/unistd.h	2012-11-02 11:17:28.000000000 +0000
+++ dietlibc/include/unistd.h	2015-01-01 12:14:43.481605561 +0000
@@ -34,11 +34,13 @@
 #define STDERR_FILENO  2
 
 off_t lseek(int fildes, off_t offset, int whence) __THROW;
-#if __WORDSIZE == 32
+#if !defined(__OFF_T_MATCHES_OFF64_T)
 loff_t lseek64(int fildes, loff_t offset, int whence) __THROW;
 #if defined _FILE_OFFSET_BITS && _FILE_OFFSET_BITS == 64
 #define lseek(fildes,offset,whence) lseek64(fildes,offset,whence)
 #endif
+#else
+#define lseek64(fildes,offset,whence) lseek(fildes,offset,whence)
 #endif
 
 int chdir(const char *path) __THROW;
@@ -48,6 +50,8 @@
 
 #ifdef _GNU_SOURCE
 char *get_current_dir_name (void) __THROW __attribute_dontuse__;
+
+int pipe2(int pipefd[2], int flags) __THROW;
 #endif
 
 int open(const char* pathname,int flags, ...) __THROW;
@@ -84,11 +88,22 @@
 pid_t setsid (void) __THROW;
 int dup (int oldfd) __THROW;
 int dup2 (int oldfd,int newfd) __THROW;
+#ifdef _GNU_SOURCE
+int dup3(int oldfd, int newfd, int flags) __THROW;
+
+/* flags for memfd_create(2) (unsigned int) */
+#define MFD_CLOEXEC		0x0001U
+#define MFD_ALLOW_SEALING	0x0002U
+
+int memfd_create(const char* name, unsigned int flags) __THROW;
 
-struct dirent;
-struct dirent64;
-int getdents(int fd, struct dirent *dirp, unsigned int count) __THROW;
-int getdents64(int fd, struct dirent64 *dirp, unsigned int count) __THROW;
+int syncfs(int fd) __THROW;
+#endif
+
+struct linux_dirent;
+struct linux_dirent64;
+int getdents(int fd, struct linux_dirent *dirp, unsigned int count) __THROW;
+int getdents64(int fd, struct linux_dirent64 *dirp, unsigned int count) __THROW;
 
 pid_t fork(void) __THROW;
 pid_t vfork(void) __THROW;
@@ -187,6 +202,8 @@
 #define _SC_NPROCESSORS_ONLN 6
 #define _SC_NPROCESSORS_CONF _SC_NPROCESSORS_ONLN
 #define _SC_PHYS_PAGES 7
+#define _SC_GETPW_R_SIZE_MAX 8
+#define _SC_GETGR_R_SIZE_MAX 9
 long sysconf(int name) __THROW;
 #define _PC_PATH_MAX 1
 #define _PC_VDISABLE 2
@@ -258,7 +275,7 @@
 #endif
 #endif
 
-#ifdef _LINUX_SOURCE
+#if defined(_LINUX_SOURCE) || defined(_GNU_SOURCE)
 int pivot_root(const char *new_root, const char *put_old) __THROW;
 /* Linux 2.6 module loading infrastructure:
  * init_module takes a buffer where you read the module file into */
@@ -270,8 +287,19 @@
 int tkill(pid_t tid, int sig) __THROW;
 int tgkill(pid_t tgid, pid_t tid, int sig) __THROW;
 /* see linux/fadvise.h */
-long fadvise64(int fd,off64_t offset,size_t len,int advice);
-long fadvise64_64(int fd,off64_t offset,off64_t len,int advice);
+long fadvise64(int fd,off64_t offset,size_t len,int advice) __THROW;
+long fadvise64_64(int fd,off64_t offset,off64_t len,int advice) __THROW;
+
+#ifndef GRND_NONBLOCK
+enum {
+  GRND_NONBLOCK=1,
+#define GRND_NONBLOCK GRND_NONBLOCK
+  GRND_RANDOM=2
+#define GRND_RANDOM GRND_RANDOM
+};
+
+int getrandom(void* buf, size_t buflen, unsigned int flags) __THROW;
+#endif
 #endif
 
 #if defined(_ATFILE_SOURCE) || ((_XOPEN_SOURCE + 0) >= 700) || ((_POSIX_C_SOURCE + 0) >= 200809L)
diff -urN -x .git dietlibc-0.33/include/wchar.h dietlibc/include/wchar.h
--- dietlibc-0.33/include/wchar.h	2010-09-25 17:03:26.000000000 +0000
+++ dietlibc/include/wchar.h	2015-01-01 12:14:43.481605561 +0000
@@ -13,7 +13,7 @@
 #else
 typedef unsigned int wint_t;
 #endif
-typedef int (*wctype_t)(wint_t) __THROW __attribute__((__const__));
+typedef int (*wctype_t)(wint_t) __attribute__((__const__)) __THROW;
 
 #ifndef WCHAR_MIN
 #define WCHAR_MIN (-2147483647 - 1)
diff -urN -x .git dietlibc-0.33/ldso.c dietlibc/ldso.c
--- dietlibc-0.33/ldso.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/ldso.c	2015-01-01 12:14:43.481605561 +0000
@@ -0,0 +1,803 @@
+#define errno fnord
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/mman.h>
+#include <elf.h>
+#include <stdlib.h>
+#include <stdint.h>
+#undef errno
+
+#if (__WORDSIZE == 64)
+
+#define phdr Elf64_Phdr
+#define ehdr Elf64_Ehdr
+#define shdr Elf64_Shdr
+#define sym Elf64_Sym
+#define dyn Elf64_Dyn
+#define rela Elf64_Rela
+#define R_SYM ELF64_R_SYM
+#define R_TYPE ELF64_R_TYPE
+
+#else
+
+#define phdr Elf32_Phdr
+#define ehdr Elf32_Ehdr
+#define shdr Elf32_Shdr
+#define sym Elf32_Sym
+#define dyn Elf32_Dyn
+#define rela Elf32_Rela
+#define R_SYM ELF32_R_SYM
+#define R_TYPE ELF32_R_TYPE
+
+#endif
+
+static int errno;
+__attribute__((visibility("hidden"))) int* __errno_location(void) { return &errno; }
+
+static size_t _strlen(const char* s) {
+  size_t i;
+  for (i=0; s[i]; ++i);
+  return i;
+}
+static char* _stpcpy(char* dest,const char* src) {
+  size_t i;
+  for (i=0; src[i]; ++i)
+    dest[i]=src[i];
+  dest[i]=0;
+  return dest+i;
+}
+static char* _strchr(char* s,char c) {
+  size_t i;
+  for (i=0; s[i] && s[i]!=c; ++i) ;
+  if (s[i]==c) return s+i; else return NULL;
+}
+static int _strcmp(const void* str1,const void* str2) {
+  const unsigned char* a=str1;
+  const unsigned char* b=str2;
+  size_t i;
+  int r;
+  for (i=0; (r=(a[i]-b[i]))==0 && a[i]; ++i) ;
+  return r;
+}
+static int _memcmp(const void* dst,const void* src,size_t count) {
+  const unsigned char* a=dst;
+  const unsigned char* b=src;
+  size_t i;
+  int r;
+  for (i=0; i<count && (r=(a[i]-b[i]))==0; ++i) ;
+  return r;
+}
+static void* _memcpy(void* dst,const void* src,size_t len) {
+  char* a=dst;
+  const char* b=src;
+  size_t i;
+  for (i=0; i<len; ++i)
+    a[i]=b[i];
+  return dst;
+}
+static void _memset(void* dst,unsigned char c,size_t len) {
+  unsigned char* a=dst;
+  size_t i;
+  for (i=0; i<len; ++i) a[i]=c;
+}
+static ssize_t __write1(const char* s) {
+  write(1,s,_strlen(s));
+}
+static ssize_t __write2(const char* s) {
+  write(2,s,_strlen(s));
+}
+
+ssize_t write(int fd,const void* buf,size_t len) __attribute__((visibility("hidden")));
+int open(const char* pathname,int flags, ...) __attribute__((visibility("hidden")));
+ssize_t read(int fd,void* buf,size_t len) __attribute__((visibility("hidden")));
+int close(int fd) __attribute__((visibility("hidden")));
+ssize_t pread64(int fd, void *buf, size_t count, off64_t offset) __attribute__((visibility("hidden")));;
+void *mmap(void *__addr, size_t __len, int __prot, int __flags, int __fd, off_t __offset) __attribute__((visibility("hidden")));
+int munmap(void *__addr, size_t __len) __attribute__((visibility("hidden")));
+int mprotect (void *__addr, size_t __len, int __prot) __attribute__((visibility("hidden")));
+void exit(int res) __attribute__((visibility("hidden")));
+
+static struct page {
+  struct page* next;
+  size_t a;
+  char data[4096-sizeof(size_t)-sizeof(struct page*)];
+}* heap;
+
+static void* _malloc(size_t l) {
+  struct page** p;
+  if (l>sizeof(heap->data)) return 0;
+  if (l%(sizeof(void*)*2)) {
+    l += sizeof(void*)*2;
+    l -= l%(sizeof(void*)*2);
+  }
+  for (p=&heap; *p && (*p)->a<l; p=&((*p)->next)) ;
+  if (!*p) {
+    void* tmp=mmap(0,4096,PROT_READ|PROT_WRITE,MAP_ANONYMOUS|MAP_PRIVATE,-1,0);
+    if (tmp==MAP_FAILED) return 0;
+    *p=tmp;
+    (*p)->a=sizeof(heap->data);
+  }
+  if (l <= (*p)->a) {
+    char* tmp=(*p)->data+sizeof((*p)->data)-(*p)->a;
+    (*p)->a-=l;
+    return tmp;
+  } else
+    return 0;	// can't happen
+}
+
+static char path[100];
+static char* ldlp;
+
+static struct dll {
+  struct dll* next;
+  ehdr* e;
+  void* code,* data;
+  size_t codelen,datalen,codeplus;
+  char name[1];		// asciiz of library name
+} *dlls, dllroot;
+
+static int map_sections(int fd,const ehdr* e,const phdr* p,struct dll* D) {
+  size_t i;
+  uintptr_t codeplus=0;
+
+  for (i=0; i<e->e_phnum; ++i) {
+    if (p[i].p_type==PT_LOAD) {
+      size_t delta=p[i].p_offset%4096;
+      size_t maplen=p[i].p_filesz+delta;
+      size_t bssdiff=(p[i].p_filesz+delta)%4096;
+      char* c;
+      if ((p[i].p_flags&PF_W) && (p[i].p_flags&PF_X)) {
+	__write2("section is both executable and writable, aborting!\n");
+	return 1;
+      }
+      if (!(p[i].p_flags&PF_W)) {
+	/* code segment */
+	size_t ofs,len,rolen=0,nolen=0,rolen2=0,vaddr=p[i].p_vaddr,baseofs=0;
+	/* the first segment will be the code segment, and it will have
+	 * either a fixed address or 0 if it's a shared library. We
+	 * insist that the mapping start at file offset 0, and we extend
+	 * the mapping so it includes the section table */
+	ofs=p[i].p_offset;
+	len=p[i].p_filesz;
+	if (ofs) {
+	  __write2("can't happen error: ofs!=0\n");
+	  exit(1);
+	  if (vaddr)
+	    vaddr-=ofs;
+	  else
+	    baseofs=ofs;
+	  rolen=ofs;
+	  len+=ofs;
+	  ofs=0;
+	}
+	if (ofs+len < e->e_shoff+e->e_shnum*e->e_shentsize) {
+	  size_t needed=e->e_shoff+e->e_shnum*e->e_shentsize;
+	  /* if this mapping does not include the section table is not
+	   * included, extend the mapping to include it */
+	  rolen2=e->e_shnum*e->e_shentsize;
+	  if (rolen2>needed-len)
+	    /* we were almost there, part of the section table was
+	     * already mapped */
+	    rolen2=needed-len;
+	  else
+	    nolen=needed-len-rolen2;
+	  /*
+	   * +------------------------+
+	   * | rolen       e->        | if the mapping did not start at beginning of file, this is the beginning of file, PROT_READ
+	   * +------------------------+
+	   * | len         base->     | this is the actual mapping, base points here, PROT_READ|PROT_EXEC
+	   * +------------------------+
+	   * | nolen                  | stuff we don't really need and will mprotect PROT_NONE
+	   * +------------------------+
+	   * | rolen2      e+e->shoff | the section header table, PROT_READ
+	   * +------------------------+
+	   */
+	}
+	c=mmap((char*)vaddr,rolen+len+nolen+rolen2,
+		  ((p[i].p_flags&PF_R)?PROT_READ:0) |
+		  ((p[i].p_flags&PF_X)?PROT_EXEC:0),
+		  MAP_SHARED|(vaddr?MAP_FIXED:0),
+		  fd,0);
+	/* in case the can't happen branch ever happens */
+	D->e=(ehdr*)c;
+	D->code=c+rolen; D->codelen=len;
+//	D->s=(shdr*)(c+e->e_shoff);
+	if (rolen>=4096)	/* if we extended the mapping in the front, remove exec permissions */
+	  mprotect(c,rolen&~4095,PROT_READ);
+	if (!vaddr && !codeplus) codeplus=(uintptr_t)(c+rolen);
+	if (nolen) {
+	  /* We mapped junk in the middle.
+	   * If there are full pages in there, map them PROT_NONE */
+	  char* start=c+rolen+len;
+	  size_t len=nolen;
+	  size_t diff=(-(uintptr_t)start & 4095);
+	  if (diff < nolen) {
+	    /* diff is the part at the beginning we need to skip because
+	     * it's on a page we actually need to be executable.
+	     * Now find out if we overshoot onto a page we want */
+	    size_t removeatend=((uintptr_t)c+rolen+len)&4095;
+	    mprotect(start+diff,len-diff-removeatend,PROT_NONE);
+	  }
+	}
+	if (rolen2) {
+	  /* Now we want to mprotect PROT_READ the section table.
+	   * What makes this complex is that mprotect granularity is one
+	   * page.  First figure out the region we are interested in. */
+	  char* start=c+rolen+len+nolen;
+	  size_t len=rolen2;
+	  /* we want to mprotect from start to start+len */
+	  int diff=((uintptr_t)start)&4095;
+	  /* This is the offset of start from the page start.  We need
+	   * to mprotect the whole page -- unless it also has code on
+	   * it, in which case we need to leave it alone */
+	  if (diff > nolen) {
+	    size_t roundup=(-(uintptr_t)start)&4095;
+	    /* we need to skip the first page. Let's see if there is
+	     * anything left in that case */
+	    start+=roundup;
+	    if (rolen2>roundup)
+	      len-=roundup;
+	    else
+	      len=0;
+	  } else {
+	    start-=diff;
+	    len+=diff;
+	  }
+	  if (len) mprotect(start,len,PROT_READ);
+	}
+      } else if (p[i].p_flags&PF_W) {	/* data segment */
+	/* We have already mapped the code segment to base.
+	 * For programs, the base mapping of the code and data segment
+	 * is absolute and we just map there with MAP_FIXED.  For shared
+	 * libraries however, the base mapping of the code segment is 0,
+	 * and the vaddr of the data segment is not absolute but
+	 * relative to the code segment */
+
+	/* The data segment may not start on a page boundary.  Round
+	 * start address if necessary. */
+	size_t addr,ofs,len,memsetstart=0,memsetend=0,additional=0;
+	addr=p[i].p_vaddr+codeplus;
+	ofs=p[i].p_offset;
+	len=p[i].p_filesz;
+	if ((memsetstart=(ofs%4096))) {
+	  len+=memsetstart;
+	  ofs-=memsetstart;
+	  addr-=memsetstart;
+	}
+
+	/* The data segment consists of actual data, but a part of it is
+	 * data initialized to 0, the .bss section.  This section is not
+	 * actually put in the file to save space, but the ELF loader
+	 * (that's us) is expected to allocate that data at program
+	 * start. */
+	memsetend=p[i].p_memsz-p[i].p_filesz;
+	if (memsetend) {
+	  /* We have a .bss.  We need to handle two cases.  First: if
+	   * the number of bytes is small enough to fit on the last page
+	   * we already mapped for the data, all we need to do is memset
+	   * it.  Otherwise we needto memset the rest of that page and
+	   * map some additional pages after it. */
+	  size_t bytes_on_last_page=(-len)&4095;
+	  if (memsetend<bytes_on_last_page)
+	    len+=memsetend;
+	  else {
+	    len+=bytes_on_last_page;
+	    additional=memsetend-bytes_on_last_page;
+	    memsetend=bytes_on_last_page;
+	  }
+	}
+
+	c=mmap((char*)addr,len,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_FIXED,fd,ofs);
+	if (c==MAP_FAILED) {
+	  __write2("mmap failed!\n");
+	  return 1;
+	}
+
+	if (memsetstart) _memset(c,0,memsetstart);
+	if (memsetend) _memset(c+len-memsetend,0,memsetend);
+	if (additional) {
+	  char* tmp=mmap(c+len,additional,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,-1,0);
+	  if (tmp==MAP_FAILED) {
+	    __write2("mmap failed!\n");
+	    return 1;
+	  }
+	}
+	D->data=c+memsetstart; D->datalen=len-memsetstart;
+	D->codeplus=codeplus;
+      } else {
+	__write2("can't happen error: LOAD segment that is neither code nor data.\n");
+	return 1;
+      }
+    }
+  }
+  return 0;
+}
+
+
+static int __loadlibrary(const char* fn) {
+  struct dll* D;
+  int fd;
+  char buf[1000];
+  ehdr* e;
+  phdr* p;
+  shdr* s;
+  size_t i;
+  char* code=0,* data=0;
+  char* base=0;
+  size_t codelen,datalen;
+#if 0
+  __write1("trying ");
+  __write1(fn);
+  __write1("\n");
+#endif
+  fd=open(fn,O_RDONLY);
+  if (fd==-1) return -1;
+  if (read(fd,buf,1000)<1000) {
+kaputt:
+    close(fd);
+    return -1;
+  }
+  if (_memcmp(buf,"\177ELF",4)) goto kaputt;
+  e=(ehdr*)buf;
+
+  if (e->e_ident[4] != (sizeof(size_t)/4) ||	// wrong word size
+      e->e_type != ET_DYN ||			// not shared object
+      e->e_machine != 				// for different architecture
+#if defined(__x86_64__)
+	EM_X86_64
+#elif defined(__i386__)
+	EM_386
+#else
+#error architecture not recognized, please add
+#endif
+                                ||
+      e->e_phentsize != sizeof(phdr) ||		// wrong program header entry size
+      e->e_phnum > 20 ||			// too many program header entries
+      e->e_shentsize !=sizeof(shdr) ||		// wrong section header entry size
+      e->e_shnum > 100)				// too many sections
+    goto kaputt;
+
+
+  if (e->e_phoff>=1000 || e->e_phentsize*e->e_phnum>1000-e->e_phoff) {
+    size_t wanted=e->e_phentsize*e->e_phnum;
+    p=alloca(wanted);
+    if (pread64(fd,p,wanted,e->e_phoff)!=wanted)
+      goto kaputt;
+  } else
+    p=(phdr*)(buf+e->e_phoff);
+
+  struct dll dll;
+  if (map_sections(fd,e,p,&dll)) {
+    __write2("map_sections failed\n");
+    goto kaputt;
+  }
+
+  close(fd);
+
+  {
+    const char* tmp;
+    for (i=0; fn[i]; ++i)
+      if (fn[i]=='/') tmp=fn+i;
+    ++tmp;
+    D=_malloc(sizeof(struct dll)+_strlen(tmp));
+    _stpcpy(D->name,tmp);
+  }
+  D->next=0;
+  D->code=dll.code; D->codelen=dll.codelen;
+  D->data=dll.data; D->datalen=dll.datalen;
+//  D->s=dll.s;
+  D->e=dll.e;
+  D->codeplus=dll.codeplus;
+  {
+    struct dll** x;
+    for (x=&dlls; *x; x=&(*x)->next) ;
+    *x=D;
+  }
+  return 0;
+}
+
+static int loadlibrary(const char* fn) {
+  char lp[200];
+  int r;
+  char* c;
+  const char* shortname=fn;
+  struct dll* d;
+
+  {
+    size_t i;
+    for (i=0; fn[i]; ++i)
+      if (fn[i]=='/') shortname=fn+i+1;
+  }
+
+  if (_strlen(fn)>50) return -1;
+  for (d=dlls; d; d=d->next)
+    if (!_strcmp(d->name,shortname))
+      return 0;
+
+  __write1("loadlibrary(\"");
+  __write1(fn);
+  __write1("\")\n");
+  if (fn[0]=='/') {
+    return __loadlibrary(fn);
+  }
+
+  c=_stpcpy(lp,path);
+  *c++='/';
+  _stpcpy(c,fn);
+  r=__loadlibrary(lp);
+  if (r==0) return r;
+  if (ldlp) {
+    size_t i;
+    char* d;
+    c=ldlp;
+    for (i=0; ; ++i) {
+again:
+      if (c[i]==':' || c[i]==0) {
+	if (i<100) {
+	  lp[i]='/';
+	  _stpcpy(lp+i+1,fn);
+	  r=__loadlibrary(lp);
+	  if (r==0) return;
+	}
+	if (c[i]==0) break;
+	c+=i+1; i=0; goto again;
+      } else
+	if (i<100) lp[i]=c[i];
+    }
+  }
+  return r;
+}
+
+static int loadlibs(struct dll* D) {
+  size_t i;
+  phdr* p=(phdr*)((char*)D->e+D->e->e_phoff);
+  dyn* d;
+  size_t dnum,dynstrlen;
+  char* dynstr;
+
+  /* we know we have exactly one code and exactly one data segment,
+   * otherwise we wouldn't have gotten this far */
+  for (i=0; i<D->e->e_phnum; ++i)
+    if (p[i].p_type==PT_DYNAMIC) {
+      d=(dyn*)((char*)p[i].p_vaddr+D->codeplus);
+      dnum=p[i].p_memsz/sizeof(dyn);
+      break;
+    }
+  for (i=0; i<dnum; ++i)
+    if (d[i].d_tag==DT_STRTAB) {
+      dynstr=(char*)d[i].d_un.d_ptr+D->codeplus;
+      break;
+    } else if (d[i].d_tag==DT_NULL)
+      break;
+
+  /* we now have a dynamic section we can traverse */
+  for (i=0; i<dnum; ++i) {
+    if (d[i].d_tag==DT_NEEDED) {
+      if (loadlibrary(dynstr+d[i].d_un.d_val)) {
+	__write2("library ");
+	__write2(dynstr+d[i].d_un.d_val);
+	__write2(" not found!\n");
+	exit(2);
+      }
+    } else if (d[i].d_tag==DT_NULL)
+      break;
+  }
+
+  return 0;
+}
+
+static unsigned int elf_hash(const unsigned char *name) {
+  unsigned int h=0, g;
+
+  while (*name) {
+    h = (h<<4) + *(name++);
+    if ((g = h&0xf0000000)) h ^= g>>24;
+    h ^= g;
+  }
+  return h;
+}
+
+static uint_fast32_t gnu_hash(const unsigned char *s) {
+  unsigned char c;
+  uint_fast32_t h=5381;
+  for(c=*s;(c!='\0');c=*++s) {
+//    h=h*33+c;
+    h=((h<<5)+h)+c;
+  }
+  return (h&0xffffffff);
+}
+
+static char* dlsym_int(const char* symbol,struct dll* x) {
+  for (; x; x=x->next) {
+    size_t i;
+    dyn* d;
+    sym* sy;
+    phdr* p=(phdr*)(x->e->e_phoff+(char*)x->e);
+    const char* strtab;
+    size_t dnum;
+    int* hash=0;
+    for (i=0; i<x->e->e_phnum; ++i)
+      if (p[i].p_type==PT_DYNAMIC) {
+	d=(dyn*)(x->codeplus + p[i].p_vaddr);
+	dnum=p[i].p_memsz/sizeof(dyn);
+	break;
+      }
+
+    for (i=0; i<dnum; ++i) {
+      if (d[i].d_tag == DT_HASH)
+	hash=(int*)((char*)x->codeplus + d[i].d_un.d_ptr);
+      else if (d[i].d_tag == DT_SYMTAB)
+	sy=(sym*)((char*)(x->codeplus+d[i].d_un.d_ptr));
+      else if (d[i].d_tag == DT_STRTAB)
+	strtab=(char*)(x->codeplus+d[i].d_un.d_ptr);
+    }
+
+    /* hash[0] is the number of buckets. */
+    /* hash[1] is the hash chain length, not used here */
+    size_t bhash=elf_hash(symbol)%hash[0];
+    unsigned int* chain=hash+2+hash[0];
+    unsigned int index;
+    for (index=(hash+2)[bhash]; index; index=chain[index]) {
+#if 0
+      __write1(strtab+sy[index].st_name); __write1("\n");
+#endif
+      if (sy[index].st_value && sy[index].st_shndx!=SHN_UNDEF && !_strcmp(strtab+sy[index].st_name,symbol)) {
+	return (char*)x->codeplus+sy[index].st_value;
+      }
+    }
+#if 0
+    if (x->next) {
+      __write1(" ... next: ");
+      __write1(x->next->name);
+      __write1("\n");
+    }
+#endif
+  }
+  return 0;
+}
+
+static void* dlsym(const char* s) {
+  return dlsym_int(s,&dllroot);
+}
+
+static void* _dlsym(const char* s) {
+  void* x=dlsym(s);
+  if (!x) {
+    __write2("ld.so: lookup of symbol \"");
+    __write2(s);
+    __write2("\" failed.\n");
+//    exit(1);
+  }
+  return x;
+}
+
+static void resolve(struct dll* D) {
+  size_t i;
+  phdr* p=(phdr*)((char*)D->e+D->e->e_phoff);
+  dyn* d=0;
+  size_t dnum,dynstrlen,rnum=0;
+  char* dynstr=0, *pltgot=0, *pltrel=0;
+  rela* r=0;
+  sym* symtab=0;
+
+  /* we know we have exactly one code and exactly one data segment,
+   * otherwise we wouldn't have gotten this far */
+  for (i=0; i<D->e->e_phnum; ++i)
+    if (p[i].p_type==PT_DYNAMIC) {
+      d=(dyn*)((char*)p[i].p_vaddr+D->codeplus);
+      dnum=p[i].p_memsz/sizeof(dyn);
+      break;
+    }
+  for (i=0; i<dnum; ++i)
+    if (d[i].d_tag==DT_STRTAB)
+      dynstr=(char*)d[i].d_un.d_ptr+D->codeplus;
+    else if (d[i].d_tag==DT_RELA)
+      r=(rela*)((char*)d[i].d_un.d_ptr+D->codeplus);
+    else if (d[i].d_tag==DT_RELASZ)
+      rnum=d[i].d_un.d_val/sizeof(rela);
+    else if (d[i].d_tag==DT_SYMTAB)
+      symtab=(sym*)((char*)d[i].d_un.d_ptr+D->codeplus);
+    else if (d[i].d_tag==0)
+      break;
+
+  for (i=0; i<rnum; ++i) {
+    size_t* x=(size_t*)((char*)(r[i].r_offset+D->codeplus));
+    char* y;
+    size_t sym=R_SYM(r[i].r_info);
+    switch (R_TYPE(r[i].r_info)) {
+#if defined(__x86_64__)
+    case R_X86_64_64:
+      *x=D->codeplus+symtab[sym].st_value;
+      break;
+    case R_X86_64_COPY:
+      y=dlsym_int(symtab[sym].st_name+dynstr,D->next);
+      if (!y && ELF32_ST_BIND(symtab[sym].st_info) != STB_WEAK) {
+	__write2("symbol lookup failed: ");
+	__write2(dynstr+symtab[sym].st_name);
+	__write2("\n");
+	exit(1);
+      }
+      _memcpy(x,y,symtab[sym].st_size);
+      break;
+    case R_X86_64_GLOB_DAT:
+    case R_X86_64_JUMP_SLOT:
+      y=dlsym(symtab[sym].st_name+dynstr);
+      if (!y && ELF32_ST_BIND(symtab[sym].st_info) != STB_WEAK) {
+	__write2("symbol lookup failed: ");
+	__write2(dynstr+symtab[sym].st_name);
+	__write2("\n");
+	exit(1);
+      }
+      *x=(uintptr_t)y;
+      break;
+    case R_X86_64_RELATIVE:
+      *x=r[i].r_addend+D->codeplus;
+      break;
+    case R_X86_64_32:
+      *(uint32_t*)x=*(uint32_t*)_dlsym(symtab[sym].st_name+dynstr)+r[i].r_addend;
+      break;
+    default:
+      __write2("unknown relocation type!\n");
+      exit(1);
+      break;
+#else
+#error fixme: add relocation types for your platform
+#endif
+    }
+  }
+
+  return;
+}
+
+int main(int argc,char* argv[],char* envp[]) {
+  int fd;
+  size_t l;
+  char* m;
+  char buf[1000];
+  ehdr* e;
+  phdr* p;
+  phdr* code=0,* data=0;
+  shdr* s;
+  dyn* d;
+  size_t dnum;
+  char* dynstr;
+  size_t dynstrlen;
+  size_t i;
+
+#if 0
+  {
+    fd=open("/proc/self/maps",O_RDONLY);
+    if (fd!=-1) {
+      size_t l;
+      do {
+	l=read(fd,buf,sizeof(buf));
+	write(1,buf,l);
+      } while (l==sizeof(buf));
+      close(fd);
+    }
+  }
+#endif
+  if (argc<2) {
+    __write2("usage: ld.so /path/to/binary\n");
+    return 0;
+  }
+  fd=open("/etc/diet.ld.conf",O_RDONLY);
+  if (fd!=-1) {
+    int r=read(fd,path,99);
+    if (r>0) path[r]=0;
+    while (r>0 && path[r-1]=='\n') path[--r]=0;
+    close(fd);
+  }
+  for (i=0; envp[i]; ++i) {
+    if (_memcmp(envp[i],"LD_LIBRARY_PATH=",16)==0)
+      ldlp=envp[i]+16;
+  }
+  fd=open(argv[1],O_RDONLY);
+  if (fd==-1) {
+    __write2("could not open \"");
+    __write2(argv[1]);
+    __write2("\".\n");
+    return 1;
+  }
+  l=read(fd,buf,1000);
+  if (l<sizeof(ehdr) || _memcmp(buf,"\177ELF",4)) {
+kaputt:
+    __write2("invalid ELF file \"");
+    close(fd);
+    return 1;
+  }
+  e=(ehdr*)buf;
+
+  if (e->e_ident[4] != (sizeof(size_t)/4)) {
+    __write2("wrong word size!\n");
+    return 1;
+  }
+#if 0
+  if (e->e_ident[7] != ELFOSABI_LINUX) {
+    __write2("ABI not Linux!\n");
+    return 1;
+  }
+#endif
+  if (e->e_type != ET_EXEC) {
+    __write2("not an executable!\n");
+    return 1;
+  }
+  if (e->e_machine !=
+#if defined(__x86_64__)
+      EM_X86_64
+#elif defined(__i386__)
+      EM_386
+#else
+#error architecture not recognized, please add
+#endif
+     ) {
+    __write2("invalid architecture!\n");
+    return 1;
+  }
+
+  if (e->e_phentsize != sizeof(phdr)) {
+    __write2("invalid phentsize!\n");
+    return 1;
+  }
+  if (e->e_phnum > 20) {
+    __write2("phnum too large!\n");
+    return 1;
+  }
+  if (e->e_shentsize != sizeof(shdr)) {
+    __write2("invalid shentsize!\n");
+    return 1;
+  }
+  if (e->e_shnum > 100) {
+    __write2("shnum too large!\n");
+    return 1;
+  }
+
+  if (e->e_phoff>=l || e->e_phentsize*e->e_phnum>l-e->e_phoff) {
+    size_t wanted=e->e_phentsize*e->e_phnum;
+    p=alloca(wanted);
+    if (pread64(fd,p,wanted,e->e_phoff)!=wanted)
+      goto kaputt;
+  } else
+    p=(phdr*)(buf+e->e_phoff);
+
+  dlls=&dllroot;
+  if (map_sections(fd,e,p,&dllroot)) {
+    __write2("map_sections failed!\n");
+    return 1;
+  }
+  close(fd);
+
+  loadlibs(&dllroot);
+
+  /* now load the prerequisites of the libraries we loaded */
+  {
+    struct dll* x;
+    for (x=dlls; x; x=x->next) {
+      loadlibs(x);
+    }
+  }
+
+  resolve(&dllroot);
+
+  __write2("jumping...\n");
+
+  {
+    int (*_init)(int argc,char* argv[],char* envp[])=(void*)(e->e_entry+dllroot.codeplus);
+    return _init(argc,argv,envp);
+  }
+#if 0
+  {
+    char* x=dlsym("theint");
+    __write1("done\n");
+  }
+#endif
+
+#if 0
+  printf("jump to %p\n",e->e_entry);
+  for (i=0; i<16; ++i) {
+    printf("%02x ",((unsigned char*)e->e_entry)[i]);
+  }
+#endif
+
+  return 0;
+}
diff -urN -x .git dietlibc-0.33/lib/alloc.c dietlibc/lib/alloc.c
--- dietlibc-0.33/lib/alloc.c	2007-10-17 11:47:57.000000000 +0000
+++ dietlibc/lib/alloc.c	2015-01-01 12:14:43.481605561 +0000
@@ -18,8 +18,7 @@
 #include <stdlib.h>
 #include <string.h>
 
-#include <sys/shm.h>	/* for PAGE_SIZE */
-
+#include "../dietpagesize.h"
 
 /* -- HELPER CODE --------------------------------------------------------- */
 
@@ -39,7 +38,7 @@
 #define BLOCK_START(b)	(((void*)(b))-sizeof(__alloc_t))
 #define BLOCK_RET(b)	(((void*)(b))+sizeof(__alloc_t))
 
-#define MEM_BLOCK_SIZE	PAGE_SIZE
+#define MEM_BLOCK_SIZE	__DIET_PAGE_SIZE
 #define PAGE_ALIGN(s)	(((s)+MEM_BLOCK_SIZE-1)&(unsigned long)(~(MEM_BLOCK_SIZE-1)))
 
 /* a simple mmap :) */
@@ -66,7 +65,9 @@
 
 #define FIRST_SMALL(p)		(((unsigned long)(p))&(~(MEM_BLOCK_SIZE-1)))
 
-static inline int __ind_shift() { return (MEM_BLOCK_SIZE==4096)?4:5; }
+static inline int __ind_shift() {
+	return __DIET_PAGE_SHIFT - sizeof(__small_mem)/sizeof(__small_mem[0]);
+}
 
 static size_t REGPARM(1) get_index(size_t _size) {
   register size_t idx=0;
@@ -143,7 +144,6 @@
 }
 void __libc_free(void *ptr) __attribute__((alias("_alloc_libc_free")));
 void free(void *ptr) __attribute__((weak,alias("_alloc_libc_free")));
-void if_freenameindex(void* ptr) __attribute__((alias("free")));
 
 #ifdef WANT_MALLOC_ZERO
 static __alloc_t zeromem[2];
diff -urN -x .git dietlibc-0.33/lib/call_once.c dietlibc/lib/call_once.c
--- dietlibc-0.33/lib/call_once.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/lib/call_once.c	2015-01-01 12:14:43.481605561 +0000
@@ -0,0 +1,6 @@
+#include <threads.h>
+
+void call_once(once_flag* flag, void (*func)(void)) {
+  if (__sync_bool_compare_and_swap(flag,0,1))
+    func();
+}
diff -urN -x .git dietlibc-0.33/lib/closedir.c dietlibc/lib/closedir.c
--- dietlibc-0.33/lib/closedir.c	2002-07-03 20:33:37.000000000 +0000
+++ dietlibc/lib/closedir.c	2015-01-01 12:14:43.484938895 +0000
@@ -4,8 +4,10 @@
 #include <dirent.h>
 #include <stdlib.h>
 
+#include "../dietpagesize.h"
+
 int closedir (DIR* d) {
   int res=close(d->fd);
-  munmap (d, PAGE_SIZE);
+  munmap (d, __DIET_PAGE_SIZE);
   return res;
 }
diff -urN -x .git dietlibc-0.33/lib/cnd_broadcast.c dietlibc/lib/cnd_broadcast.c
--- dietlibc-0.33/lib/cnd_broadcast.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/lib/cnd_broadcast.c	2015-01-01 12:14:43.484938895 +0000
@@ -0,0 +1,8 @@
+#include <threads.h>
+#include <sys/futex.h>
+
+int cnd_broadcast(cnd_t* cond) {
+  cond->sem=1;
+  futex(&cond->sem,FUTEX_WAKE,0x7fffffff,0,0,0);
+  return thrd_success;
+}
diff -urN -x .git dietlibc-0.33/lib/cnd_destroy.c dietlibc/lib/cnd_destroy.c
--- dietlibc-0.33/lib/cnd_destroy.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/lib/cnd_destroy.c	2015-01-01 12:14:43.484938895 +0000
@@ -0,0 +1,6 @@
+#include <threads.h>
+
+void cnd_destroy(cnd_t* cond) {
+  // no need to do anything
+  (void)cond;
+}
diff -urN -x .git dietlibc-0.33/lib/cnd_init.c dietlibc/lib/cnd_init.c
--- dietlibc-0.33/lib/cnd_init.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/lib/cnd_init.c	2015-01-01 12:14:43.484938895 +0000
@@ -0,0 +1,6 @@
+#include <threads.h>
+
+int cnd_init(cnd_t* cond) {
+  cond->sem=0;
+  return thrd_success;
+}
diff -urN -x .git dietlibc-0.33/lib/cnd_signal.c dietlibc/lib/cnd_signal.c
--- dietlibc-0.33/lib/cnd_signal.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/lib/cnd_signal.c	2015-01-01 12:14:43.484938895 +0000
@@ -0,0 +1,8 @@
+#include <threads.h>
+#include <sys/futex.h>
+
+int cnd_signal(cnd_t* cond) {
+  cond->sem=1;
+  futex(&cond->sem,FUTEX_WAKE,1,0,0,0);
+  return thrd_success;
+}
diff -urN -x .git dietlibc-0.33/lib/cnd_timedwait.c dietlibc/lib/cnd_timedwait.c
--- dietlibc-0.33/lib/cnd_timedwait.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/lib/cnd_timedwait.c	2015-01-01 12:14:43.484938895 +0000
@@ -0,0 +1,17 @@
+#include <threads.h>
+#include <sys/futex.h>
+#include <errno.h>
+
+int cnd_timedwait(cnd_t* cond, mtx_t* mutex, const struct timespec* time_point) {
+  int r;
+  do {
+    r=futex(&cond->sem,FUTEX_WAIT,0,time_point,0,0);
+    if (r==-1) {
+      if (errno==EWOULDBLOCK) { r=0; break; }
+      else if (errno==EINTR) continue;
+    } else
+      break;
+  } while (r==0);
+  cond->sem=0;
+  return mtx_timedlock(mutex,time_point);
+}
diff -urN -x .git dietlibc-0.33/lib/cnd_wait.c dietlibc/lib/cnd_wait.c
--- dietlibc-0.33/lib/cnd_wait.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/lib/cnd_wait.c	2015-01-01 12:14:43.484938895 +0000
@@ -0,0 +1,7 @@
+#include <threads.h>
+#include <sys/futex.h>
+#include <errno.h>
+
+int cnd_wait(cnd_t* cond, mtx_t* mutex) {
+  return cnd_timedwait(cond,mutex,0);
+}
diff -urN -x .git dietlibc-0.33/lib/__dtostr.c dietlibc/lib/__dtostr.c
--- dietlibc-0.33/lib/__dtostr.c	2006-09-14 16:29:22.000000000 +0000
+++ dietlibc/lib/__dtostr.c	2015-01-01 12:14:43.481605561 +0000
@@ -5,13 +5,15 @@
 
 static int copystring(char* buf,int maxlen, const char* s) {
   int i;
-  for (i=0; i<3&&i<maxlen; ++i)
+  for (i=0; i<maxlen; ++i) {
     buf[i]=s[i];
-  if (i<maxlen) { buf[i]=0; ++i; }
+    if (!s[i])
+      break;
+  }
   return i;
 }
 
-int __dtostr(double d,char *buf,unsigned int maxlen,unsigned int prec,unsigned int prec2,int g) {
+int __dtostr(double d,char *buf,unsigned int maxlen,unsigned int prec,unsigned int prec2,int flags) {
 #if 1
   union {
     unsigned long long l;
@@ -35,8 +37,12 @@
   double tmp;
   char *oldbuf=buf;
 
-  if ((i=isinf(d))) return copystring(buf,maxlen,i>0?"inf":"-inf");
-  if (isnan(d)) return copystring(buf,maxlen,"nan");
+  if (isinf(d))
+    return copystring(buf,maxlen,
+		      (d<0)?
+		      (flags&0x02?"-INF":"-inf"):
+		      (flags&0x02?"INF":"inf"));
+  if (isnan(d)) return copystring(buf,maxlen,flags&0x02?"NAN":"nan");
   e10=1+(long)(e*0.30102999566398119802); /* log10(2) */
   /* Wir iterieren von Links bis wir bei 0 sind oder maxlen erreicht
    * ist.  Wenn maxlen erreicht ist, machen wir das nochmal in
@@ -126,7 +132,7 @@
   if (prec2 || prec>(unsigned int)(buf-oldbuf)+1) {	/* more digits wanted */
     if (!maxlen) return 0; --maxlen;
     *buf='.'; ++buf;
-    if (g) {
+    if ((flags & 0x01)) {
       if (prec2) prec=prec2;
       prec-=buf-oldbuf-1;
     } else {
diff -urN -x .git dietlibc-0.33/lib/errno.c dietlibc/lib/errno.c
--- dietlibc-0.33/lib/errno.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/lib/errno.c	2015-01-01 12:14:43.484938895 +0000
@@ -0,0 +1,3 @@
+#define extern
+
+#include "errno_definition.h"
diff -urN -x .git dietlibc-0.33/lib/errno_location.c dietlibc/lib/errno_location.c
--- dietlibc-0.33/lib/errno_location.c	2001-06-07 12:29:35.000000000 +0000
+++ dietlibc/lib/errno_location.c	2015-01-01 12:14:43.484938895 +0000
@@ -1,5 +1,7 @@
-extern int errno;
+#include <sys/tls.h>
+#include <threads.h>
+#include <errno.h>
 
-int *__errno_location(void) __attribute__((weak));
-int *__errno_location() { return &errno; }
+// int *__errno_location(void) __attribute__((weak));
+__attribute__((weak)) int *__errno_location(void) { return &errno; }
 
diff -urN -x .git dietlibc-0.33/lib/eventfd.c dietlibc/lib/eventfd.c
--- dietlibc-0.33/lib/eventfd.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/lib/eventfd.c	2015-01-01 12:14:43.484938895 +0000
@@ -0,0 +1,21 @@
+#include <sys/types.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <sys/eventfd.h>
+
+extern int __eventfd(unsigned int count);
+extern int __eventfd2(unsigned int count,int flags);
+
+int eventfd(unsigned int count,int flags) {
+  int r=__eventfd2(count,flags);
+  if (r==-1 && errno==ENOSYS) {
+    r=__eventfd(count);
+    if (r!=-1 && flags) {
+      int x;
+      x=fcntl(r,F_SETFD,flags);
+      if (x==-1)
+	close(r);
+    }
+  }
+  return r;
+}
diff -urN -x .git dietlibc-0.33/lib/fdopendir.c dietlibc/lib/fdopendir.c
--- dietlibc-0.33/lib/fdopendir.c	2012-01-15 19:20:56.000000000 +0000
+++ dietlibc/lib/fdopendir.c	2015-01-01 12:14:43.484938895 +0000
@@ -1,4 +1,5 @@
 #include "dietdirent.h"
+#include "dietpagesize.h"
 #include <sys/mman.h>
 #include <unistd.h>
 #include <dirent.h>
@@ -9,12 +10,9 @@
   DIR*  t  = NULL;
 
   if ( fd >= 0 ) {
-    t = (DIR *) mmap (NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, 
+    t = (DIR *) mmap (NULL, __DIET_PAGE_SIZE, PROT_READ | PROT_WRITE,
 		MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
-    if (t == MAP_FAILED)
-lose:
-      close (fd);
-    else
+    if (t != MAP_FAILED)
       t->fd = fd;
   }
 
diff -urN -x .git dietlibc-0.33/lib/__get_cur_tcb.c dietlibc/lib/__get_cur_tcb.c
--- dietlibc-0.33/lib/__get_cur_tcb.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/lib/__get_cur_tcb.c	2015-01-01 12:14:43.481605561 +0000
@@ -0,0 +1,26 @@
+#include <sys/tls.h>
+
+tcbhead_t* __get_cur_tcb(void) {
+#if defined(__alpha__)
+  register void* cur asm("$0");
+  asm("call_pal 158" : "=r"(cur) );	/* PAL_rduniq = 158 */
+#else	/* alpha */
+  register void* cur=0;
+#if defined(__sparc__)
+  asm("mov %%g6,%0" : "=r"(cur) );	/* %g6 (res. system use) is used as thread pointer */
+#elif defined(__s390__)
+  asm("ear %0,%%a0" : "=d"(cur) );	/* a0 (access register 0) is used as thread pointer */
+#elif defined(__ia64__)
+  asm("mov %0 = r13" : "=r"(cur) );	/* r13 (tp) is used as thread pointer */
+#elif defined(__x86_64__)
+#ifdef __ILP32__
+  asm("movl %%fs:(0),%0" : "=r"(cur));
+#else
+  asm("movq %%fs:(0),%0" : "=r"(cur));
+#endif
+#elif defined(__i386__)
+  asm("movl %%gs:(0),%0" : "=r"(cur));
+#endif
+#endif /* __alpha__ */
+  return cur;
+}
diff -urN -x .git dietlibc-0.33/lib/__get_elf_aux_value.c dietlibc/lib/__get_elf_aux_value.c
--- dietlibc-0.33/lib/__get_elf_aux_value.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/lib/__get_elf_aux_value.c	2015-01-01 12:14:43.481605561 +0000
@@ -0,0 +1,19 @@
+#include "dietfeatures.h"
+
+#ifdef WANT_ELFINFO
+#include <stdlib.h>
+#include "../dietelfinfo.h"
+
+__diet_elf_addr_t const *__get_elf_aux_value(unsigned int tag)
+{
+  extern __diet_elf_addr_t const * const	__elfinfo;
+  __diet_elf_addr_t const			*aux_ptr;
+
+  for (aux_ptr = __elfinfo; aux_ptr[0]!=AT_NULL; aux_ptr += 2)
+    if (aux_ptr[0]==tag)
+      return aux_ptr+1;
+
+  return NULL;
+}
+
+#endif
diff -urN -x .git dietlibc-0.33/lib/hcreate.c dietlibc/lib/hcreate.c
--- dietlibc-0.33/lib/hcreate.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/lib/hcreate.c	2015-01-01 12:14:43.484938895 +0000
@@ -0,0 +1,18 @@
+#include <search.h>
+
+static struct hsearch_data hd;
+
+int hcreate(size_t count) {
+  return hcreate_r(count,&hd);
+}
+
+void hdestroy(void) {
+  hdestroy_r(&hd);
+}
+
+ENTRY* hsearch(ENTRY item, ACTION action) {
+  ENTRY* x;
+  if (hsearch_r(item,action,&x,&hd))
+    return x;
+  return NULL;
+}
diff -urN -x .git dietlibc-0.33/lib/hcreate_r.c dietlibc/lib/hcreate_r.c
--- dietlibc-0.33/lib/hcreate_r.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/lib/hcreate_r.c	2015-01-01 12:14:43.484938895 +0000
@@ -0,0 +1,28 @@
+#define _GNU_SOURCE
+#include <search.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <time.h>
+#include <sys/auxv.h>
+
+int hcreate_r(size_t count, struct hsearch_data* htab) {
+  htab->size=count;
+  htab->filled=0;
+  htab->table=calloc(count,sizeof(htab->table[0]));
+  if (htab->table) {
+    char* rnd=(char*)getauxval(AT_RANDOM);
+    if (rnd)
+      memcpy(htab->key,rnd,16);
+    else {
+      struct timeval tv;
+      struct timeval* x=(struct timeval*)htab->key;
+      if (getrandom(&htab->key,sizeof(htab->key),0) != sizeof(htab->key)) {
+	gettimeofday(&tv,NULL);
+	x->tv_sec += tv.tv_sec;
+	x->tv_usec += tv.tv_usec;
+      }
+    }
+  }
+  return htab->table ? 1 : 0;
+}
+
diff -urN -x .git dietlibc-0.33/lib/hdestroy_r.c dietlibc/lib/hdestroy_r.c
--- dietlibc-0.33/lib/hdestroy_r.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/lib/hdestroy_r.c	2015-01-01 12:14:43.484938895 +0000
@@ -0,0 +1,19 @@
+#define _GNU_SOURCE
+#include <search.h>
+#include <stdlib.h>
+
+static void freelist(struct bucket* b) {
+  while (b) {
+    struct bucket* o=b;
+    b=b->next;
+    free(o);
+  }
+}
+
+void hdestroy_r(struct hsearch_data* htab) {
+  size_t i;
+  for (i=0; i<htab->size; ++i) {
+    freelist(htab->table[i]);
+    htab->table[i]=0;
+  }
+}
diff -urN -x .git dietlibc-0.33/lib/hsearch_r.c dietlibc/lib/hsearch_r.c
--- dietlibc-0.33/lib/hsearch_r.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/lib/hsearch_r.c	2015-01-01 12:14:43.484938895 +0000
@@ -0,0 +1,68 @@
+#define _GNU_SOURCE
+#include <search.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+static const size_t primes[] = {
+  67, 127, 257, 521, 1031, 2053, 4099, 8191, 16381, 32771, 65537,
+  131071, 262147, 524287, 1048583, 2097143 };
+
+static const unsigned int nprimes = sizeof(primes)/sizeof(primes[0]);
+
+int hsearch_r(ENTRY item, ACTION action, ENTRY** retval, struct hsearch_data* htab) {
+  uint64_t hv=siphash24(htab->key,(const unsigned char*)item.key,strlen(item.key));
+  struct bucket** b=&htab->table[hv%htab->size];
+  while (*b) {
+    if ((*b)->hv==hv && !strcmp((*b)->e.key,item.key)) {
+      /* found */
+      if (retval) *retval=&(*b)->e;
+      return 1;
+    }
+    b=(&(*b)->next);
+  }
+  if (action==FIND) {
+    errno=ESRCH;
+    return 0;
+  }
+  /* if we get this far, we are supposed to add the key */
+  if (htab -> size < primes[nprimes-1] && htab->filled+1 > htab->size) {
+    /* attempt to resize */
+    unsigned int i;
+    struct bucket** n;
+    for (i=0; i<nprimes; ++i)
+      if (htab->size < primes[i]) break;
+    i=primes[i];
+    n=calloc(i,sizeof(struct bucket*));
+    /* If the allocation failed, we can just limp on.
+      * Performance will be reduced but we'll live. */
+    if (n) {
+      unsigned int j;
+
+      for (j=0; j<htab->size; ++j) {
+	struct bucket* B=htab->table[j];
+	while (B) {
+	  struct bucket* c=B;
+	  B=B->next;
+	  unsigned int m=c->hv % i;
+	  c->next=n[m];
+	  n[m]=c;
+	}
+      }
+      free(htab->table);
+      htab->table=n;
+      htab->size=i;
+      b=&htab->table[hv%htab->size];
+      while (*b)
+	b=(&(*b)->next);
+    }
+  }
+  *b=malloc(sizeof(struct bucket));
+  if (!*b) return 0;
+  ++htab->filled;
+  (*b)->next=0;
+  (*b)->e=item;
+  (*b)->hv=hv;
+  if (retval) *retval=&(*b)->e;
+  return 1;
+}
diff -urN -x .git dietlibc-0.33/lib/if_freenameindex.c dietlibc/lib/if_freenameindex.c
--- dietlibc-0.33/lib/if_freenameindex.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/lib/if_freenameindex.c	2015-01-01 12:14:43.484938895 +0000
@@ -0,0 +1,6 @@
+#include <net/if.h>
+#include <stdlib.h>
+
+void if_freenameindex(struct if_nameindex* ptr) {
+  free(ptr);
+}
diff -urN -x .git dietlibc-0.33/lib/makecontext.c dietlibc/lib/makecontext.c
--- dietlibc-0.33/lib/makecontext.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/lib/makecontext.c	2015-01-01 12:14:43.484938895 +0000
@@ -0,0 +1,69 @@
+#include <ucontext.h>
+#include <stdarg.h>
+
+extern void __setcontext_trampoline();
+
+void makecontext(ucontext_t* c, void (*func)(void), int argc, ...) {
+  size_t* sp;
+  va_list v;
+  int i;
+#ifdef __hppa__
+#define PUSH(val) *++sp=(val);
+#else
+#define PUSH(val) *--sp=(val);
+#endif
+  /* we are called like this:
+
+    if (getcontext(&uctx_func1) == -1)
+        handle_error("getcontext");
+    uctx_func1.uc_stack.ss_sp = func1_stack;
+    uctx_func1.uc_stack.ss_size = sizeof(func1_stack);
+    uctx_func1.uc_link = &uctx_main;
+    makecontext(&uctx_func1, func1, 0);
+  */
+
+  /* first order of business: set up the stack */
+  /* the &-16 aligns it to 16 bytes */
+  sp=(size_t*)((size_t)(c->uc_stack.ss_sp + c->uc_stack.ss_size)&-16);
+  /* note that if the provided stack is to small, we will just crash in here */
+  va_start(v,argc);
+#ifdef __i386__
+  /* if there are no args, we need to make sure there is space on the
+   * stack for the trampoline to pretend uc_link was passed as stack
+   * argument */
+  if (!argc) PUSH(0);
+  /* we set up the context so we jump to it directly, and we leave
+   * __setcontext_trampoline as return address on the stack. */
+  /* __setcontext_trampoline needs to know the c->uc_link, so we put
+   * that into ebx, which is callee-saved */
+  c->uc_mcontext.ebx=(size_t)c->uc_link;
+  sp-=argc;
+  for (i=0; i<argc; ++i)
+    sp[i]=va_arg(v,size_t);
+  PUSH((size_t)__setcontext_trampoline);
+  c->uc_mcontext.esp=(size_t)sp;
+  c->uc_mcontext.eip=(size_t)func;
+#elif defined __x86_64__
+  /* __setcontext_trampoline needs to know the c->uc_link, so we put
+   * that into ebx, which is callee-saved */
+  c->uc_mcontext.rbx=(size_t)c->uc_link;
+  for (i=0; i<argc; ++i) {
+    switch(i) {
+    case 0: c->uc_mcontext.rdi=va_arg(v,size_t); break;
+    case 1: c->uc_mcontext.rsi=va_arg(v,size_t); break;
+    case 2: c->uc_mcontext.rdx=va_arg(v,size_t); break;
+    case 3: c->uc_mcontext.rcx=va_arg(v,size_t); break;
+    case 4: c->uc_mcontext.r8=va_arg(v,size_t); break;
+    case 5: c->uc_mcontext.r9=va_arg(v,size_t); break;
+    default: /* the rest goes on the stack */
+      PUSH(va_arg(v,size_t));
+    }
+  }
+  PUSH((size_t)__setcontext_trampoline);
+  c->uc_mcontext.rsp=(size_t)sp;
+  c->uc_mcontext.rip=(size_t)func;
+#else
+#warning platform not supported yet in makecontext
+#endif
+  va_end(v);
+}
diff -urN -x .git dietlibc-0.33/lib/mbrlen.c dietlibc/lib/mbrlen.c
--- dietlibc-0.33/lib/mbrlen.c	2008-12-10 20:00:59.000000000 +0000
+++ dietlibc/lib/mbrlen.c	2015-01-01 12:14:43.484938895 +0000
@@ -1,8 +1,6 @@
 #include <wchar.h>
 #include <errno.h>
 
-static mbstate_t internal;
-
 size_t mbrlen(const char *s, size_t n, mbstate_t *ps) {
   static mbstate_t internal;
   return mbrtowc (NULL, s, n, ps ?: &internal);
diff -urN -x .git dietlibc-0.33/lib/mmap64.c dietlibc/lib/mmap64.c
--- dietlibc-0.33/lib/mmap64.c	2004-12-13 10:21:31.000000000 +0000
+++ dietlibc/lib/mmap64.c	2015-01-01 12:14:43.484938895 +0000
@@ -4,16 +4,18 @@
 #include <syscalls.h>
 #include <errno.h>
 
+#include "../dietpagesize.h"
+
 #ifdef __NR_mmap2
 void*__mmap2(void*start,size_t length,int prot,int flags,int fd,off_t pgoffset);
 
 void*__libc_mmap64(void*addr,size_t len,int prot,int flags,int fd,off64_t offset);
 void*__libc_mmap64(void*addr,size_t len,int prot,int flags,int fd,off64_t offset) {
-  if (offset&(PAGE_SIZE-1)) {
+  if (offset&(__DIET_PAGE_SIZE)) {
     errno=-EINVAL;
     return MAP_FAILED;
   }
-  return __mmap2(addr,len,prot,flags,fd,offset>>PAGE_SHIFT);
+  return __mmap2(addr,len,prot,flags,fd,offset>>__DIET_PAGE_SHIFT);
 }
 
 void*mmap64(void*addr,size_t len,int prot,int flags,int fd,off64_t offset)
diff -urN -x .git dietlibc-0.33/lib/mtx_destroy.c dietlibc/lib/mtx_destroy.c
--- dietlibc-0.33/lib/mtx_destroy.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/lib/mtx_destroy.c	2015-01-01 12:14:43.484938895 +0000
@@ -0,0 +1,6 @@
+#include <threads.h>
+
+void mtx_destroy(mtx_t* mutex) {
+  // no need to do anything
+  (void)mutex;
+}
diff -urN -x .git dietlibc-0.33/lib/mtx_init.c dietlibc/lib/mtx_init.c
--- dietlibc-0.33/lib/mtx_init.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/lib/mtx_init.c	2015-01-01 12:14:43.484938895 +0000
@@ -0,0 +1,7 @@
+#include <threads.h>
+
+int mtx_init(mtx_t* mutex, int type) {
+  mutex->lock=0;
+  mutex->type=type;
+  return thrd_success;
+}
diff -urN -x .git dietlibc-0.33/lib/mtx_lock.c dietlibc/lib/mtx_lock.c
--- dietlibc-0.33/lib/mtx_lock.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/lib/mtx_lock.c	2015-01-01 12:14:43.484938895 +0000
@@ -0,0 +1,8 @@
+#define _REENTRANT
+#include <threads.h>
+#include <sys/futex.h>
+#include <errno.h>
+
+int mtx_lock(mtx_t* mutex) {
+  return mtx_timedlock(mutex,0);
+}
diff -urN -x .git dietlibc-0.33/lib/mtx_timedlock.c dietlibc/lib/mtx_timedlock.c
--- dietlibc-0.33/lib/mtx_timedlock.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/lib/mtx_timedlock.c	2015-01-01 12:14:43.484938895 +0000
@@ -0,0 +1,24 @@
+#define _REENTRANT
+#define _DIETLIBC_SOURCE
+#include <threads.h>
+#include <sys/futex.h>
+#include <errno.h>
+
+int mtx_timedlock(mtx_t* mutex, const struct timespec* time_point) {
+  int i,r;
+  thrd_t me=thrd_current();
+  do {
+    r=__mtx_trylock(mutex,&i);
+    if (r!=thrd_busy) return r;
+    for (;;) {
+      r=futex(&mutex->lock,FUTEX_WAIT,i,time_point,0,0);
+      if (r==-1) {
+	if (errno==EWOULDBLOCK) { r=0; break; } else
+	if (errno==ETIMEDOUT) return thrd_timedout; else
+	if (errno==EINTR) continue;
+      } else
+	break;
+    }
+  } while (r==0);
+  return thrd_error;
+}
diff -urN -x .git dietlibc-0.33/lib/mtx_trylock.c dietlibc/lib/mtx_trylock.c
--- dietlibc-0.33/lib/mtx_trylock.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/lib/mtx_trylock.c	2015-01-01 12:14:43.484938895 +0000
@@ -0,0 +1,28 @@
+#define _REENTRANT
+#define _DIETLIBC_SOURCE
+#include <threads.h>
+#include <sys/futex.h>
+#include <errno.h>
+
+int __mtx_trylock(mtx_t* mutex,int* lockval) {
+  int i;
+  thrd_t me=thrd_current();
+  /* attempt to lock the mutex with an atomic instruction */
+  if ((i=__sync_val_compare_and_swap(&mutex->lock,0,1))==0) {
+    mutex->owner=me;
+    return thrd_success;
+  }
+  if ((mutex->type&mtx_recursive) && mutex->owner==me) {
+    if (__sync_add_and_fetch(&mutex->lock,1)>1000) {
+      __sync_add_and_fetch(&mutex->lock,-1);
+      return thrd_error;
+    }
+    return thrd_success;
+  }
+  if (lockval) *lockval=i;
+  return thrd_busy;
+}
+
+int mtx_trylock(mtx_t* mutex) {
+  return __mtx_trylock(mutex,NULL);
+}
diff -urN -x .git dietlibc-0.33/lib/mtx_unlock.c dietlibc/lib/mtx_unlock.c
--- dietlibc-0.33/lib/mtx_unlock.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/lib/mtx_unlock.c	2015-01-01 12:14:43.484938895 +0000
@@ -0,0 +1,22 @@
+#define _REENTRANT
+#include <threads.h>
+#include <sys/futex.h>
+#include <errno.h>
+
+int mtx_unlock(mtx_t* mutex) {
+  int i,r;
+  thrd_t me=thrd_current();
+  if (mutex->lock==0) return thrd_error;
+  if ((mutex->type&mtx_recursive) && mutex->owner==me) {
+    if (__sync_add_and_fetch(&mutex->lock,-1)==0) {
+      // If we get here, the mutex was recursive, we unlocked it, and we
+      // were the last guy holding the lock.  Wake waiters.
+      mutex->owner=0;	// cosmetic; not really needed
+      futex(&mutex->lock,FUTEX_WAKE,1,0,0,0);
+    }
+    return thrd_success;
+  }
+  if (__sync_val_compare_and_swap(&mutex->lock,1,0)==1)
+    futex(&mutex->lock,FUTEX_WAKE,1,0,0,0);
+  return thrd_success;
+}
diff -urN -x .git dietlibc-0.33/lib/__nice.c dietlibc/lib/__nice.c
--- dietlibc-0.33/lib/__nice.c	2005-01-21 18:25:10.000000000 +0000
+++ dietlibc/lib/__nice.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,9 +0,0 @@
-#include "syscalls.h"
-#include <sys/time.h>
-#include <sys/resource.h>
-
-#ifndef __NR_nice
-int nice(int i) {
-  return setpriority(PRIO_PROCESS,0,getpriority(PRIO_PROCESS,0)+i);
-}
-#endif
diff -urN -x .git dietlibc-0.33/lib/nice.c dietlibc/lib/nice.c
--- dietlibc-0.33/lib/nice.c	2012-01-15 18:43:18.000000000 +0000
+++ dietlibc/lib/nice.c	2015-01-01 12:14:43.484938895 +0000
@@ -1,17 +1,56 @@
-#define _REENTRANT
+/*
+ * nice() for uClibc
+ *
+ * Copyright (C) 2000-2004 by Erik Andersen <andersen@codepoet.org>
+ * Copyright (C) 2005 by Manuel Novoa III <mjn3@codepoet.org>
+ *
+ * GNU Library General Public License (LGPL) version 2 or later.
+ */
+
 #include <errno.h>
-#include <unistd.h>
+#include <limits.h>
 #include <sys/resource.h>
 
-int nice(int incr) {
-  int prio;
-  int res;
-  errno=0;
-  prio = getpriority(PRIO_PROCESS,0) + incr;
-  if (prio < PRIO_MIN) prio=PRIO_MIN;
-  if (prio >= PRIO_MAX) prio=PRIO_MAX-1;
-  if (setpriority (PRIO_PROCESS, 0, prio)==-1)
-    return -1;
-  else
-    return getpriority(PRIO_PROCESS, 0);
+static inline int int_add_no_wrap(int a, int b)
+{
+	int	s;
+
+	if ((b > 0) && (a > (INT_MAX - b)))
+		s = INT_MAX;
+	else if ((b < 0) && (a < (INT_MIN - b)))
+		s = INT_MIN;
+	else
+		s = a + b;
+
+	return s;
+}
+
+static inline int __syscall_nice(int incr)
+{
+	int old_priority;
+	int old_errno;
+
+	old_errno = errno;
+	__set_errno(0);
+	old_priority = getpriority(PRIO_PROCESS, 0);
+	if ((old_priority == -1) && errno) {
+		return -1;
+	}
+	__set_errno(old_errno);
+
+	if (setpriority(PRIO_PROCESS, 0, int_add_no_wrap(old_priority, incr))) {
+		__set_errno(EPERM);	/* SUSv3 mandates EPERM for nice failure. */
+		return -1;
+	}
+
+	return 0;
+}
+
+int nice(int incr)
+{
+	if (__syscall_nice(incr)) {
+		return -1;
+	}
+
+	return getpriority(PRIO_PROCESS, 0);
 }
diff -urN -x .git dietlibc-0.33/lib/opendir.c dietlibc/lib/opendir.c
--- dietlibc-0.33/lib/opendir.c	2002-07-03 20:33:38.000000000 +0000
+++ dietlibc/lib/opendir.c	2015-01-01 12:14:43.484938895 +0000
@@ -5,6 +5,8 @@
 #include <stdlib.h>
 #include <fcntl.h>
 
+#include "../dietpagesize.h"
+
 DIR*  opendir ( const char* name ) {
   int   fd = open (name, O_RDONLY | O_DIRECTORY);
   DIR*  t  = NULL;
@@ -12,7 +14,7 @@
   if ( fd >= 0 ) {
     if (fcntl (fd, F_SETFD, FD_CLOEXEC) < 0)
       goto lose;
-    t = (DIR *) mmap (NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, 
+    t = (DIR *) mmap (NULL, __DIET_PAGE_SIZE, PROT_READ | PROT_WRITE,
 		MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
     if (t == MAP_FAILED)
 lose:
diff -urN -x .git dietlibc-0.33/lib/readdir64.c dietlibc/lib/readdir64.c
--- dietlibc-0.33/lib/readdir64.c	2004-03-02 21:27:19.000000000 +0000
+++ dietlibc/lib/readdir64.c	2015-01-01 12:14:43.484938895 +0000
@@ -13,11 +13,13 @@
 
 #ifndef WANT_LARGEFILE_BACKCOMPAT
 struct dirent64* readdir64(DIR *d) {
-  if (!d->num || (d->cur += ((struct dirent64*)(d->buf+d->cur))->d_reclen)>=d->num) {
-    int res=getdents64(d->fd,(struct dirent64*)d->buf, sizeof (d->buf)-1);
+  struct linux_dirent64 *ld = d->num ? (struct linux_dirent64*)(d->buf+d->cur) : NULL;
+  if (!d->num || (d->cur += ld->d_reclen)>=d->num) {
+    int res=getdents64(d->fd,(struct linux_dirent64*)d->buf, __DIRSTREAM_BUF_SIZE-1);
     if (res<=0) return 0;
-    d->num=res; d->cur=0;
+    d->num=res; d->cur=0; d->is_64=1;
   }
+  /* \todo: ensure that dirent64 and linux_dirent64 are compatible */
   return (struct dirent64*)(d->buf+d->cur);
 }
 #else
@@ -25,28 +27,30 @@
 #ifdef __NR_getdents64
   static int trygetdents64=1;
 #endif
-  struct dirent* o;
   static struct dirent64 d64;
 #ifdef __NR_getdents64
 again:
   if (!trygetdents64) {
 #endif
-    if (!d->num || (d->cur += ((struct dirent*)(d->buf+d->cur))->d_reclen)>=d->num) {
-      int res=getdents(d->fd,(struct dirent*)d->buf, sizeof (d->buf)-1);
+    struct linux_dirent *ld = d->num ? (struct linux_dirent*)(d->buf+d->cur) : NULL;
+    if (!d->num || (d->cur += ld->d_reclen)>=d->num) {
+      int res=getdents(d->fd,(struct linux_dirent*)d->buf, __DIRSTREAM_BUF_SIZE-1);
       if (res<=0) return 0;
-      d->num=res; d->cur=0;
+      d->num=res; d->cur=0;d->is_64=0;
+      ld=(struct linux_dirent*)(d->buf+d->cur);
     }
-    o=(struct dirent*)(d->buf+d->cur);
-    d64.d_ino=o->d_ino;
-    d64.d_off=o->d_off;
-    d64.d_reclen=o->d_reclen;
-    strcpy(d64.d_name,o->d_name);
+    d64.d_ino=ld->d_ino;
+    d64.d_off=ld->d_off;
+    d64.d_reclen=ld->d_reclen;
+    strcpy(d64.d_name,ld->d_name);
     d64.d_type=0;	/* is this correct? */
     return &d64;
 #ifdef __NR_getdents64
   }
-  if (!d->num || (d->cur += ((struct dirent64*)(d->buf+d->cur))->d_reclen)>=d->num) {
-    int res=getdents64(d->fd,(struct dirent64*)d->buf,sizeof (d->buf));
+  {
+  struct linux_dirent64 *ld = d->num ? (struct linux_dirent64*)(d->buf+d->cur) : NULL;
+  if (!d->num || (d->cur += ld->d_reclen)>=d->num) {
+    int res=getdents64(d->fd,(struct linux_dirent64*)d->buf,__DIRSTREAM_BUF_SIZE);
     if (res<=0) {
       if (errno==ENOSYS) {
 	trygetdents64=0;
@@ -54,8 +58,10 @@
       }
       return 0;
     }
-    d->num=res; d->cur=0;
+    d->num=res; d->cur=0; d->is_64=1;
   }
+  }
+  /* \todo: ensure that dirent64 and linux_dirent64 are compatible */
   return (struct dirent64*)(d->buf+d->cur);
 #endif
 }
diff -urN -x .git dietlibc-0.33/lib/readdir.c dietlibc/lib/readdir.c
--- dietlibc-0.33/lib/readdir.c	2012-11-02 11:17:28.000000000 +0000
+++ dietlibc/lib/readdir.c	2015-01-01 12:14:43.484938895 +0000
@@ -1,3 +1,4 @@
+#define _POSIX_SOURCE
 #include "dietdirent.h"
 #include <unistd.h>
 #include <dirent.h>
diff -urN -x .git dietlibc-0.33/lib/readdir_r.c dietlibc/lib/readdir_r.c
--- dietlibc-0.33/lib/readdir_r.c	2012-10-30 19:54:17.000000000 +0000
+++ dietlibc/lib/readdir_r.c	2015-01-01 12:14:43.484938895 +0000
@@ -4,21 +4,14 @@
 #include <dirent.h>
 #include <stdlib.h>
 
-struct linux_dirent {
-  long		d_ino;
-  off_t		d_off;
-  uint16_t	d_reclen;
-  char		d_name[1];
-};
-
 int readdir_r(DIR *d,struct dirent* entry, struct dirent** result) {
-  struct linux_dirent* ld;
+  struct linux_dirent* ld = d->num ? (struct linux_dirent*)(d->buf+d->cur) : NULL;
   *result=0;
-  if (!d->num || (d->cur += ((struct dirent*)(d->buf+d->cur))->d_reclen)>=d->num) {
-    int res=getdents(d->fd,(struct dirent*)d->buf,sizeof (d->buf)-1);
+  if (!d->num || d->cur >= d->num || (d->cur += ld->d_reclen)>=d->num) {
+    int res=getdents(d->fd,(struct linux_dirent*)d->buf,__DIRSTREAM_BUF_SIZE-1);
     if (res<=0)
       return res<0;
-    d->num=res; d->cur=0;
+    d->num=res; d->cur=0; d->is_64=0;
   }
   ld=(struct linux_dirent*)(d->buf+d->cur);
   if (ld->d_reclen < sizeof(struct linux_dirent))
diff -urN -x .git dietlibc-0.33/lib/reallocarray.c dietlibc/lib/reallocarray.c
--- dietlibc-0.33/lib/reallocarray.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/lib/reallocarray.c	2015-01-01 12:14:43.484938895 +0000
@@ -0,0 +1,17 @@
+#include <stdlib.h>
+#include <endian.h>
+
+#if __WORDSIZE == 64
+typedef __uint128_t ulll;
+#else
+typedef uint64_t ulll;
+#endif
+
+void* reallocarray(void* ptr, size_t nmemb, size_t size) {
+  /* produce a compile-time error if uintmax_t is not larger than size_t */
+  typedef char compile_time_assertion[(sizeof(ulll)>=sizeof(size_t)*2)-1];
+
+  ulll l=(ulll)nmemb * size;
+  if ((size_t)l != l) return 0;	// overflow
+  return realloc(ptr,(size_t)l);
+}
diff -urN -x .git dietlibc-0.33/lib/seekdir.c dietlibc/lib/seekdir.c
--- dietlibc-0.33/lib/seekdir.c	2006-05-29 16:30:53.000000000 +0000
+++ dietlibc/lib/seekdir.c	2015-01-01 12:14:43.488272228 +0000
@@ -2,9 +2,15 @@
 #include <unistd.h>
 #include <dirent.h>
 
-void seekdir(DIR *d,off_t offset) {
+void seekdir(DIR *d,long offset) {
   if (lseek(d->fd,offset,SEEK_SET) != (off_t)-1) {
     d->num=d->cur=0;
-    ((struct dirent *)(d->buf))->d_off = offset;
+    if (d->is_64) {
+      struct linux_dirent64 *ld = (void *)(d->buf + d->cur);
+      ld->d_off = offset;
+    } else {
+      struct linux_dirent *ld = (void *)(d->buf + d->cur);
+      ld->d_off = offset;
+    }
   }
 }
diff -urN -x .git dietlibc-0.33/lib/sigandset.c dietlibc/lib/sigandset.c
--- dietlibc-0.33/lib/sigandset.c	2004-12-17 19:14:49.000000000 +0000
+++ dietlibc/lib/sigandset.c	2015-01-01 12:14:43.488272228 +0000
@@ -4,8 +4,8 @@
 int sigandset(sigset_t*set,const sigset_t*left,const sigset_t*right)
 {
   set->sig[0]=left->sig[0]&right->sig[0];
-  if (_NSIG_WORDS>1) set->sig[1]=left->sig[1]&right->sig[1];
-  if (_NSIG_WORDS>2) {
+  if (_SIGSET_WORDS>1) set->sig[1]=left->sig[1]&right->sig[1];
+  if (_SIGSET_WORDS>2) {
     set->sig[2]=left->sig[2]&right->sig[2];
     set->sig[3]=left->sig[3]&right->sig[3];
   }
diff -urN -x .git dietlibc-0.33/lib/sigemptyset.c dietlibc/lib/sigemptyset.c
--- dietlibc-0.33/lib/sigemptyset.c	2001-07-26 13:14:34.000000000 +0000
+++ dietlibc/lib/sigemptyset.c	2015-01-01 12:14:43.488272228 +0000
@@ -2,8 +2,8 @@
 
 int sigemptyset(sigset_t *set) {
   set->sig[0]=0;
-  if (_NSIG_WORDS>1) set->sig[1]=0;
-  if (_NSIG_WORDS>2) {
+  if (_SIGSET_WORDS>1) set->sig[1]=0;
+  if (_SIGSET_WORDS>2) {
     set->sig[2]=0;
     set->sig[3]=0;
   }
diff -urN -x .git dietlibc-0.33/lib/sigfillset.c dietlibc/lib/sigfillset.c
--- dietlibc-0.33/lib/sigfillset.c	2001-07-26 13:14:34.000000000 +0000
+++ dietlibc/lib/sigfillset.c	2015-01-01 12:14:43.488272228 +0000
@@ -2,8 +2,8 @@
 
 int sigfillset(sigset_t *set) {
   set->sig[0]=(unsigned long)-1;
-  if (_NSIG_WORDS>1) set->sig[1]=(unsigned long)-1;
-  if (_NSIG_WORDS>2) {
+  if (_SIGSET_WORDS>1) set->sig[1]=(unsigned long)-1;
+  if (_SIGSET_WORDS>2) {
     set->sig[2]=(unsigned long)-1;
     set->sig[3]=(unsigned long)-1;
   }
diff -urN -x .git dietlibc-0.33/lib/sigisemptyset.c dietlibc/lib/sigisemptyset.c
--- dietlibc-0.33/lib/sigisemptyset.c	2005-09-28 06:18:43.000000000 +0000
+++ dietlibc/lib/sigisemptyset.c	2015-01-01 12:14:43.488272228 +0000
@@ -5,8 +5,8 @@
 {
   unsigned long ret;
   ret=set->sig[0];
-  if (_NSIG_WORDS>1) ret|=set->sig[1];
-  if (_NSIG_WORDS>2) {
+  if (_SIGSET_WORDS>1) ret|=set->sig[1];
+  if (_SIGSET_WORDS>2) {
     ret|=set->sig[2];
     ret|=set->sig[3];
   }
diff -urN -x .git dietlibc-0.33/lib/signalfd.c dietlibc/lib/signalfd.c
--- dietlibc-0.33/lib/signalfd.c	2008-08-30 13:59:28.000000000 +0000
+++ dietlibc/lib/signalfd.c	2015-01-01 12:14:43.488272228 +0000
@@ -1,13 +1,21 @@
 #include <signal.h>
 #include <errno.h>
 #include <sys/signalfd.h>
+#include <fcntl.h>
 
 extern int __signalfd(int fd,const sigset_t* mask,size_t nsig);
+extern int __signalfd4(int fd,const sigset_t* mask,size_t nsig, int flags);
 
 int signalfd(int fd,const sigset_t* mask,int flags) {
-  if (flags) {	/* bizarre glibc bullshit */
-    errno=EINVAL;
-    return -1;
+  int r=__signalfd4(fd,mask,_NSIG/8,flags);
+  if (r==-1 && errno==ENOSYS) {
+    r=__signalfd(fd,mask,NSIG/8);
+    if (r!=-1 && flags) {
+      int x;
+      x=fcntl(r,F_SETFD,flags);
+      if (x==-1)
+	close(r);
+    }
   }
-  return __signalfd(fd,mask,_NSIG/8);
+  return r;
 }
diff -urN -x .git dietlibc-0.33/lib/sigorset.c dietlibc/lib/sigorset.c
--- dietlibc-0.33/lib/sigorset.c	2004-12-17 19:14:49.000000000 +0000
+++ dietlibc/lib/sigorset.c	2015-01-01 12:14:43.488272228 +0000
@@ -4,8 +4,8 @@
 int sigorset(sigset_t*set,const sigset_t*left,const sigset_t*right)
 {
   set->sig[0]=left->sig[0]|right->sig[0];
-  if (_NSIG_WORDS>1) set->sig[1]=left->sig[1]|right->sig[1];
-  if (_NSIG_WORDS>2) {
+  if (_SIGSET_WORDS>1) set->sig[1]=left->sig[1]|right->sig[1];
+  if (_SIGSET_WORDS>2) {
     set->sig[2]=left->sig[2]|right->sig[2];
     set->sig[3]=left->sig[3]|right->sig[3];
   }
diff -urN -x .git dietlibc-0.33/lib/siphash24.c dietlibc/lib/siphash24.c
--- dietlibc-0.33/lib/siphash24.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/lib/siphash24.c	2015-01-01 12:14:43.488272228 +0000
@@ -0,0 +1,67 @@
+#include <search.h>
+
+/* taken from https://github.com/floodyberry/siphash */
+
+#define ROTL64(a,b) (((a)<<(b))|((a)>>(64-b)))
+
+static uint64_t
+U8TO64_LE(const unsigned char *p) {
+	return *(const uint64_t *)p;
+}
+
+uint64_t
+siphash24(const unsigned char key[16], const unsigned char *m, size_t len) {
+	uint64_t v0, v1, v2, v3;
+	uint64_t mi, k0, k1;
+	uint64_t last7;
+	size_t i, blocks;
+
+	k0 = U8TO64_LE(key + 0);
+	k1 = U8TO64_LE(key + 8);
+	v0 = k0 ^ 0x736f6d6570736575ull;
+	v1 = k1 ^ 0x646f72616e646f6dull;
+	v2 = k0 ^ 0x6c7967656e657261ull;
+	v3 = k1 ^ 0x7465646279746573ull;
+
+	last7 = (uint64_t)(len & 0xff) << 56;
+
+#define sipcompress() \
+	v0 += v1; v2 += v3; \
+	v1 = ROTL64(v1,13);	v3 = ROTL64(v3,16); \
+	v1 ^= v0; v3 ^= v2; \
+	v0 = ROTL64(v0,32); \
+	v2 += v1; v0 += v3; \
+	v1 = ROTL64(v1,17); v3 = ROTL64(v3,21); \
+	v1 ^= v2; v3 ^= v0; \
+	v2 = ROTL64(v2,32);
+
+	for (i = 0, blocks = (len & ~7); i < blocks; i += 8) {
+		mi = U8TO64_LE(m + i);
+		v3 ^= mi;
+		sipcompress()
+		sipcompress()
+		v0 ^= mi;
+	}
+
+	switch (len - blocks) {
+		case 7: last7 |= (uint64_t)m[i + 6] << 48;
+		case 6: last7 |= (uint64_t)m[i + 5] << 40;
+		case 5: last7 |= (uint64_t)m[i + 4] << 32;
+		case 4: last7 |= (uint64_t)m[i + 3] << 24;
+		case 3: last7 |= (uint64_t)m[i + 2] << 16;
+		case 2: last7 |= (uint64_t)m[i + 1] <<  8;
+		case 1: last7 |= (uint64_t)m[i + 0]      ;
+		case 0:
+		default:;
+	};
+	v3 ^= last7;
+	sipcompress()
+	sipcompress()
+	v0 ^= last7;
+	v2 ^= 0xff;
+	sipcompress()
+	sipcompress()
+	sipcompress()
+	sipcompress()
+	return v0 ^ v1 ^ v2 ^ v3;
+}
diff -urN -x .git dietlibc-0.33/lib/stackgap.c dietlibc/lib/stackgap.c
--- dietlibc-0.33/lib/stackgap.c	2012-01-24 18:24:26.000000000 +0000
+++ dietlibc/lib/stackgap.c	2015-01-01 12:14:43.488272228 +0000
@@ -16,13 +16,20 @@
 #include <elf.h>
 #include <stdlib.h>
 #include "dietfeatures.h"
+#include <sys/auxv.h>
+#include "dietelfinfo.h"
+
+#ifdef IN_LDSO
+#undef WANT_TLS
+#undef WANT_SSP
+#endif
 
 #ifdef WANT_GNU_STARTUP_BLOAT
 char* program_invocation_name;
 char* program_invocation_short_name;
 #endif
 
-void* __vdso;
+void const * __vdso;
 
 extern int main(int argc,char* argv[],char* envp[]);
 
@@ -50,11 +57,12 @@
 
 static void findtlsdata(long* auxvec) {
 #if (__WORDSIZE == 64)
-  Elf64_Phdr* x=0;
+  Elf64_Phdr const * x=0;
 #else
-  Elf32_Phdr* x=0;
+  Elf32_Phdr const * x=0;
 #endif
   size_t i,n=0;
+#ifndef WANT_ELFINFO
   while (*auxvec) {
     if (auxvec[0]==3) {	/* AT_PHDR */
       x=(void*)auxvec[1];
@@ -65,12 +73,26 @@
     }
     auxvec+=2;
   } /* if we don't find the entry, the kernel let us down */
+#else
+  {
+    __diet_elf_addr_t const	*x_addr = __get_elf_aux_value(AT_PHDR);
+    __diet_elf_addr_t const	*n_addr = __get_elf_aux_value(AT_PHNUM);
+
+    (void)auxvec;
+    if (x_addr)
+      x = (__typeof__(x)) *x_addr;
+    if (n_addr)
+      n = *n_addr;
+  }
+#endif
   if (!x || !n) return;	/* a kernel this old does not support thread local storage anyway */
   for (i=0; i<n; ++i)
     if (x[i].p_type==PT_TLS) {
       __tdataptr=(void*)x[i].p_vaddr;
       __tdatasize=x[i].p_filesz;
       __tmemsize=x[i].p_memsz;
+      if (__tmemsize&15)
+	__tmemsize=(__tmemsize+15)&~15;
       break;
     }
   /* if there is no PT_TLS section, there is no thread-local data, and
@@ -113,42 +135,61 @@
 
 #elif defined(__alpha__) || defined(__s390__)
   __builtin_set_thread_pointer(mainthread);
-#elif defined(__ia64__) || defined(__powerpc__)
-  register tcbhead_t* __thread_self __asm__("r13");
-  __thread_self=mainthread;
-#elif defined(__sparc__)
-  register tcbhead_t* __thread_self __asm("%g7");
+#elif defined(__arm__)
+  __arm_set_tls(mainthread);
+#elif defined(__ABI_TLS_REGISTER)
+  register tcbhead_t* __thread_self __asm__(__ABI_TLS_REGISTER);
   __thread_self=mainthread;
+  __asm__ __volatile__("" : : "r"(__thread_self) : "memory");
 #else
-#warning "no idea how to enable TLS on this platform, edit lib/stackgap.c"
+#error "no idea how to enable TLS on this platform, edit lib/stackgap.c"
 #endif
 }
 #endif
 
-static void* find_in_auxvec(long* x,long what) {
+static void const * find_in_auxvec(long* x,long what) {
+#ifndef WANT_ELFINFO
   while (*x) {
     if (*x==what)
       return (void*)x[1];
     x+=2;
   }
   return NULL;
+#else
+  __diet_elf_addr_t const	*a = __get_elf_aux_value(what);
+  (void)x;
+  return a ? (void *)*a : NULL;
+#endif
+}
+
+#ifndef WANT_ELFINFO
+static long* _auxvec;
+#else
+#define _auxvec	NULL
+#endif
+
+unsigned long getauxval(unsigned long type) {
+  return (long)find_in_auxvec(_auxvec,type);
 }
 
 int stackgap(int argc,char* argv[],char* envp[]);
 int stackgap(int argc,char* argv[],char* envp[]) {
-  long* auxvec=(long*)envp;
 #if defined(WANT_STACKGAP) || defined(WANT_SSP) || defined(WANT_TLS)
-  char* rand;
+  char const * rand;
   char* tlsdata;
+  long* auxvec=(long*)envp;
+#ifndef WANT_ELFINFO
   while (*auxvec) ++auxvec; ++auxvec;	/* skip envp to get to auxvec */
+  _auxvec=auxvec;
+#endif
 #ifdef WANT_STACKGAP
   unsigned short s;
+  volatile char* gap;
 #endif
 #if defined(WANT_STACKGAP) || defined(WANT_SSP)
-  volatile char* gap;
+  char myrand[10];
   rand=find_in_auxvec(auxvec,25);
   if (!rand) {
-    char myrand[10];
     int fd=open("/dev/urandom",O_RDONLY);
     read(fd,myrand,10);
     close(fd);
@@ -181,6 +222,7 @@
   memcpy(tlsdata,__tdataptr,__tdatasize);
   memset(tlsdata+__tdatasize,0,__tmemsize-__tdatasize);
   __setup_tls(__tcb_mainthread=(tcbhead_t*)(tlsdata+__tmemsize));
+  __tcb_mainthread->sysinfo=(uintptr_t)find_in_auxvec(auxvec,32);
 #elif defined(WANT_SSP)
   tlsdata=alloca(sizeof(tcbhead_t));
   __setup_tls(__tcb_mainthread=(tcbhead_t*)(tlsdata));
diff -urN -x .git dietlibc-0.33/lib/stack_smash_handler2.c dietlibc/lib/stack_smash_handler2.c
--- dietlibc-0.33/lib/stack_smash_handler2.c	2006-04-04 05:35:14.000000000 +0000
+++ dietlibc/lib/stack_smash_handler2.c	2015-01-01 12:14:43.488272228 +0000
@@ -8,5 +8,17 @@
  * diagnostics.  No more. :-( */
 void __stack_chk_fail(void) {
   __write2("smashed stack detected, program terminated.\n");
-  _exit(127);
+
+  /* trigger a segfault which can be inspected within a debugger (inclusive
+   * stack-trace). 'abort(3)' at this place would be too heavy weighted.
+   *
+   * TODO: limit this to systems which are known to have an MMU (resp. is
+   * dietlibc with stack-protector used on systems without an MMU?)
+   */
+  *(char volatile *)0 = 0;
+  while (1) {
+#if defined(__GNUC__) && ((((__GNUC__) << 8) | (__GNUC_MINOR__)) >= 0x405)
+    __builtin_unreachable();
+#endif
+  }
 }
diff -urN -x .git dietlibc-0.33/lib/stpcpy.c dietlibc/lib/stpcpy.c
--- dietlibc-0.33/lib/stpcpy.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/lib/stpcpy.c	2015-01-01 12:14:43.488272228 +0000
@@ -0,0 +1,6 @@
+#include <string.h>
+
+char * stpcpy (char *dst, const char *src) {
+  while ((*dst++ = *src++));
+  return (dst-1);
+}
diff -urN -x .git dietlibc-0.33/lib/swapcontext.c dietlibc/lib/swapcontext.c
--- dietlibc-0.33/lib/swapcontext.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/lib/swapcontext.c	2015-01-01 12:14:43.488272228 +0000
@@ -0,0 +1,12 @@
+#include <ucontext.h>
+#include <stdio.h>
+
+int swapcontext(ucontext_t* o,const ucontext_t* n) {
+  volatile int once=0;
+  if (getcontext(o)==-1) return -1;
+  if (!once) {
+    ++once;
+    return setcontext(n);
+  }
+  return 0;
+}
diff -urN -x .git dietlibc-0.33/lib/tcsetattr.c dietlibc/lib/tcsetattr.c
--- dietlibc-0.33/lib/tcsetattr.c	2002-01-11 18:06:53.000000000 +0000
+++ dietlibc/lib/tcsetattr.c	2015-01-01 12:14:43.488272228 +0000
@@ -3,24 +3,8 @@
 #include <errno.h>
 #include "dietfeatures.h"
 
-#if !defined(__powerpc__) && !defined(__sparc__) && !defined(__alpha__) && !defined(__hppa__)
-#if TCSANOW==0 && TCSADRAIN==1 && TCSAFLUSH==2 && TCSETSW-TCSETS==1 && TCSETSF-TCSETS==2
-#define shortcut
-#endif
-#endif
-
 int  tcsetattr ( int fildes, int optional_actions, struct termios* termios_p )
 {
-#ifdef shortcut
-
-    if ( (unsigned int)optional_actions < 3u )
-        return ioctl ( fildes, TCSETS+optional_actions, termios_p );
-
-    errno = EINVAL;
-    return -1;
-
-#else
-
     switch ( optional_actions ) {
     case TCSANOW:
         return ioctl ( fildes, TCSETS , termios_p );
@@ -32,6 +16,4 @@
         errno = EINVAL;
         return -1;
     }
-    
-#endif    
 }
diff -urN -x .git dietlibc-0.33/lib/telldir.c dietlibc/lib/telldir.c
--- dietlibc-0.33/lib/telldir.c	2006-05-29 16:30:53.000000000 +0000
+++ dietlibc/lib/telldir.c	2015-01-01 12:14:43.488272228 +0000
@@ -2,9 +2,16 @@
 #include <unistd.h>
 #include <dirent.h>
 
-off_t telldir(DIR *d) {
-  off_t result = 0;
-  if (lseek(d->fd,0,SEEK_CUR))
-    result=((struct dirent*)(d->buf+d->cur))->d_off;
+long telldir(DIR *d) {
+  long result = 0;
+  if (lseek(d->fd,0,SEEK_CUR)) {
+    if (d->is_64) {
+      struct linux_dirent64 *ld = (void *)(d->buf + d->cur);
+      result=ld->d_off;
+    } else {
+      struct linux_dirent *ld = (void *)(d->buf + d->cur);
+      result=ld->d_off;
+    }
+  }
   return result;
 }
diff -urN -x .git dietlibc-0.33/lib/thrd_create.c dietlibc/lib/thrd_create.c
--- dietlibc-0.33/lib/thrd_create.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/lib/thrd_create.c	2015-01-01 12:14:43.488272228 +0000
@@ -0,0 +1,73 @@
+#define _LINUX_SOURCE
+#include <unistd.h>
+#include <threads.h>
+#include <sys/mman.h>
+#include <fcntl.h>
+#define _GNU_SOURCE
+#include <sched.h>
+#include "dietfeatures.h"
+#include <sys/tls.h>
+#include <stdio.h>
+
+extern thrd_t _thrd_root;
+extern size_t _thrd_stacksize;
+
+#ifdef WANT_TLS
+extern size_t __tdatasize, __tmemsize;
+extern void* __tdataptr;
+extern tcbhead_t* __tcb_mainthread;
+#else
+static const size_t __tmemsize=0,__tdatasize=0;
+#endif
+
+static int launch(void* p) {
+  thrd_t self=p;
+  thrd_exit(self->func(self->arg));
+  return 0;
+}
+
+int thrd_create(thrd_t *thr, thrd_start_t func, void *arg) {
+  size_t stacksize=_thrd_stacksize;	// capture value to prevent asynchronous changes to break us
+  char* stack=mmap(0,stacksize+4096+__tmemsize+sizeof(tcbhead_t)+sizeof(**thr),PROT_NONE,MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK|MAP_GROWSDOWN,-1,0);
+  thrd_t t;
+  tcbhead_t* tcb;
+  int r;
+
+  if (stack==MAP_FAILED) return thrd_nomem;
+  r=thrd_success;
+  if (mprotect(stack+4096,stacksize+__tmemsize+sizeof(tcbhead_t)+sizeof(**thr),PROT_READ|PROT_WRITE)) {
+    munmap(stack,stacksize+4096+__tmemsize+sizeof(tcbhead_t)+sizeof(**thr));
+    return thrd_error;
+  }
+  tcb=(tcbhead_t*)(stack+stacksize+4096+__tmemsize);
+  tcb->tcb=tcb;
+  tcb->dtv=0;
+  t=(thrd_t)(tcb+1);
+  tcb->self=t;
+  tcb->multiple_threads=1;
+#ifdef WANT_TLS
+  tcb->sysinfo=__tcb_mainthread->sysinfo;
+  tcb->stack_guard=__tcb_mainthread->stack_guard ^ gettid() ^ (uintptr_t)t;
+  __tcb_mainthread->multiple_threads=1;
+#endif
+  t->memstart=stack;
+  t->memsize=stacksize+4096+__tmemsize;
+  t->res=0;
+  t->func=func;
+  t->arg=arg;
+  t->flags=0;
+  t->join_futex=0;
+
+#ifdef WANT_TLS
+  memcpy(stack+stacksize+4096,__tdataptr,__tdatasize);
+  memset(stack+stacksize+4096+__tdatasize,0,__tmemsize-__tdatasize);
+#endif
+
+  t->tid=clone(launch,stack+4096+stacksize,CLONE_FILES|CLONE_FS|CLONE_IO|CLONE_PARENT|CLONE_SIGHAND|CLONE_SYSVSEM|CLONE_THREAD|CLONE_VM|CLONE_SETTLS|CLONE_PARENT_SETTID,t,&t->tid,stack+stacksize+4096+__tmemsize);
+  if (t->tid==-1) {
+    munmap(stack,stacksize+4096+__tmemsize+sizeof(tcbhead_t)+sizeof(**thr));
+    return thrd_error;
+  }
+  *thr=t;
+  return thrd_success;
+}
diff -urN -x .git dietlibc-0.33/lib/thrd_current.c dietlibc/lib/thrd_current.c
--- dietlibc-0.33/lib/thrd_current.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/lib/thrd_current.c	2015-01-01 12:14:43.488272228 +0000
@@ -0,0 +1,8 @@
+#include <sys/tls.h>
+#include <threads.h>
+
+thrd_t thrd_current(void) {
+  tcbhead_t* x=__get_cur_tcb();
+  if (x->multiple_threads==0) return NULL;
+  return (thrd_t)(x+1);
+}
diff -urN -x .git dietlibc-0.33/lib/thrd_detach.c dietlibc/lib/thrd_detach.c
--- dietlibc-0.33/lib/thrd_detach.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/lib/thrd_detach.c	2015-01-01 12:14:43.488272228 +0000
@@ -0,0 +1,17 @@
+#include <threads.h>
+#include <sys/tls.h>
+#include <sys/mman.h>
+
+int thrd_detach(thrd_t thr) {
+  int flags=thr->flags;
+  do {
+    if (flags&4) return thrd_error;
+    if (flags&2) {
+      munmap(thr->memstart+thr->memsize,sizeof(tcbhead_t)+sizeof(*thr));
+      return thrd_success;
+    }
+    if (flags&1) return thrd_success;
+    flags=__sync_val_compare_and_swap(&thr->flags,flags,flags|1);
+  } while (1);
+}
+
diff -urN -x .git dietlibc-0.33/lib/thrd_exit.c dietlibc/lib/thrd_exit.c
--- dietlibc-0.33/lib/thrd_exit.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/lib/thrd_exit.c	2015-01-01 12:14:43.488272228 +0000
@@ -0,0 +1,59 @@
+#define _REENTRANT
+#define _LINUX_SOURCE
+#include <threads.h>
+#include <unistd.h>
+#include <sys/futex.h>
+#include <sys/tls.h>
+#include <stdlib.h>
+#include <errno.h>
+
+extern void __munmap_and_exit(void* map,size_t len) __attribute__((noreturn));
+
+thread_local tss_t tss_dtor_list;
+
+void thrd_exit(int res) {
+  thrd_t t=thrd_current();
+  int flags;
+
+  size_t len;
+
+  while (tss_dtor_list) {
+    tss_t cur=tss_dtor_list;
+    tss_dtor_list=tss_dtor_list->next;
+    if (cur->dtor) cur->dtor(cur);
+  }
+  if (!t) exit(res);	// moron user called us when no threads are running
+  t->res=res;
+  if ((flags=__sync_fetch_and_or(&t->flags,4))&4) return;	// shouldn't be possible, but the tear-down-bit was already set
+  if (t->join_futex) {	// somebody is waiting; send him a message
+    t->join_wait_futex=0;
+    if (futex(&t->join_futex,FUTEX_WAKE,1,0,0,0)==1) {	// wake the guy waiting for us
+      // We woke somebody up.
+      // Give him time to read our exit code.
+      int r;
+      do {
+	r=futex(&t->join_wait_futex,FUTEX_WAIT,0,0,0,0);
+      } while (r==EINTR);
+    }
+    flags|=1;	// mark as detached
+  }
+
+  len=t->memsize;
+  if (flags&1) {
+    // We are detached or somebody already thrd_join'ed us.
+    // We can die in piece and free all our resources
+    len += sizeof(tcbhead_t)+sizeof(*t);
+  } else {
+    // Tell thrd_join that we are dead and cleaned up our stack and it
+    // should clean up the rest when it's done.
+    __sync_fetch_and_or(&t->flags,2);
+    len&=~4095;	// round down to nearest page
+    t->arg=t->memstart+len;
+    t->memsize=t->memsize+sizeof(tcbhead_t)+sizeof(*t)-len;
+  }
+  /* Problem: we need to unmap the stack and call exit, but we can't
+   * touch the stack in between. Unfortunately, calling exit touches the
+   * stack. Returning from the munmap syscall also touches the stack. So
+   * this needs to be done in assembly language. */
+  __munmap_and_exit(t->memstart,len);
+}
diff -urN -x .git dietlibc-0.33/lib/thrd_join.c dietlibc/lib/thrd_join.c
--- dietlibc-0.33/lib/thrd_join.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/lib/thrd_join.c	2015-01-01 12:14:43.488272228 +0000
@@ -0,0 +1,30 @@
+#define _REENTRANT
+#include <threads.h>
+#include <sys/futex.h>
+#include <sys/mman.h>
+#include <sys/tls.h>
+#include <errno.h>
+
+int thrd_join(thrd_t thr, int* res) {
+  int flags=thr->flags;
+  int r;
+  if ((flags&2)==0) {
+    if (flags&5)
+      // thread is detached or in the process of being cleaned up, refuse join
+      return thrd_error;
+    if (!__sync_bool_compare_and_swap(&thr->join_futex,0,1))
+      // somebody is already calling thrd_join, refuse join
+      return thrd_error;
+    do {
+      r=futex(&thr->join_futex,FUTEX_WAIT,1,0,0,0);
+    } while (r==-1 && errno==EINTR);
+    if (res) *res=thr->res;
+    thr->join_wait_futex=1;
+    futex(&thr->join_wait_futex,FUTEX_WAKE,1,0,0,0);
+  } else {
+    if (res) *res=thr->res;
+    munmap(thr->arg,thr->memsize);
+  }
+  return thrd_success;
+}
+
diff -urN -x .git dietlibc-0.33/lib/thrd_root.c dietlibc/lib/thrd_root.c
--- dietlibc-0.33/lib/thrd_root.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/lib/thrd_root.c	2015-01-01 12:14:43.488272228 +0000
@@ -0,0 +1,4 @@
+#include <threads.h>
+
+thrd_t _thrd_root;
+size_t _thrd_stacksize=16*1024;
diff -urN -x .git dietlibc-0.33/lib/tss_create.c dietlibc/lib/tss_create.c
--- dietlibc-0.33/lib/tss_create.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/lib/tss_create.c	2015-01-01 12:14:43.488272228 +0000
@@ -0,0 +1,14 @@
+#include <stdlib.h>
+#include <threads.h>
+
+extern thread_local tss_t tss_dtor_list;
+
+int tss_create(tss_t* tss_id, tss_dtor_t destructor) {
+  *tss_id=malloc(sizeof(**tss_id));
+  if (!*tss_id) return thrd_nomem;
+  (*tss_id)->dtor=destructor;
+  (*tss_id)->next=tss_dtor_list;
+  (*tss_id)->data=0;
+  tss_dtor_list=*tss_id;
+  return thrd_success;
+}
diff -urN -x .git dietlibc-0.33/lib/tss_delete.c dietlibc/lib/tss_delete.c
--- dietlibc-0.33/lib/tss_delete.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/lib/tss_delete.c	2015-01-01 12:14:43.488272228 +0000
@@ -0,0 +1,14 @@
+#include <threads.h>
+
+extern thread_local tss_t tss_dtor_list;
+
+void tss_delete(tss_t tss_id) {
+  tss_t* cur;
+  for (cur=&tss_dtor_list; *cur; cur=&((*cur)->next)) {
+    if (*cur==tss_id)
+      *cur=tss_id->next;
+  }
+  tss_id->dtor=0;
+  tss_id->data=0;
+  tss_id->next=0;
+}
diff -urN -x .git dietlibc-0.33/lib/tss_get.c dietlibc/lib/tss_get.c
--- dietlibc-0.33/lib/tss_get.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/lib/tss_get.c	2015-01-01 12:14:43.488272228 +0000
@@ -0,0 +1,5 @@
+#include <threads.h>
+
+void* tss_get(tss_t tss_id) {
+  return tss_id->data;
+}
diff -urN -x .git dietlibc-0.33/lib/tss_set.c dietlibc/lib/tss_set.c
--- dietlibc-0.33/lib/tss_set.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/lib/tss_set.c	2015-01-01 12:14:43.488272228 +0000
@@ -0,0 +1,6 @@
+#include <threads.h>
+
+int tss_set(tss_t tss_id, void* val) {
+  tss_id->data=val;
+  return thrd_success;
+}
diff -urN -x .git dietlibc-0.33/lib/__utime.c dietlibc/lib/__utime.c
--- dietlibc-0.33/lib/__utime.c	2011-03-03 18:40:05.000000000 +0000
+++ dietlibc/lib/__utime.c	2015-01-01 12:14:43.481605561 +0000
@@ -1,7 +1,13 @@
-#include <utime.h>
 #include <syscalls.h>
+#define _BSD_SOURCE
+#include <utime.h>
+#include <sys/time.h>
 
 #ifndef __NR_utime
+#define _BSD_SOURCE
+#include <utime.h>
+#include <sys/time.h>
+
 int utime(const char *filename, const struct utimbuf *times)
 {
   if (times == NULL)
diff -urN -x .git dietlibc-0.33/lib/__v_printf.c dietlibc/lib/__v_printf.c
--- dietlibc-0.33/lib/__v_printf.c	2008-05-06 17:18:34.000000000 +0000
+++ dietlibc/lib/__v_printf.c	2015-01-01 12:14:43.481605561 +0000
@@ -4,6 +4,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <errno.h>
+#include <math.h>
 #include "dietstdio.h"
 #include "dietwarning.h"
 
@@ -346,45 +347,49 @@
 #ifdef WANT_FLOATING_POINT_IN_PRINTF
       /* print a floating point value */
       case 'f':
+      case 'F':
       case 'g':
+      case 'G':
 	{
-	  int g=(ch=='g');
+	  int flags=(((ch&0x5f)=='G') ? 0x01 : 0x00) | ((ch&0x20) ? 0x00 : 0x02);
 	  double d=va_arg(arg_ptr,double);
 	  s=buf+1;
 	  if (width==0) width=1;
 	  if (!flag_dot) preci=6;
 	  if (flag_sign || d < +0.0) flag_in_sign=1;
 
-	  sz=__dtostr(d,s,sizeof(buf)-1,width,preci,g);
+	  sz=__dtostr(d,s,sizeof(buf)-1,width,preci,flags);
 
-	  if (flag_dot) {
-	    char *tmp;
-	    if ((tmp=strchr(s,'.'))) {
-	      if (preci || flag_hash) ++tmp;
-	      while (preci>0 && *++tmp) --preci;
-	      *tmp=0;
-	    } else if (flag_hash) {
-	      s[sz]='.';
-	      s[++sz]='\0';
+	  if (!isnan(d) && !isinf(d)) {		/* skip NaN + INF values */
+	    if (flag_dot) {
+	      char *tmp;
+	      if ((tmp=strchr(s,'.'))) {
+		if (preci || flag_hash) ++tmp;
+		while (preci>0 && *++tmp) --preci;
+		*tmp=0;
+	      } else if (flag_hash) {
+		s[sz]='.';
+		s[++sz]='\0';
+	      }
 	    }
-	  }
 
-	  if (g) {
-	    char *tmp,*tmp1;	/* boy, is _this_ ugly! */
-	    if ((tmp=strchr(s,'.'))) {
-	      tmp1=strchr(tmp,'e');
-	      while (*tmp) ++tmp;
-	      if (tmp1) tmp=tmp1;
-	      while (*--tmp=='0') ;
-	      if (*tmp!='.') ++tmp;
-	      *tmp=0;
-	      if (tmp1) strcpy(tmp,tmp1);
+	    if ((flags&0x01)) {
+	      char *tmp,*tmp1;	/* boy, is _this_ ugly! */
+	      if ((tmp=strchr(s,'.'))) {
+		tmp1=strchr(tmp,'e');
+		while (*tmp) ++tmp;
+		if (tmp1) tmp=tmp1;
+		while (*--tmp=='0') ;
+		if (*tmp!='.') ++tmp;
+		*tmp=0;
+		if (tmp1) strcpy(tmp,tmp1);
+	      }
 	    }
-	  }
 	  
-	  if ((flag_sign || flag_space) && d>=0) {
-	    *(--s)=(flag_sign)?'+':' ';
-	    ++sz;
+	    if ((flag_sign || flag_space) && d>=0) {
+	      *(--s)=(flag_sign)?'+':' ';
+	      ++sz;
+	    }
 	  }
 	  
 	  sz=strlen(s);
diff -urN -x .git dietlibc-0.33/libcompat/rcmd.c dietlibc/libcompat/rcmd.c
--- dietlibc-0.33/libcompat/rcmd.c	2005-05-08 15:33:39.000000000 +0000
+++ dietlibc/libcompat/rcmd.c	2015-01-01 12:14:43.491605562 +0000
@@ -4,6 +4,12 @@
 	 const char *remuser, const char *cmd, int *fd2p);
 int rcmd(char **ahost, int inport, const char *locuser,
 	 const char *remuser, const char *cmd, int *fd2p) {
+  (void)ahost;
+  (void)inport;
+  (void)locuser;
+  (void)remuser;
+  (void)cmd;
+  (void)fd2p;
   __write2("for security reasons, rcmd is not supported by the diet libc.\n");
   return -1;
 }
diff -urN -x .git dietlibc-0.33/libcompat/stpcpy.c dietlibc/libcompat/stpcpy.c
--- dietlibc-0.33/libcompat/stpcpy.c	2002-05-03 21:22:06.000000000 +0000
+++ dietlibc/libcompat/stpcpy.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,6 +0,0 @@
-#include <string.h>
-
-char * stpcpy (char *dst, const char *src) {
-  while ((*dst++ = *src++));
-  return (dst-1);
-}
diff -urN -x .git dietlibc-0.33/libcompat/syscall.S dietlibc/libcompat/syscall.S
--- dietlibc-0.33/libcompat/syscall.S	2006-05-29 16:30:53.000000000 +0000
+++ dietlibc/libcompat/syscall.S	2015-01-01 12:14:43.491605562 +0000
@@ -130,6 +130,13 @@
 	b    __unified_syscall
 
 #else
-		/* arch not implemented yet */
+#include <endian.h>
+	.section	.comment
+#if (__WORDSIZE == 64)
+	.quad		__syscall_2_not_implemented_for_this_arch
+#else
+	.long		__syscall_2_not_implemented_for_this_arch
+#endif
+	.section	.text
 #endif
 .size	syscall, . - syscall
diff -urN -x .git dietlibc-0.33/libcruft/bindtextdomain.c dietlibc/libcruft/bindtextdomain.c
--- dietlibc-0.33/libcruft/bindtextdomain.c	2003-11-14 15:16:51.000000000 +0000
+++ dietlibc/libcruft/bindtextdomain.c	2015-01-01 12:14:43.491605562 +0000
@@ -5,6 +5,7 @@
 static char* dir;
 
 char* bindtextdomain(const char* domainname,const char* dirname) {
+  (void)domainname;
   if (dir) free(dir);
   if (!(dir=strdup(dirname))) return 0;
   return dir;
diff -urN -x .git dietlibc-0.33/libcruft/dcgettext.c dietlibc/libcruft/dcgettext.c
--- dietlibc-0.33/libcruft/dcgettext.c	2003-11-04 18:26:52.000000000 +0000
+++ dietlibc/libcruft/dcgettext.c	2015-01-01 12:14:43.491605562 +0000
@@ -1,5 +1,7 @@
 #include <libintl.h>
 
 char* dcgettext(const char *domainname, const char *msgid, int category) {
+  (void)domainname;
+  (void)category;
   return (char*)msgid;
 }
diff -urN -x .git dietlibc-0.33/libcruft/dgettext.c dietlibc/libcruft/dgettext.c
--- dietlibc-0.33/libcruft/dgettext.c	2003-11-04 18:26:52.000000000 +0000
+++ dietlibc/libcruft/dgettext.c	2015-01-01 12:14:43.491605562 +0000
@@ -1,4 +1,4 @@
 #include <libintl.h>
 
 #undef dgettext
-char* dgettext(const char* domainname, const char* x) { return (char*)x; }
+char* dgettext(const char* domainname, const char* x) { (void)domainname; return (char*)x; }
diff -urN -x .git dietlibc-0.33/libcruft/getpagesize.c dietlibc/libcruft/getpagesize.c
--- dietlibc-0.33/libcruft/getpagesize.c	2009-07-01 00:27:26.000000000 +0000
+++ dietlibc/libcruft/getpagesize.c	2015-01-01 12:14:43.491605562 +0000
@@ -1,25 +1,23 @@
 #include <sys/types.h>
 #include <sys/ipc.h>
 #include <sys/shm.h>
-/* for environ: */
-#include <stdlib.h>
 
-#ifndef PAGE_SIZE
-#define PAGE_SIZE 4096
-#endif
+#include "../dietelfinfo.h"
+#include "../dietpagesize.h"
 
-size_t __libc_getpagesize(void);
 size_t __libc_getpagesize(void) {
-  long* x=(long*)environ;
-  int fd;
-  while (*x) ++x; ++x;	/* skip envp to get to auxvec */
-  while (*x) {
-    if (*x==6)
-      return x[1];
-    x+=2;
+#ifdef WANT_DYN_PAGESIZE
+  static size_t	pgsz;
+
+  if (__unlikely(pgsz==0)) {
+    __diet_elf_addr_t const	*v = __get_elf_aux_value(AT_PAGESZ);
+    pgsz = *v;	/* causes segfault when 'v==NULL' */
   }
-  return PAGE_SIZE;
+
+  return pgsz;
+#else
+  return __DIET_PAGE_SIZE_PREDEF;
+#endif
 }
 
 size_t getpagesize(void)       __attribute__((weak,alias("__libc_getpagesize")));
-
diff -urN -x .git dietlibc-0.33/libcruft/mkstemp.c dietlibc/libcruft/mkstemp.c
--- dietlibc-0.33/libcruft/mkstemp.c	2001-08-16 18:44:17.000000000 +0000
+++ dietlibc/libcruft/mkstemp.c	2015-01-01 12:14:43.494938894 +0000
@@ -1,3 +1,4 @@
+#define _FILE_OFFSET_BITS 64
 #include <unistd.h>
 #include <fcntl.h>
 #include <string.h>
diff -urN -x .git dietlibc-0.33/libcruft/res_mkquery.c dietlibc/libcruft/res_mkquery.c
--- dietlibc-0.33/libcruft/res_mkquery.c	2007-03-09 13:42:12.000000000 +0000
+++ dietlibc/libcruft/res_mkquery.c	2015-01-01 12:14:43.494938894 +0000
@@ -44,12 +44,17 @@
   unsigned char packet[512];
   unsigned long len;
 
+  (void)newrr;
+  (void)data;
+  (void)datalen;
+
   memcpy(packet,dnspacket,12);
   len=rand();
   packet[0]=len;
   packet[1]=len>>8;
   len=0;
   if ((_res.options&RES_RECURSE)==0) packet[2]=0;
+  packet[2] |= (op&7)<<3;
   {
     unsigned char* x;
     const char* y,* tmp;
diff -urN -x .git dietlibc-0.33/libcruft/sysconf.c dietlibc/libcruft/sysconf.c
--- dietlibc-0.33/libcruft/sysconf.c	2012-01-24 18:24:27.000000000 +0000
+++ dietlibc/libcruft/sysconf.c	2015-01-01 12:14:43.494938894 +0000
@@ -6,6 +6,9 @@
 #define _GNU_SOURCE
 #include <sched.h>
 
+#include "dietelfinfo.h"
+#include "dietpagesize.h"
+
 extern int __sc_nr_cpus();
 
 static long physpages() {
@@ -42,6 +45,14 @@
       return limit.rlim_cur;
     }
   case _SC_CLK_TCK:
+#ifdef WANT_ELFINFO
+    {
+      __diet_elf_addr_t const	*v = __get_elf_aux_value(AT_CLKTCK);
+      if (v)
+	return *v;
+    }
+#endif
+
 #ifdef __alpha__
     return 1024;
 #else
@@ -49,11 +60,7 @@
 #endif
 
   case _SC_PAGESIZE:
-#if ( defined(__alpha__) || defined(__sparc__) )
-    return 8192;
-#else
-    return 4096;
-#endif
+    return __libc_getpagesize();
 
   case _SC_PHYS_PAGES:
     return physpages();
diff -urN -x .git dietlibc-0.33/libcruft/tmpnam.c dietlibc/libcruft/tmpnam.c
--- dietlibc-0.33/libcruft/tmpnam.c	2002-02-23 22:18:42.000000000 +0000
+++ dietlibc/libcruft/tmpnam.c	2015-01-01 12:14:43.494938894 +0000
@@ -16,7 +16,7 @@
   if (s) tmp=s; else tmp=buf;
   strcpy(tmp,"/tmp/temp_");
   for (;;) {
-    struct stat s;
+    struct stat ss;
     int i,j;
     i=rand();
     for (j=0; j<8; ++j) {
@@ -25,7 +25,7 @@
       i>>=4;
     }
     tmp[17]=0;
-    if (lstat(tmp,&s)==-1 && errno==ENOENT) break;
+    if (lstat(tmp,&ss)==-1 && errno==ENOENT) break;
   }
   return tmp;
 }
diff -urN -x .git dietlibc-0.33/libm/ceil.c dietlibc/libm/ceil.c
--- dietlibc-0.33/libm/ceil.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/libm/ceil.c	2015-01-01 12:14:43.498272228 +0000
@@ -0,0 +1,92 @@
+/* @(#)s_ceil.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+/*
+ * ceil(x)
+ * Return x rounded toward -inf to integral value
+ * Method:
+ *	Bit twiddling.
+ * Exception:
+ *	Inexact flag raised if x not equal to ceil(x).
+ */
+
+#include <math.h>
+
+typedef union {
+  double value;
+  struct {
+    unsigned int lsw;
+    unsigned int msw;
+  } parts;
+} ieee_double_shape_type;
+
+/* Get two 32 bit ints from a double.  */
+
+#define EXTRACT_WORDS(ix0,ix1,d)                                \
+do {                                                            \
+  ieee_double_shape_type ew_u;                                  \
+  ew_u.value = (d);                                             \
+  (ix0) = ew_u.parts.msw;                                       \
+  (ix1) = ew_u.parts.lsw;                                       \
+} while (0)
+
+#define INSERT_WORDS(d,ix0,ix1)                                 \
+do {                                                            \
+  ieee_double_shape_type iw_u;                                  \
+  iw_u.parts.msw = (ix0);                                       \
+  iw_u.parts.lsw = (ix1);                                       \
+  (d) = iw_u.value;                                             \
+} while (0)
+
+static const double huge = 1.0e300;
+
+double ceil(double x)
+{
+	int i0,i1,j0;
+	unsigned int i,j;
+	EXTRACT_WORDS(i0,i1,x);
+	j0 = ((i0>>20)&0x7ff)-0x3ff;
+	if(j0<20) {
+	    if(j0<0) { 	/* raise inexact if x != 0 */
+		if(huge+x>0.0) {/* return 0*sign(x) if |x|<1 */
+		    if(i0<0) {i0=0x80000000;i1=0;}
+		    else if((i0|i1)!=0) { i0=0x3ff00000;i1=0;}
+		}
+	    } else {
+		i = (0x000fffff)>>j0;
+		if(((i0&i)|i1)==0) return x; /* x is integral */
+		if(huge+x>0.0) {	/* raise inexact flag */
+		    if(i0>0) i0 += (0x00100000)>>j0;
+		    i0 &= (~i); i1=0;
+		}
+	    }
+	} else if (j0>51) {
+	    if(j0==0x400) return x+x;	/* inf or NaN */
+	    else return x;		/* x is integral */
+	} else {
+	    i = ((unsigned int)(0xffffffff))>>(j0-20);
+	    if((i1&i)==0) return x;	/* x is integral */
+	    if(huge+x>0.0) { 		/* raise inexact flag */
+		if(i0>0) {
+		    if(j0==20) i0+=1;
+		    else {
+			j = i1 + (1<<(52-j0));
+			if(j<i1) i0+=1;	/* got a carry */
+			i1 = j;
+		    }
+		}
+		i1 &= (~i);
+	    }
+	}
+	INSERT_WORDS(x,i0,i1);
+	return x;
+}
diff -urN -x .git dietlibc-0.33/libm/gamma.c dietlibc/libm/gamma.c
--- dietlibc-0.33/libm/gamma.c	2005-05-08 15:33:39.000000000 +0000
+++ dietlibc/libm/gamma.c	2015-01-01 12:14:43.498272228 +0000
@@ -33,19 +33,19 @@
 #include <stdlib.h>
 #include <math.h>
 
-#define B0      +            1.0l/   6/ 1/ 2
-#define B1      -            1.0l/  30/ 3/ 4
-#define B2      +            1.0l/  42/ 5/ 6
-#define B3      -            1.0l/  30/ 7/ 8
-#define B4      +            5.0l/  66/ 9/10
-#define B5      -          691.0l/2730/11/12
-#define B6      +            7.0l/   6/13/14
-#define B7      -         3617.0l/ 510/15/16
-#define B8      +        43867.0l/ 798/17/18
-#define B9      -       174611.0l/ 330/19/20
-#define B10     +       854513.0l/ 138/21/22
-#define B11     -    236364091.0l/2730/23/24
-#define B12     +      8553103.0l/   6/25/26
+#define B0      +            1.0/   6/ 1/ 2
+#define B1      -            1.0/  30/ 3/ 4
+#define B2      +            1.0/  42/ 5/ 6
+#define B3      -            1.0/  30/ 7/ 8
+#define B4      +            5.0/  66/ 9/10
+#define B5      -          691.0/2730/11/12
+#define B6      +            7.0/   6/13/14
+#define B7      -         3617.0/ 510/15/16
+#define B8      +        43867.0/ 798/17/18
+#define B9      -       174611.0/ 330/19/20
+#define B10     +       854513.0/ 138/21/22
+#define B11     -    236364091.0/2730/23/24
+#define B12     +      8553103.0/   6/25/26
 
 static const double  coeff[] = { B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10 };
 int                  signgam;
diff -urN -x .git dietlibc-0.33/libpthread/pthread_attr_getscope.c dietlibc/libpthread/pthread_attr_getscope.c
--- dietlibc-0.33/libpthread/pthread_attr_getscope.c	2003-08-18 17:32:52.000000000 +0000
+++ dietlibc/libpthread/pthread_attr_getscope.c	2015-01-01 12:14:43.498272228 +0000
@@ -5,7 +5,7 @@
 #include "thread_internal.h"
 
 int pthread_attr_getscope(const pthread_attr_t*attr,int*scope) {
-  if (0) { attr=0; }
+  (void)attr;
   *scope=PTHREAD_SCOPE_SYSTEM;
   return 0;
 }
diff -urN -x .git dietlibc-0.33/libpthread/pthread_attr_setscope.c dietlibc/libpthread/pthread_attr_setscope.c
--- dietlibc-0.33/libpthread/pthread_attr_setscope.c	2003-08-18 17:32:52.000000000 +0000
+++ dietlibc/libpthread/pthread_attr_setscope.c	2015-01-01 12:14:43.498272228 +0000
@@ -5,7 +5,7 @@
 #include "thread_internal.h"
 
 int pthread_attr_setscope(pthread_attr_t*attr,int scope) {
-  if (0) { attr=0; }
+  (void)attr;
   if (scope==PTHREAD_SCOPE_SYSTEM) return 0;
   if (scope==PTHREAD_SCOPE_PROCESS) return ENOTSUP;
   return EINVAL;
diff -urN -x .git dietlibc-0.33/libpthread/pthread_condattr_getshared.c dietlibc/libpthread/pthread_condattr_getshared.c
--- dietlibc-0.33/libpthread/pthread_condattr_getshared.c	2003-08-18 17:32:53.000000000 +0000
+++ dietlibc/libpthread/pthread_condattr_getshared.c	2015-01-01 12:14:43.498272228 +0000
@@ -5,7 +5,7 @@
 #include "thread_internal.h"
 
 int pthread_condattr_getpshared(const pthread_condattr_t*attr,int*pshared) {
-  if (0) { attr=0; }
+  (void)attr;
   *pshared=PTHREAD_PROCESS_PRIVATE;
   return 0;
 }
diff -urN -x .git dietlibc-0.33/libpthread/pthread_condattr_setshared.c dietlibc/libpthread/pthread_condattr_setshared.c
--- dietlibc-0.33/libpthread/pthread_condattr_setshared.c	2003-08-18 17:32:53.000000000 +0000
+++ dietlibc/libpthread/pthread_condattr_setshared.c	2015-01-01 12:14:43.498272228 +0000
@@ -5,7 +5,7 @@
 #include "thread_internal.h"
 
 int pthread_condattr_setpshared(pthread_condattr_t*attr,int pshared) {
-  if (0) { attr=0; }
+  (void)attr;
   if ((pshared!=PTHREAD_PROCESS_PRIVATE) && (pshared!=PTHREAD_PROCESS_SHARED))
     return EINVAL;
   if (pshared!=PTHREAD_PROCESS_PRIVATE)
diff -urN -x .git dietlibc-0.33/libpthread/pthread_cond_init.c dietlibc/libpthread/pthread_cond_init.c
--- dietlibc-0.33/libpthread/pthread_cond_init.c	2003-08-18 17:32:52.000000000 +0000
+++ dietlibc/libpthread/pthread_cond_init.c	2015-01-01 12:14:43.498272228 +0000
@@ -6,7 +6,7 @@
 #include "thread_internal.h"
 
 int pthread_cond_init(pthread_cond_t*cond,pthread_condattr_t*cond_attr) {
-  if (0) { cond_attr=0; }
+  (void)cond_attr;
   memset(cond,0,sizeof(pthread_cond_t));
   cond->lock.__spinlock=PTHREAD_SPIN_UNLOCKED;
   return 0;
diff -urN -x .git dietlibc-0.33/libpthread/pthread_errno.c dietlibc/libpthread/pthread_errno.c
--- dietlibc-0.33/libpthread/pthread_errno.c	2001-06-09 17:45:50.000000000 +0000
+++ dietlibc/libpthread/pthread_errno.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,5 +0,0 @@
-int errno;
-
-#include "dietwarning.h"
-
-link_warning("errno","\e[1;33;41m>>> your multithreaded code uses errno! <<<\e[0m");
diff -urN -x .git dietlibc-0.33/libpthread/pthread_internal.c dietlibc/libpthread/pthread_internal.c
--- dietlibc-0.33/libpthread/pthread_internal.c	2010-09-25 17:03:27.000000000 +0000
+++ dietlibc/libpthread/pthread_internal.c	2015-01-01 12:14:43.498272228 +0000
@@ -283,7 +283,7 @@
 /* cancel signal */
 static void pthread_handle_sigcancel(int sig,siginfo_t*info,void*arg) {
   _pthread_descr this=__thread_self();
-  if (0) { sig=0; arg=0; }
+  (void)sig; (void)arg;
 #ifdef DEBUG
   printf("pthread_handle_sigcancel(%d): sigcancel %d\n",sig,this->pid);
 #endif
@@ -519,7 +519,7 @@
   struct pollfd pfd;
   _pthread_descr td;
   int n,status;
-  if (0) arg=0;
+  (void)arg;
   pfd.fd=mgr_recv_fd;
   pfd.events=POLLIN;
 
diff -urN -x .git dietlibc-0.33/libpthread/pthread_semaphore_misc.c dietlibc/libpthread/pthread_semaphore_misc.c
--- dietlibc-0.33/libpthread/pthread_semaphore_misc.c	2003-09-17 15:06:10.000000000 +0000
+++ dietlibc/libpthread/pthread_semaphore_misc.c	2015-01-01 12:14:43.498272228 +0000
@@ -6,12 +6,12 @@
 #include "thread_internal.h"
 
 sem_t*sem_open(const char*name,int oflag,...) {
-  if (0) { name=0; oflag=0; }
+  (void)name; (void)oflag;
   _errno_=ENOSYS;
   return 0;
 }
 int sem_close(sem_t*sem) {
-  if (0) sem=0;
+  (void)sem;
   _errno_=ENOSYS;
   return -1;
 }
diff -urN -x .git dietlibc-0.33/libpthread/pthread_spinlock.c dietlibc/libpthread/pthread_spinlock.c
--- dietlibc-0.33/libpthread/pthread_spinlock.c	2003-08-18 17:32:53.000000000 +0000
+++ dietlibc/libpthread/pthread_spinlock.c	2015-01-01 12:14:43.498272228 +0000
@@ -1,11 +1,86 @@
+#define _REENTRANT
+
+#include <errno.h>
+
 #include <time.h>
 
 #include <pthread.h>
 #include "thread_internal.h"
 
+#include <sys/atomic.h>
+#include <sys/futex.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <write12.h>
+
+#define NO_CAS
+
+#ifndef NO_CAS
+int __kernel_supports_futex;
+#endif
+
 void __pthread_lock(struct _pthread_fastlock*lock) {
   int cnt=0;
   struct timespec tm;
+#ifndef NO_CAS
+  if (__kernel_supports_futex==-1) goto old_and_busted;
+  /* if we have CAS, use a futex */
+try_again:
+#if 0
+  if (__atomic_add(&lock->__spinlock,1)==1)
+    /* we now hold the lock, there was no contention */
+    return;
+  __atomic_add(&lock->__spinlock,-1);
+#else
+  {
+    /* slight optimization: if we don't get the lock immediately, busy-loop for a few iterations. */
+    size_t i;
+    for (i=0; i<10; ++i) {
+      if (__CAS(&lock->__spinlock,0,1)==0)
+	/* we now hold the lock, there was no contention */
+	return;
+    }
+  }
+#endif
+  if (__CAS(&lock->__spinlock,1,2)!=1) goto try_again;
+  /* if we got here, we did not get the lock. */
+#if 0
+  {
+    char buf[1024];
+    sprintf(buf,"thread %u goes FUTEX_WAIT (lock now %u)\n",gettid(),lock->__spinlock);
+    write(1,buf,strlen(buf));
+  }
+#endif
+  if (futex(&lock->__spinlock,FUTEX_WAIT,2,NULL,NULL,0)!=0) {
+    switch (*__errno_location()) {
+    case ENOSYS: /* kernel too old */
+      goto old_and_busted;
+    case EWOULDBLOCK: /* when futex() looked, the value was no longer -1 */
+    case EINTR: /* a signal interrupted us */
+    case EDEADLK: /* not in the man page, treat same as EWOULDBLOCK? */
+      break;
+#if 0
+    default:
+      {
+	char buf[100];
+	sprintf(buf,"futex %d",*__errno_location());
+	perror(buf);
+      }
+      exit(1);
+#endif
+    }
+  }
+#if 0
+  else { /* we waited, the other guy left, we got woken up. */
+    char buf[1024];
+    sprintf(buf,"thread %u comes out of FUTEX_WAIT (lock now %u)\n",gettid(),lock->__spinlock);
+    write(1,buf,strlen(buf));
+  }
+#endif
+  goto try_again;
+old_and_busted:
+#endif
   while (__testandset(&lock->__spinlock)) {
     if (cnt<MAX_SPIN_COUNT) {
       sched_yield();
@@ -20,10 +95,33 @@
 }
 
 int __pthread_trylock(struct _pthread_fastlock*lock) {
+#ifndef NO_CAS
+  if (__kernel_supports_futex==-1) goto old_and_busted;
+  /* if we have CAS, use a futex */
+  return __CAS(&lock->__spinlock,0,1)!=0;
+old_and_busted:
+#endif
   return __testandset(&lock->__spinlock);
 }
 
 int __pthread_unlock(struct _pthread_fastlock*lock) {
+#ifndef NO_CAS
+  if (__kernel_supports_futex==-1) goto old_and_busted;
+  /* if we have CAS, use a futex */
+  if (__CAS(&lock->__spinlock,1,0)!=1) {
+    lock->__spinlock=0;
+    futex(&lock->__spinlock,FUTEX_WAKE,1,NULL,NULL,0);
+#if 0
+    {
+      char buf[1024];
+      sprintf(buf,"thread %u calls FUTEX_WAKE (lock now %u)\n",gettid(),lock->__spinlock);
+      write(1,buf,strlen(buf));
+    }
+#endif
+  }
+  return 0;
+old_and_busted:
+#endif
   lock->__spinlock=PTHREAD_SPIN_UNLOCKED;
   return 0;
 }
diff -urN -x .git dietlibc-0.33/libpthread/pthread_sys_fcntl.c dietlibc/libpthread/pthread_sys_fcntl.c
--- dietlibc-0.33/libpthread/pthread_sys_fcntl.c	2003-08-18 17:32:53.000000000 +0000
+++ dietlibc/libpthread/pthread_sys_fcntl.c	2015-01-01 12:14:43.498272228 +0000
@@ -1,7 +1,9 @@
+#define fcntl lib_fcntl
 #include <unistd.h>
 
 #include <pthread.h>
 #include "thread_internal.h"
+#undef fcntl
 
 int fcntl(int fd, int cmd, void *arg);
 int fcntl(int fd, int cmd, void *arg) {
diff -urN -x .git dietlibc-0.33/libregex/rx.c dietlibc/libregex/rx.c
--- dietlibc-0.33/libregex/rx.c	2010-09-25 17:03:27.000000000 +0000
+++ dietlibc/libregex/rx.c	2015-01-01 12:14:43.501605560 +0000
@@ -429,6 +429,12 @@
 }
 
 static int matchempty(void*__restrict__ x,const char*__restrict__ s,int ofs,struct __regex_t*__restrict__ preg,int plus,int eflags) {
+  (void)x;
+  (void)s;
+  (void)ofs;
+  (void)preg;
+  (void)plus;
+  (void)eflags;
   return 0;
 }
 
@@ -450,10 +456,10 @@
     }
 //    printf("b->p from %p to ",b->p);
     {
-      struct piece* tmp;
-      if (!(tmp=realloc(b->p,++b->num*sizeof(p)))) return s;
-//      printf("piece realloc: %p -> %p (%d*%d)\n",b->p,tmp,b->num,sizeof(p));
-      b->p=tmp;
+      struct piece* t;
+      if (!(t=realloc(b->p,++b->num*sizeof(p)))) return s;
+//      printf("piece realloc: %p -> %p (%d*%d)\n",b->p,t,b->num,sizeof(p));
+      b->p=t;
     }
 //    printf("%p (size %d)\n",b->p,b->num*sizeof(p));
     b->p[b->num-1]=p;
@@ -501,10 +507,10 @@
     if (tmp==s && !closebracket(s,p)) return s;
 //    printf("r->b from %p to ",r->b);
     {
-      struct branch* tmp;
-      if (!(tmp=realloc(r->b,++r->num*sizeof(b)))) return s;
-//      printf("branch realloc: %p -> %p (%d*%d)\n",r->b,tmp,r->num,sizeof(b));
-      r->b=tmp;
+      struct branch* t;
+      if (!(t=realloc(r->b,++r->num*sizeof(b)))) return s;
+//      printf("branch realloc: %p -> %p (%d*%d)\n",r->b,t,r->num,sizeof(b));
+      r->b=t;
     }
 //    printf("%p (size %d)\n",r->b,r->num*sizeof(b));
     r->b[r->num-1]=b;
@@ -618,6 +624,8 @@
 }
 
 size_t regerror(int errcode, const regex_t*__restrict__ preg, char*__restrict__ errbuf, size_t errbuf_size) {
+  (void)preg;
+  (void)errcode;
   strncpy(errbuf,"invalid regular expression (sorry)",errbuf_size);
   return strlen(errbuf);
 }
diff -urN -x .git dietlibc-0.33/librpc/auth_none.c dietlibc/librpc/auth_none.c
--- dietlibc-0.33/librpc/auth_none.c	2003-08-19 19:34:18.000000000 +0000
+++ dietlibc/librpc/auth_none.c	2015-01-01 12:14:43.504938894 +0000
@@ -98,6 +98,8 @@
 {
 	register struct authnone_private *ap = authnone_private;
 
+	(void)client;
+
 	if (ap == 0)
 		return (0);
 	return ((*xdrs->x_ops->x_putbytes) (xdrs,
@@ -106,21 +108,24 @@
 
 static void authnone_verf(AUTH *x)
 {
+  (void)x;
 }
 
 static bool_t authnone_validate(AUTH *x, struct opaque_auth *x1)
 {
-
+  (void)x;
+  (void)x1;
 	return (TRUE);
 }
 
 static bool_t authnone_refresh(AUTH *x)
 {
-
+  (void)x;
 	return (FALSE);
 }
 
 static void authnone_destroy(AUTH *x)
 {
+  (void)x;
 }
 
diff -urN -x .git dietlibc-0.33/librpc/auth_unix.c dietlibc/librpc/auth_unix.c
--- dietlibc-0.33/librpc/auth_unix.c	2003-08-19 19:34:18.000000000 +0000
+++ dietlibc/librpc/auth_unix.c	2015-01-01 12:14:43.504938894 +0000
@@ -191,6 +191,7 @@
 static void authunix_nextverf(auth)
 AUTH *auth;
 {
+  (void)auth;
 	/* no action necessary */
 }
 
diff -urN -x .git dietlibc-0.33/librpc/clnt_perror.c dietlibc/librpc/clnt_perror.c
--- dietlibc-0.33/librpc/clnt_perror.c	2003-08-19 19:34:18.000000000 +0000
+++ dietlibc/librpc/clnt_perror.c	2015-01-01 12:14:43.504938894 +0000
@@ -67,6 +67,8 @@
  */
 char *clnt_sperror __P ((CLIENT *rpch, const char *s))
 {
+  (void)rpch;
+  (void)s;
 #if 0
 	struct rpc_err e;
 	void clnt_perrno();
@@ -204,6 +206,7 @@
 char *clnt_sperrno(stat)
 enum clnt_stat stat;
 {
+  (void)stat;
 #if 0
 	int i;
 
@@ -225,6 +228,7 @@
 
 char *clnt_spcreateerror __P ((__const char *s))
 {
+  (void)s;
 #if 0
 	extern int sys_nerr;
 	extern char *sys_errlist[];
diff -urN -x .git dietlibc-0.33/librpc/clnt_raw.c dietlibc/librpc/clnt_raw.c
--- dietlibc-0.33/librpc/clnt_raw.c	2003-08-19 19:34:18.000000000 +0000
+++ dietlibc/librpc/clnt_raw.c	2015-01-01 12:14:43.504938894 +0000
@@ -53,7 +53,10 @@
 	CLIENT client_object;
 	XDR xdr_stream;
 	char _raw_buf[UDPMSGSIZE];
-	char mashl_callmsg[MCALL_MSG_SIZE];
+	union {
+		struct rpc_msg	msg;
+		char buf[MCALL_MSG_SIZE];
+	} mashl_call;
 	unsigned int mcnt;
 } *clntraw_private;
 
@@ -101,7 +104,7 @@
 	call_msg.rm_call.cb_rpcvers = RPC_MSG_VERSION;
 	call_msg.rm_call.cb_prog = prog;
 	call_msg.rm_call.cb_vers = vers;
-	xdrmem_create(xdrs, clp->mashl_callmsg, MCALL_MSG_SIZE, XDR_ENCODE);
+	xdrmem_create(xdrs, clp->mashl_call.buf, MCALL_MSG_SIZE, XDR_ENCODE);
 	if (!xdr_callhdr(xdrs, &call_msg)) {
 		perror("clnt_raw.c - Fatal header serialization error.");
 	}
@@ -137,6 +140,8 @@
 	enum clnt_stat status;
 	struct rpc_err error;
 
+	(void)timeout;
+
 	if (clp == 0)
 		return (RPC_FAILED);
   call_again:
@@ -145,8 +150,8 @@
 	 */
 	xdrs->x_op = XDR_ENCODE;
 	XDR_SETPOS(xdrs, 0);
-	((struct rpc_msg *) clp->mashl_callmsg)->rm_xid++;
-	if ((!XDR_PUTBYTES(xdrs, clp->mashl_callmsg, clp->mcnt)) ||
+	clp->mashl_call.msg.rm_xid++;
+	if ((!XDR_PUTBYTES(xdrs, clp->mashl_call.buf, clp->mcnt)) ||
 		(!XDR_PUTLONG(xdrs, (long *) &proc)) ||
 		(!AUTH_MARSHALL(h->cl_auth, xdrs)) || (!(*xargs) (xdrs, argsp))) {
 		return (RPC_CANTENCODEARGS);
@@ -197,6 +202,8 @@
 
 static void clntraw_geterr(CLIENT *x, struct rpc_err *x1)
 {
+  (void)x;
+  (void)x1;
 }
 
 
@@ -209,6 +216,8 @@
 	register XDR *xdrs = &clp->xdr_stream;
 	bool_t rval;
 
+	(void)cl;
+
 	if (clp == 0) {
 		rval = (bool_t) RPC_FAILED;
 		return (rval);
@@ -223,10 +232,14 @@
 
 static bool_t clntraw_control(CLIENT *x, int x1, char *x2)
 {
+  (void)x;
+  (void)x1;
+  (void)x2;
 	return (FALSE);
 }
 
 static void clntraw_destroy(CLIENT *x)
 {
+  (void)x;
 }
 
diff -urN -x .git dietlibc-0.33/librpc/clnt_udp.c dietlibc/librpc/clnt_udp.c
--- dietlibc-0.33/librpc/clnt_udp.c	2005-05-08 15:33:39.000000000 +0000
+++ dietlibc/librpc/clnt_udp.c	2015-01-01 12:14:43.504938894 +0000
@@ -335,7 +335,7 @@
 		if (inlen < 4)
 			continue;
 		/* see if reply transaction id matches sent id */
-		if (*((uint32_t *) (cu->cu_inbuf)) != *((uint32_t *) (cu->cu_outbuf)))
+		if (memcmp(cu->cu_inbuf, cu->cu_outbuf, 4) != 0)
 			continue;
 		/* we now assume we have the proper reply */
 		break;
diff -urN -x .git dietlibc-0.33/librpc/pmap_rmt.c dietlibc/librpc/pmap_rmt.c
--- dietlibc-0.33/librpc/pmap_rmt.c	2005-05-08 15:33:39.000000000 +0000
+++ dietlibc/librpc/pmap_rmt.c	2015-01-01 12:14:43.504938894 +0000
@@ -158,6 +158,9 @@
 int sock;						/* any valid socket will do */
 char *buf;						/* why allocxate more when we can use existing... */
 {
+  (void)addrs;
+  (void)sock;
+  (void)buf;
 #ifdef __linux__
 	struct sockaddr_in addr;
 
diff -urN -x .git dietlibc-0.33/librpc/svc_auth_unix.c dietlibc/librpc/svc_auth_unix.c
--- dietlibc-0.33/librpc/svc_auth_unix.c	2007-03-09 13:42:12.000000000 +0000
+++ dietlibc/librpc/svc_auth_unix.c	2015-01-01 12:14:43.504938894 +0000
@@ -136,5 +136,7 @@
 struct svc_req *rqst;
 struct rpc_msg *msg;
 {
+  (void)rqst;
+  (void)msg;
 	return (AUTH_REJECTEDCRED);
 }
diff -urN -x .git dietlibc-0.33/librpc/svc_raw.c dietlibc/librpc/svc_raw.c
--- dietlibc-0.33/librpc/svc_raw.c	2003-08-19 19:34:18.000000000 +0000
+++ dietlibc/librpc/svc_raw.c	2015-01-01 12:14:43.504938894 +0000
@@ -91,7 +91,7 @@
 
 static enum xprt_stat svcraw_stat(SVCXPRT *__xprt)
 {
-
+  (void)__xprt;
 	return (XPRT_IDLE);
 }
 
@@ -102,6 +102,8 @@
 	register struct svcraw_private *srp = svcraw_private;
 	register XDR *xdrs;
 
+	(void)xprt;
+
 	if (srp == 0)
 		return (0);
 	xdrs = &srp->xdr_stream;
@@ -119,6 +121,8 @@
 	register struct svcraw_private *srp = svcraw_private;
 	register XDR *xdrs;
 
+	(void)xprt;
+
 	if (srp == 0)
 		return (FALSE);
 	xdrs = &srp->xdr_stream;
@@ -137,6 +141,8 @@
 {
 	register struct svcraw_private *srp = svcraw_private;
 
+	(void)xprt;
+
 	if (srp == 0)
 		return (FALSE);
 	return ((*xdr_args) (&srp->xdr_stream, args_ptr));
@@ -150,6 +156,8 @@
 	register struct svcraw_private *srp = svcraw_private;
 	register XDR *xdrs;
 
+	(void)xprt;
+
 	if (srp == 0)
 		return (FALSE);
 	xdrs = &srp->xdr_stream;
@@ -159,5 +167,6 @@
 
 static void svcraw_destroy(SVCXPRT *__xprt)
 {
+  (void)__xprt;
 }
 
diff -urN -x .git dietlibc-0.33/librpc/svc_tcp.c dietlibc/librpc/svc_tcp.c
--- dietlibc-0.33/librpc/svc_tcp.c	2012-11-02 11:17:28.000000000 +0000
+++ dietlibc/librpc/svc_tcp.c	2015-01-01 12:14:43.504938894 +0000
@@ -232,6 +232,8 @@
 	struct sockaddr_in addr;
 	socklen_t len;
 
+	(void)msg;
+
 	r = (struct tcp_rendezvous *) xprt->xp_p1;
   again:
 	len = sizeof(struct sockaddr_in);
@@ -253,7 +255,7 @@
 
 static enum xprt_stat rendezvous_stat(SVCXPRT *xprt)
 {
-
+  (void)xprt;
 	return (XPRT_IDLE);
 }
 
diff -urN -x .git dietlibc-0.33/librpc/svc_udp.c dietlibc/librpc/svc_udp.c
--- dietlibc-0.33/librpc/svc_udp.c	2005-05-08 15:33:39.000000000 +0000
+++ dietlibc/librpc/svc_udp.c	2015-01-01 12:14:43.504938894 +0000
@@ -160,7 +160,7 @@
 static enum xprt_stat svcudp_stat(xprt)
 SVCXPRT *xprt;
 {
-
+  (void)xprt;
 	return (XPRT_IDLE);
 }
 
diff -urN -x .git dietlibc-0.33/librpc/xdr_array.c dietlibc/librpc/xdr_array.c
--- dietlibc-0.33/librpc/xdr_array.c	2002-07-31 21:42:20.000000000 +0000
+++ dietlibc/librpc/xdr_array.c	2015-01-01 12:14:43.504938894 +0000
@@ -82,9 +82,9 @@
 	}
 	/* duh, look for integer overflow (fefe) */
 	{
-	  unsigned int i;
+	  unsigned int j;
 	  nodesize = 0;
-	  for (i=c; i; --i) {
+	  for (j=c; j; --j) {
 	    unsigned int tmp=nodesize+elsize;
 	    if (tmp<nodesize)	/* overflow */
 	      return FALSE;
diff -urN -x .git dietlibc-0.33/librpc/xdr_mem.c dietlibc/librpc/xdr_mem.c
--- dietlibc-0.33/librpc/xdr_mem.c	2012-11-02 11:17:28.000000000 +0000
+++ dietlibc/librpc/xdr_mem.c	2015-01-01 12:14:43.504938894 +0000
@@ -91,6 +91,7 @@
 static void
 xdrmem_destroy (XDR *xdrs)
 {
+  (void)xdrs;
 }
 
 static bool_t
diff -urN -x .git dietlibc-0.33/librpc/xdr_stdio.c dietlibc/librpc/xdr_stdio.c
--- dietlibc-0.33/librpc/xdr_stdio.c	2003-08-19 19:34:18.000000000 +0000
+++ dietlibc/librpc/xdr_stdio.c	2015-01-01 12:14:43.504938894 +0000
@@ -174,6 +174,8 @@
 
 static int32_t *xdrstdio_inline(XDR* xdrs, unsigned int len)
 {
+  (void)xdrs;
+  (void)len;
 
 	/*
 	 * Must do some work to implement this: must insure
diff -urN -x .git dietlibc-0.33/libstdio/fdglue.c dietlibc/libstdio/fdglue.c
--- dietlibc-0.33/libstdio/fdglue.c	2004-03-02 21:27:19.000000000 +0000
+++ dietlibc/libstdio/fdglue.c	2015-01-01 12:14:43.508272227 +0000
@@ -13,9 +13,9 @@
     switch (*mode) {
     case 0: return f;
     case 'b': break;
-    case 'r': f=O_RDONLY; break;
-    case 'w': f=O_WRONLY|O_CREAT|O_TRUNC; break;
-    case 'a': f=O_WRONLY|O_CREAT|O_APPEND; break;
+    case 'r': f|=O_RDONLY; break;
+    case 'w': f|=O_WRONLY|O_CREAT|O_TRUNC; break;
+    case 'a': f|=O_WRONLY|O_CREAT|O_APPEND; break;
     case '+': f=(f&(~O_WRONLY))|O_RDWR; break;
     }
     ++mode;
diff -urN -x .git dietlibc-0.33/libstdio/fflush.c dietlibc/libstdio/fflush.c
--- dietlibc-0.33/libstdio/fflush.c	2012-11-02 11:17:28.000000000 +0000
+++ dietlibc/libstdio/fflush.c	2015-01-01 12:14:43.508272227 +0000
@@ -17,7 +17,6 @@
   if (stream==0) {
     int res;
     FILE *f;
-    __fflush_stdin();
     __fflush_stdout();
     __fflush_stderr();
     for (res=0, f=__stdio_root; f; f=f->next)
diff -urN -x .git dietlibc-0.33/libstdio/fgets.c dietlibc/libstdio/fgets.c
--- dietlibc-0.33/libstdio/fgets.c	2012-11-02 11:17:28.000000000 +0000
+++ dietlibc/libstdio/fgets.c	2015-01-01 12:14:43.508272227 +0000
@@ -2,7 +2,8 @@
 
 char *fgets_unlocked(char *s, int size, FILE *stream) {
   int l;
-  for (l=0; l<size; ) {
+  if (size<=0) return 0;
+  for (l=0; l+1<size; ) {
     register int c;
     if (l && __likely(stream->bm<stream->bs)) {
       /* try common case first */
@@ -11,17 +12,14 @@
       c=fgetc_unlocked(stream);
       if (__unlikely(c==EOF)) {
 	if (!l) return 0;
-	goto fini;
+	break;
       }
     }
     s[l]=c;
     ++l;
-    if (c=='\n') {
-fini:
-      s[l]=0;
-      break;
-    }
+    if (c=='\n') break;
   }
+  s[l]=0;
   return s;
 }
 
diff -urN -x .git dietlibc-0.33/libstdio/fread.c dietlibc/libstdio/fread.c
--- dietlibc-0.33/libstdio/fread.c	2005-09-28 06:18:44.000000000 +0000
+++ dietlibc/libstdio/fread.c	2015-01-01 12:14:43.508272227 +0000
@@ -3,7 +3,6 @@
 #include <unistd.h>
 
 size_t fread_unlocked(void *ptr, size_t size, size_t nmemb, FILE *stream) {
-  int res;
   unsigned long i,j;
   j=size*nmemb;
   i=0;
@@ -44,6 +43,7 @@
   }
 #endif
   for (; i<j; ++i) {
+    int res;
     res=fgetc_unlocked(stream);
     if (res==EOF)
 exit:
diff -urN -x .git dietlibc-0.33/libugly/asctime.c dietlibc/libugly/asctime.c
--- dietlibc-0.33/libugly/asctime.c	2001-02-01 22:14:06.000000000 +0000
+++ dietlibc/libugly/asctime.c	2015-01-01 12:14:43.508272227 +0000
@@ -1,6 +1,6 @@
 #include <time.h>
 
-static char buf[25];
+static char buf[26];
 
 char *asctime(const struct tm *timeptr) {
   return asctime_r(timeptr,buf);
diff -urN -x .git dietlibc-0.33/libugly/asctime_r.c dietlibc/libugly/asctime_r.c
--- dietlibc-0.33/libugly/asctime_r.c	2001-07-20 13:10:07.000000000 +0000
+++ dietlibc/libugly/asctime_r.c	2015-01-01 12:14:43.508272227 +0000
@@ -9,7 +9,7 @@
 }
 
 char *asctime_r(const struct tm *t, char *buf) {
-  /* "Wed Jun 30 21:49:08 1993\n" */
+  /* "Wed Jun 30 21:49:08 1993\n\0" */
   *(int*)buf=*(int*)(days+(t->tm_wday<<2));
   *(int*)(buf+4)=*(int*)(months+(t->tm_mon<<2));
   num2str(buf+8,t->tm_mday);
@@ -25,5 +25,6 @@
   num2str(buf+20,(t->tm_year+1900)/100);
   num2str(buf+22,(t->tm_year+1900)%100);
   buf[24]='\n';
+  buf[25]='\0';
   return buf;
 }
diff -urN -x .git dietlibc-0.33/libugly/gethostent.c dietlibc/libugly/gethostent.c
--- dietlibc-0.33/libugly/gethostent.c	2003-06-23 10:48:13.000000000 +0000
+++ dietlibc/libugly/gethostent.c	2015-01-01 12:14:43.511605561 +0000
@@ -74,11 +74,11 @@
     while (cur<last && !isspace(*cur)) ++cur;
     {
       char *from=pe->h_aliases[aliasidx];
-      int len=cur-from;
-      if (max-dest<len+2) goto nospace;
+      int l=cur-from;
+      if (max-dest<l+2) goto nospace;
       pe->h_aliases[aliasidx]=dest;
       memmove(dest,from,(size_t)(cur-from));
-      dest+=len;
+      dest+=l;
       *dest=0; ++dest;
     }
     if (*cur=='\n') { ++cur; ++aliasidx; break; }
diff -urN -x .git dietlibc-0.33/libugly/strftime.c dietlibc/libugly/strftime.c
--- dietlibc-0.33/libugly/strftime.c	2012-04-19 16:50:23.000000000 +0000
+++ dietlibc/libugly/strftime.c	2015-01-01 12:14:43.514938893 +0000
@@ -45,46 +45,47 @@
 	    else
 again:
 	    switch (*format) {
-//          case '%': *p++ = '%';  				 break;			// reduce size of jump table
-	    case 'n': *p++ = '\n'; 				 break;
-	    case 't': *p++ = '\t'; 				 break;
+//          case '%': *p++ = '%';  				break;			// reduce size of jump table
+	    case 'n': *p++ = '\n'; 				break;
+	    case 't': *p++ = '\t'; 				break;
 	    case 'O': case 'E': ++format; goto again;
-	    case 'c': src = "%b %a %d %k:%M:%S %Z %Y";        	 goto _strf;
-	    case 'r': src = "%I:%M:%S %p";                    	 goto _strf;
-	    case 'R': src = "%H:%M";      			 goto _strf;
-	    case 'x': src = "%b %a %d";   			 goto _strf;
-	    case 'X': src = "%k:%M:%S";   			 goto _strf;
-	    case 'D': src = "%m/%d/%y";   			 goto _strf;
+	    case 'c': src = "%b %a %d %k:%M:%S %Z %Y";        	goto _strf;
+	    case 'r': src = "%I:%M:%S %p";                    	goto _strf;
+	    case 'R': src = "%H:%M";      			goto _strf;
+	    case 'x': src = "%b %a %d";   			goto _strf;
+	    case 'X': src = "%k:%M:%S";   			goto _strf;
+	    case 'D': src = "%m/%d/%y";   			goto _strf;
+	    case 'F': src = "%Y-%m-%d";				goto _strf;
 	    case 'T': src = "%H:%M:%S";
 	       _strf: p  += strftime (p, (size_t)(dst+max-p), src, tm); 	 break;
-	    case 'a': src = sweekdays [tm->tm_wday]; 		 goto _str;
-	    case 'A': src = weekdays  [tm->tm_wday]; 		 goto _str;
+	    case 'a': src = sweekdays [tm->tm_wday]; 		goto _str;
+	    case 'A': src = weekdays  [tm->tm_wday]; 		goto _str;
 	    case 'h':
-	    case 'b': src = smonths   [tm->tm_mon];  		 goto _str;
-	    case 'B': src = months    [tm->tm_mon];  		 goto _str;
+	    case 'b': src = smonths   [tm->tm_mon];  		goto _str;
+	    case 'B': src = months    [tm->tm_mon];  		goto _str;
 	    case 'p': src = ampm [tm->tm_hour > 12 ? 3 : 2]; goto _str;
 	    case 'P': src = ampm [tm->tm_hour > 12 ? 1 : 0]; goto _str;
-	    case 'C': no  = tm->tm_year/100 + 19; 		 goto _no;
-	    case 'd': no  = tm->tm_mday;          		 goto _no;
-	    case 'e': no  = tm->tm_mday;          		 goto _nos;
-	    case 'H': no  = tm->tm_hour;          		 goto _no;
-	    case 'I': no  = tm->tm_hour % 12;     		 goto _no;
-	    case 'j': no  = tm->tm_yday;          		 goto _no;
-	    case 'k': no  = tm->tm_hour;          		 goto _nos;
-	    case 'l': no  = tm->tm_hour % 12;     		 goto _nos;
-	    case 'm': no  = tm->tm_mon + 1;         		 goto _no;
-	    case 'M': no  = tm->tm_min;           		 goto _no;
-	    case 'S': no  = tm->tm_sec;           		 goto _no;
-	    case 'u': no  = tm->tm_wday ? tm->tm_wday : 7; 	 goto _no;
-	    case 'w': no  = tm->tm_wday;              		 goto _no;
+	    case 'C': no  = tm->tm_year/100 + 19; 		goto _no;
+	    case 'd': no  = tm->tm_mday;          		goto _no;
+	    case 'e': no  = tm->tm_mday;          		goto _nos;
+	    case 'H': no  = tm->tm_hour;          		goto _no;
+	    case 'I': no  = tm->tm_hour % 12;     		goto _no;
+	    case 'j': no  = tm->tm_yday;          		goto _no;
+	    case 'k': no  = tm->tm_hour;          		goto _nos;
+	    case 'l': no  = tm->tm_hour % 12;     		goto _nos;
+	    case 'm': no  = tm->tm_mon + 1;         		goto _no;
+	    case 'M': no  = tm->tm_min;           		goto _no;
+	    case 'S': no  = tm->tm_sec;           		goto _no;
+	    case 'u': no  = tm->tm_wday ? tm->tm_wday : 7; 	goto _no;
+	    case 'w': no  = tm->tm_wday;              		goto _no;
 	    case 'U': no  = (tm->tm_yday - tm->tm_wday + 7) / 7; goto _no;
 	    case 'W': no  = (tm->tm_yday - (tm->tm_wday - 1 + 7) % 7 + 7) / 7; goto _no;
 	    case 's': {
 			time_t t = mktime((struct tm*)tm);
-			char buf[101];
+			char sbuf[101];
 			char* c;
-			buf[100]=0;
-			for (c=buf+99; c>buf; --c) {
+			sbuf[100]=0;
+			for (c=sbuf+99; c>sbuf; --c) {
 			  *c=(t%10)+'0';
 			  t/=10;
 			  if (!t) break;
diff -urN -x .git dietlibc-0.33/libugly/strptime.c dietlibc/libugly/strptime.c
--- dietlibc-0.33/libugly/strptime.c	2008-12-10 20:00:59.000000000 +0000
+++ dietlibc/libugly/strptime.c	2015-01-01 12:14:43.514938893 +0000
@@ -119,10 +119,10 @@
 	++s;
 	break;
       case 'x':
-	s=strptime(s,"%b %a %d",tm);
+	s=strptime(s,"%m/%d/%y",tm);
 	break;
       case 'X':
-	s=strptime(s,"%k:%M:%S",tm);
+	s=strptime(s,"%H:%M:%S",tm);
 	break;
       case 'y':
 	i=getint(&s,2);
diff -urN -x .git dietlibc-0.33/libugly/timegm.c dietlibc/libugly/timegm.c
--- dietlibc-0.33/libugly/timegm.c	2005-01-31 12:53:34.000000000 +0000
+++ dietlibc/libugly/timegm.c	2015-01-01 12:14:43.514938893 +0000
@@ -14,6 +14,7 @@
   if (t->tm_min>60) { t->tm_hour += t->tm_min/60; t->tm_min%=60; }
   if (t->tm_hour>60) { t->tm_mday += t->tm_hour/60; t->tm_hour%=60; }
   if (t->tm_mon>12) { t->tm_year += t->tm_mon/12; t->tm_mon%=12; }
+  if (t->tm_mon<0) t->tm_mon=0;
   while (t->tm_mday>__spm[1+t->tm_mon]) {
     if (t->tm_mon==1 && __isleap(t->tm_year+1900)) {
       if (t->tm_mon==31+29) break;
diff -urN -x .git dietlibc-0.33/linuxnet.h dietlibc/linuxnet.h
--- dietlibc-0.33/linuxnet.h	2001-06-16 17:49:29.000000000 +0000
+++ dietlibc/linuxnet.h	2015-01-01 12:14:43.514938893 +0000
@@ -16,4 +16,7 @@
 #define SYS_GETSOCKOPT	15		/* sys_getsockopt(2)		*/
 #define SYS_SENDMSG	16		/* sys_sendmsg(2)		*/
 #define SYS_RECVMSG	17		/* sys_recvmsg(2)		*/
+#define SYS_ACCEPT4	18		/* sys_accept4(2)		*/
+#define SYS_RECVMMSG	19		/* sys_recvmmsg(2)		*/
+#define SYS_SENDMMSG	20		/* sys_sendmmsg(2)		*/
 
diff -urN -x .git dietlibc-0.33/Makefile dietlibc/Makefile
--- dietlibc-0.33/Makefile	2012-11-02 11:17:28.000000000 +0000
+++ dietlibc/Makefile	2015-01-01 12:14:43.451605563 +0000
@@ -8,7 +8,9 @@
 BINDIR=${prefix}/bin
 MAN1DIR=${prefix}/man/man1
 
-MYARCH:=$(shell uname -m | sed -e 's/i[4-9]86/i386/' -e 's/armv[3-6]t\?e\?[lb]/arm/')
+EXTRACFLAGS=
+
+MYARCH:=$(shell uname -m | sed -e 's/i[4-9]86/i386/' -e 's/armv[3-7]t\?[eh]\?j\?[lb]/arm/')
 
 # This extra-ugly cruft is here so make will not run uname and sed each
 # time it looks at $(OBJDIR).  This alone sped up running make when
@@ -100,10 +102,13 @@
 
 profiling: $(OBJDIR)/libgmon.a $(OBJDIR)/pstart.o
 
-CFLAGS=-pipe -nostdinc
+DEFAULTCFLAGS=-pipe -nostdinc -D_REENTRANT $(EXTRACFLAGS)
+CFLAGS=$(DEFAULTCFLAGS)
 CROSS=
 
 CC=gcc
+CCC=$(CROSS)$(CC)
+STRIP=$(COMMENT) $(CROSS)strip
 INC=-I. -isystem include
 
 VPATH=lib:libstdio:libugly:libcruft:libcrypt:libshell:liblatin1:libcompat:libdl:librpc:libregex:libm:profiling
@@ -128,19 +133,26 @@
 
 LIBGMON_OBJS=$(OBJDIR)/__mcount.o $(OBJDIR)/monitor.o $(OBJDIR)/profil.o
 
+NO_STACK_PROTECTOR=stackgap.o __get_elf_aux_value.o
+
 include $(ARCH)/Makefile.add
 
 LIBMATHOBJ=$(patsubst %,$(OBJDIR)/%,$(LIBMATH))
 
-ifeq ($(CFLAGS),-pipe -nostdinc)
+ifeq ($(CFLAGS),$(DEFAULTCFLAGS))
 CFLAGS+=-O -fomit-frame-pointer
 endif
 
 ifneq ($(DEBUG),)
 CFLAGS = -g
-COMMENT = :
+STRIP = :
+endif
+CFLAGS += -W -Wall -Wextra -Wchar-subscripts -Wmissing-prototypes -Wmissing-declarations -Wno-switch -Wno-unused -Wredundant-decls -Wshadow
+
+ASM_CFLAGS = -Wa,--noexecstack
+ifneq ($(subst clang,fnord,$(CC)),$(CC))
+ASM_CFLAGS += -fno-integrated-as
 endif
-CFLAGS += -W -Wall -Wextra -Wchar-subscripts -Wmissing-prototypes -Wmissing-declarations -Wno-switch -Wno-unused -Wredundant-decls
 
 PWD=$(shell pwd)
 
@@ -155,31 +167,35 @@
 
 % :: %,v
 
-$(OBJDIR)/%: $(OBJDIR)
-
 ifeq ($(CC),tcc)
-$(OBJDIR)/%.o: %.S $(ARCH)/syscalls.h
-	$(CROSS)cpp $(INC) $< | $(CROSS)as -o $@
+$(OBJDIR)/%.o: %.S $(ARCH)/syscalls.h | $(OBJDIR)
+	$(CROSS)cpp $(INC) $< | $(CROSS)as --noexecstack -o $@
 
-$(OBJDIR)/%.o: %.c
+$(OBJDIR)/%.o: %.c | $(OBJDIR)
 	tcc -I. -Iinclude -c $< -o $@
-	$(COMMENT) -$(CROSS)strip -x -R .comment -R .note $@
+	-$(STRIP) -x -R .comment -R .note $@
 else
-$(OBJDIR)/pstart.o: start.S
-	$(CROSS)$(CC) $(INC) $(CFLAGS) -DPROFILING -c $< -o $@
+$(OBJDIR)/pstart.o: start.S | $(OBJDIR)
+	$(CCC) $(INC) $(CFLAGS) $(EXTRACFLAGS) -DPROFILING -c $< $(ASM_CFLAGS) -o $@
+
+$(OBJDIR)/%.o: %.S $(ARCH)/syscalls.h | $(OBJDIR)
+	$(CCC) $(INC) $(CFLAGS) $(EXTRACFLAGS) -c $< $(ASM_CFLAGS) -o $@
 
-$(OBJDIR)/%.o: %.S $(ARCH)/syscalls.h
-	$(CROSS)$(CC) $(INC) $(CFLAGS) -c $< -o $@
+$(OBJDIR)/pthread_%.o: libpthread/pthread_%.c | $(OBJDIR)
+	$(CCC) $(INC) $(CFLAGS) $(EXTRACFLAGS) -c $< -o $@
+	-$(STRIP) -x -R .comment -R .note $@
+$(OBJDIR)/stack_smash_handler2.o:	EXTRACFLAGS:=-fno-omit-frame-pointer
 
-$(OBJDIR)/pthread_%.o: libpthread/pthread_%.c
-	$(CROSS)$(CC) $(INC) $(CFLAGS) -c $< -o $@
-	$(COMMENT) -$(CROSS)strip -x -R .comment -R .note $@
+$(OBJDIR)/%.o: %.c | $(OBJDIR)
+	$(CCC) $(INC) $(CFLAGS) $(EXTRACFLAGS) -c $< -o $@ -D__dietlibc__
+	-$(STRIP) -x -R .comment -R .note $@
 
-$(OBJDIR)/%.o: %.c
-	$(CROSS)$(CC) $(INC) $(CFLAGS) -c $< -o $@ -D__dietlibc__
-	$(COMMENT) -$(CROSS)strip -x -R .comment -R .note $@
+$(addprefix $(OBJDIR)/,$(NO_STACK_PROTECTOR)) \
+$(addprefix $(PICODIR)/,$(NO_STACKPROTECTOR)):	EXTRACFLAGS+=-fno-stack-protector
 endif
 
+
+
 ifeq ($(shell $(CC) -v 2>&1 | grep "gcc version"),gcc version 4.0.0)
 SAFE_CFLAGS=$(shell echo $(CFLAGS)|sed 's/-Os/-O2/')
 SAFER_CFLAGS=$(shell echo $(CFLAGS)|sed 's/-Os/-O/')
@@ -190,8 +206,8 @@
 
 CC+=-D__dietlibc__
 
-$(OBJDIR)/crypt.o: libcrypt/crypt.c
-	$(CROSS)$(CC) $(INC) $(SAFER_CFLAGS) -c $< -o $@
+$(OBJDIR)/crypt.o: libcrypt/crypt.c | $(OBJDIR)
+	$(CCC) $(INC) $(SAFER_CFLAGS) $(EXTRACFLAGS) -c $< -o $@
 
 DIETLIBC_OBJ = $(OBJDIR)/unified.o \
 $(SYSCALLOBJ) $(LIBOBJ) $(LIBSTDIOOBJ) $(LIBUGLYOBJ) \
@@ -205,9 +221,9 @@
 $(OBJDIR)/librpc.a: $(LIBRPCOBJ)
 	$(CROSS)ar cru $@ $(LIBRPCOBJ)
 
-$(OBJDIR)/libcrypt.a:
+$(OBJDIR)/libcrypt.a: | $(OBJDIR)
 	touch dummy.c
-	$(CROSS)$(CC) -c dummy.c
+	$(CCC) -c dummy.c
 	$(CROSS)ar cru $@ dummy.o
 	rm -f dummy.c dummy.o
 
@@ -242,23 +258,23 @@
 	$(PICODIR)/libpthread.so $(PICODIR)/libdl.so $(PICODIR)/libcompat.so \
 	$(PICODIR)/libm.so $(PICODIR)/diet-dyn $(PICODIR)/diet-dyn-i
 
-$(PICODIR)/%.o: %.S $(ARCH)/syscalls.h
-	$(CROSS)$(CC) $(INC) $(CFLAGS) -fPIC -D__DYN_LIB -c $< -o $@
+$(PICODIR)/%.o: %.S $(ARCH)/syscalls.h | $(PICODIR)
+	$(CCC) $(INC) $(CFLAGS) $(EXTRACFLAGS) -fPIC -D__DYN_LIB $(ASM_CFLAGS) -c $< -o $@
 
-$(PICODIR)/pthread_%.o: libpthread/pthread_%.c
-	$(CROSS)$(CC) $(INC) $(CFLAGS) -fPIC -D__DYN_LIB -c $< -o $@
-	$(COMMENT) $(CROSS)strip -x -R .comment -R .note $@
-
-$(PICODIR)/%.o: %.c
-	$(CROSS)$(CC) $(INC) $(CFLAGS) -fPIC -D__DYN_LIB -c $< -o $@
-	$(COMMENT) $(CROSS)strip -x -R .comment -R .note $@
-
-$(PICODIR)/dstart.o: start.S
-	$(CROSS)$(CC) $(INC) $(CFLAGS) -fPIC -D__DYN_LIB -c $< -o $@
-
-$(PICODIR)/dyn_so_start.o: dyn_start.c
-	$(CROSS)$(CC) $(INC) $(CFLAGS) -fPIC -D__DYN_LIB -D__DYN_LIB_SHARED -c $< -o $@
-	$(COMMENT) $(CROSS)strip -x -R .comment -R .note $@
+$(PICODIR)/pthread_%.o: libpthread/pthread_%.c | $(PICODIR)
+	$(CCC) $(INC) $(CFLAGS) $(EXTRACFLAGS) -fPIC -D__DYN_LIB -c $< -o $@
+	$(STRIP) -x -R .comment -R .note $@
+
+$(PICODIR)/%.o: %.c | $(PICODIR)
+	$(CCC) $(INC) $(CFLAGS) $(EXTRACFLAGS) -fPIC -D__DYN_LIB -c $< -o $@
+	$(STRIP) -x -R .comment -R .note $@
+
+$(PICODIR)/dstart.o: start.S | $(PICODIR)
+	$(CCC) $(INC) $(CFLAGS) $(EXTRACFLAGS) -fPIC -D__DYN_LIB $(ASM_CFLAGS) -c $< -o $@
+
+$(PICODIR)/dyn_so_start.o: dyn_start.c | $(PICODIR)
+	$(CCC) $(INC) $(CFLAGS) $(EXTRACFLAGS) -fPIC -D__DYN_LIB -D__DYN_LIB_SHARED -c $< -o $@
+	$(STRIP) -x -R .comment -R .note $@
 
 DYN_LIBC_PIC = $(LIBOBJ) $(LIBSTDIOOBJ) $(LIBUGLYOBJ) \
 $(LIBCRUFTOBJ) $(LIBCRYPTOBJ) $(LIBSHELLOBJ) $(LIBREGEXOBJ)
@@ -274,55 +290,55 @@
 
 DYN_LIBMATH_OBJS = $(patsubst $(OBJDIR)/%.o,$(PICODIR)/%.o,$(LIBMATHOBJ))
 
-$(PICODIR)/libc.so: $(PICODIR) $(DYN_LIBC_OBJ)
-	$(LD_UNSET) $(CROSS)$(CC) -nostdlib -shared -o $@ $(CFLAGS) -fPIC $(DYN_LIBC_OBJ) -lgcc -Wl,-soname=libc.so
+$(PICODIR)/libc.so: $(DYN_LIBC_OBJ)
+	$(LD_UNSET) $(CCC) -nostdlib -shared -o $@ $(CFLAGS) -fPIC $(DYN_LIBC_OBJ) -lgcc -Wl,-soname=libc.so
 
-$(PICODIR)/libpthread.so: $(DYN_PTHREAD_OBJS) dietfeatures.h
-	$(LD_UNSET) $(CROSS)$(CC) -nostdlib -shared -o $@ $(CFLAGS) -fPIC $(DYN_PTHREAD_OBJS) -L$(PICODIR) -lc -Wl,-soname=libpthread.so
+$(PICODIR)/libpthread.so: $(DYN_PTHREAD_OBJS) dietfeatures.h $(PICODIR)/libc.so
+	$(LD_UNSET) $(CCC) -nostdlib -shared -o $@ $(CFLAGS) -fPIC $(DYN_PTHREAD_OBJS) -L$(PICODIR) -lc -Wl,-soname=libpthread.so
 
-$(PICODIR)/libdl.so: libdl/_dl_main.c dietfeatures.h
-	$(LD_UNSET) $(CROSS)$(CC) -D__OD_CLEAN_ROOM -DNODIETREF -fPIC -nostdlib -shared -Bsymbolic -Wl,-Bsymbolic \
+$(PICODIR)/libdl.so: libdl/_dl_main.c dietfeatures.h $(PICODIR)/libc.so
+	$(LD_UNSET) $(CCC) -D__OD_CLEAN_ROOM -DNODIETREF -fPIC -nostdlib -shared -Bsymbolic -Wl,-Bsymbolic \
 		-o $@ $(SAFE_CFLAGS) $(INC) libdl/_dl_main.c -Wl,-soname=libdl.so
 
 $(OBJDIR)/pthread_create.o $(PICODIR)/pthread_create.o: dietfeatures.h
 $(OBJDIR)/pthread_internal.o $(PICODIR)/pthread_internal.o: dietfeatures.h
 
 #$(PICODIR)/libdl.so: $(DYN_LIBDL_OBJS) dietfeatures.h
-#	$(CROSS)$(CC) -nostdlib -shared -o $@ $(CFLAGS) -fPIC $(DYN_LIBDL_OBJS) -L$(PICODIR) -ldietc -Wl,-soname=libdl.so
+#	$(CCC) -nostdlib -shared -o $@ $(CFLAGS) -fPIC $(DYN_LIBDL_OBJS) -L$(PICODIR) -ldietc -Wl,-soname=libdl.so
 
-$(PICODIR)/libcompat.so: $(DYN_LIBCOMPAT_OBJS) dietfeatures.h
-	$(LD_UNSET) $(CROSS)$(CC) -nostdlib -shared -o $@ $(CFLAGS) -fPIC $(DYN_LIBCOMPAT_OBJS) -L$(PICODIR) -lc -Wl,-soname=libcompat.so
+$(PICODIR)/libcompat.so: $(DYN_LIBCOMPAT_OBJS) dietfeatures.h $(PICODIR)/libc.so
+	$(LD_UNSET) $(CCC) -nostdlib -shared -o $@ $(CFLAGS) -fPIC $(DYN_LIBCOMPAT_OBJS) -L$(PICODIR) -lc -Wl,-soname=libcompat.so
 
-$(PICODIR)/libm.so: $(DYN_LIBMATH_OBJS) dietfeatures.h
-	$(LD_UNSET) $(CROSS)$(CC) -nostdlib -shared -o $@ $(CFLAGS) -fPIC $(DYN_LIBMATH_OBJS) -L$(PICODIR) -lc -Wl,-soname=libm.so
+$(PICODIR)/libm.so: $(DYN_LIBMATH_OBJS) dietfeatures.h $(PICODIR)/libc.so
+	$(LD_UNSET) $(CCC) -nostdlib -shared -o $@ $(CFLAGS) -fPIC $(DYN_LIBMATH_OBJS) -L$(PICODIR) -lc -Wl,-soname=libm.so
 
 
 $(SYSCALLOBJ): syscalls.h
 
 $(OBJDIR)/elftrunc: $(OBJDIR)/diet contrib/elftrunc.c
-	bin-$(MYARCH)/diet $(CROSS)$(CC) $(CFLAGS) -o $@ contrib/elftrunc.c
+	bin-$(MYARCH)/diet $(CCC) $(CFLAGS) -o $@ contrib/elftrunc.c
 
 $(OBJDIR)/dnsd: $(OBJDIR)/diet contrib/dnsd.c
-	bin-$(MYARCH)/diet $(CROSS)$(CC) $(CFLAGS) -o $@ contrib/dnsd.c
+	bin-$(MYARCH)/diet $(CCC) $(CFLAGS) -o $@ contrib/dnsd.c
 
 VERSION=dietlibc-$(shell head -n 1 CHANGES|sed 's/://')
 CURNAME=$(notdir $(shell pwd))
 
 $(OBJDIR)/diet: $(OBJDIR)/start.o $(OBJDIR)/dyn_start.o diet.c $(OBJDIR)/dietlibc.a $(OBJDIR)/dyn_stop.o
-	$(CROSS)$(CC) -isystem include $(CFLAGS) -nostdlib -o $@ $^ -DDIETHOME=\"$(HOME)\" -DVERSION=\"$(VERSION)\" -lgcc
-	$(CROSS)strip -R .comment -R .note $@
+	$(CCC) -isystem include $(CFLAGS) -nostdlib -o $@ $^ -DDIETHOME=\"$(HOME)\" -DVERSION=\"$(VERSION)\" -lgcc
+	$(STRIP) -R .comment -R .note $@
 
 $(OBJDIR)/diet-i: $(OBJDIR)/start.o $(OBJDIR)/dyn_start.o diet.c $(OBJDIR)/dietlibc.a $(OBJDIR)/dyn_stop.o
-	$(CROSS)$(CC) -isystem include $(CFLAGS) -nostdlib -o $@ $^ -DDIETHOME=\"$(prefix)\" -DVERSION=\"$(VERSION)\" -DINSTALLVERSION -lgcc
-	$(CROSS)strip -R .comment -R .note $@
+	$(CCC) -isystem include $(CFLAGS) -nostdlib -o $@ $^ -DDIETHOME=\"$(prefix)\" -DVERSION=\"$(VERSION)\" -DINSTALLVERSION -lgcc
+	$(STRIP) -R .comment -R .note $@
 
 $(PICODIR)/diet-dyn: $(PICODIR)/start.o $(PICODIR)/dyn_start.o diet.c
-	$(LD_UNSET) $(CROSS)$(CC) -isystem include $(CFLAGS) -fPIC -nostdlib -o $@ $^ -DDIETHOME=\"$(HOME)\" -D__DYN_LIB -DVERSION=\"$(VERSION)\" -L$(PICODIR) -lc -lgcc $(PICODIR)/dyn_stop.o -Wl,-dynamic-linker=$(HOME)/$(PICODIR)/libdl.so
-	$(CROSS)strip -R .command -R .note $@
+	$(LD_UNSET) $(CCC) -isystem include $(CFLAGS) -fPIC -nostdlib -o $@ $^ -DDIETHOME=\"$(HOME)\" -D__DYN_LIB -DVERSION=\"$(VERSION)\" -L$(PICODIR) -lc -lgcc $(PICODIR)/dyn_stop.o -Wl,-dynamic-linker=$(HOME)/$(PICODIR)/libdl.so
+	$(STRIP) -R .command -R .note $@
 
 $(PICODIR)/diet-dyn-i: $(PICODIR)/start.o $(PICODIR)/dyn_start.o diet.c
-	$(LD_UNSET) $(CROSS)$(CC) -isystem include $(CFLAGS) -fPIC -nostdlib -o $@ $^ -DDIETHOME=\"$(prefix)\" -D__DYN_LIB -DVERSION=\"$(VERSION)\" -L$(PICODIR) -lc -lgcc $(PICODIR)/dyn_stop.o -Wl,-dynamic-linker=$(ILIBDIR)/libdl.so -DINSTALLVERSION
-	$(CROSS)strip -R .command -R .note $@
+	$(LD_UNSET) $(CCC) -isystem include $(CFLAGS) -fPIC -nostdlib -o $@ $^ -DDIETHOME=\"$(prefix)\" -D__DYN_LIB -DVERSION=\"$(VERSION)\" -L$(PICODIR) -lc -lgcc $(PICODIR)/dyn_stop.o -Wl,-dynamic-linker=$(ILIBDIR)/libdl.so -DINSTALLVERSION
+	$(STRIP) -R .command -R .note $@
 
 $(OBJDIR)/djb: $(OBJDIR)/compile $(OBJDIR)/load
 
@@ -335,7 +351,7 @@
 	chmod 755 $@
 
 clean:
-	rm -f *.o *.a t t1 compile load elftrunc exports mapfile libdietc.so
+	rm -f *.o *.a t t1 compile load elftrunc exports mapfile libdietc.so include/errno_definition.h
 	rm -rf bin-* pic-*
 	$(MAKE) -C examples clean
 	$(MAKE) -C dynlinker clean
@@ -352,14 +368,14 @@
 
 .PHONY: t t1
 t:
-	$(CROSS)$(CC) -g $(CFLAGS) -fno-builtin -nostdlib -isystem include -o t t.c $(OBJDIR)/start.o $(OBJDIR)/dyn_start.o $(OBJDIR)/dietlibc.a -lgcc $(OBJDIR)/dyn_stop.o -Wl,-Map,mapfile
+	$(CCC) -g $(CFLAGS) -fno-builtin -nostdlib -isystem include -o t t.c $(OBJDIR)/start.o $(OBJDIR)/dyn_start.o $(OBJDIR)/dietlibc.a -lgcc $(OBJDIR)/dyn_stop.o -Wl,-Map,mapfile
 
 t1:
-	$(CROSS)$(CC) -g -o t1 t.c
+	$(CCC) -g -o t1 t.c
 
 install-bin: $(OBJDIR)/start.o $(OBJDIR)/dietlibc.a $(OBJDIR)/librpc.a $(OBJDIR)/liblatin1.a $(OBJDIR)/libcompat.a $(OBJDIR)/elftrunc $(OBJDIR)/diet-i
 	$(INSTALL) -d $(DESTDIR)$(ILIBDIR) $(DESTDIR)$(MAN1DIR) $(DESTDIR)$(BINDIR)
-	$(INSTALL) $(OBJDIR)/start.o $(DESTDIR)$(ILIBDIR)/start.o
+	$(INSTALL) -m 644 $(OBJDIR)/start.o $(OBJDIR)/dyn_start.o $(OBJDIR)/dyn_stop.o $(DESTDIR)$(ILIBDIR)/
 	$(INSTALL) -m 644 $(OBJDIR)/libm.a $(OBJDIR)/libpthread.a $(OBJDIR)/librpc.a \
 $(OBJDIR)/liblatin1.a $(OBJDIR)/libcompat.a $(OBJDIR)/libcrypt.a $(DESTDIR)$(ILIBDIR)
 	$(INSTALL) -m 644 $(OBJDIR)/dietlibc.a $(DESTDIR)$(ILIBDIR)/libc.a
@@ -371,7 +387,7 @@
 	$(INSTALL) -m 644 diet.1 $(DESTDIR)$(MAN1DIR)/diet.1
 
 install-profiling:
-	-$(INSTALL) $(OBJDIR)/pstart.o $(OBJDIR)/libgmon.a $(OBJDIR)/dyn_start.o $(OBJDIR)/dyn_stop.o $(DESTDIR)$(ILIBDIR)
+	-$(INSTALL) $(OBJDIR)/pstart.o $(OBJDIR)/libgmon.a $(DESTDIR)$(ILIBDIR)
 
 install-pic:
 	-$(INSTALL) $(PICODIR)/libc.so $(DESTDIR)$(ILIBDIR)/libc.so
@@ -445,6 +461,10 @@
 cross:
 	$(MAKE) $(subst $(ARCH),,$(CROSS_ARCH))
 
+# DOES NOT WORK YET
+mips64:
+	ARCH=mips64 CROSS=mips64-linux- CC="gcc -mabi=64"
+
 
 # these depend on dietfeatures.h for large file backward compatibility
 $(OBJDIR)/__fstat64.o $(OBJDIR)/__lstat64.o $(OBJDIR)/__stat64.o $(OBJDIR)/lseek64.o $(OBJDIR)/readdir64.o $(OBJDIR)/stat64.o $(OBJDIR)/lstat64.o $(OBJDIR)/fstat64.o $(OBJDIR)/truncate64.o $(OBJDIR)/__truncate64.o $(OBJDIR)/ftruncate64.o $(OBJDIR)/__ftruncate64.o $(OBJDIR)/sendfile64.o $(OBJDIR)/__sendfile64.o $(PICODIR)/dyn_syscalls.o $(PICODIR)/__truncate64.o $(PICODIR)/__ftruncate64.o $(PICODIR)/__stat64.o $(PICODIR)/__lstat64.o $(PICODIR)/__fstat64.o $(OBJDIR)/__sendfile64.o $(OBJDIR)/fstatfs64.o $(OBJDIR)/statfs64.o: dietfeatures.h
@@ -519,6 +539,10 @@
 # these depend on dietfeatures.h for WANT_INET_ADDR_DNS
 $(OBJDIR)/gethostbyname_r.o: dietfeatures.h
 
+# these depend on dietfeatures.h for WANT_VALGRIND_SUPPORT
+bin-x86_64/strlen.o bin-x86_64/memchr.o bin-x86_64/gettimeofday.o: dietfeatures.h
+bin-x32/strlen.o bin-x32/memchr.o bin-x32/gettimeofday.o: dietfeatures.h
+
 # WANT_PLUGPLAY_DNS
 $(OBJDIR)/getaddrinfo.o: dietfeatures.h
 
@@ -531,11 +555,84 @@
 # WANT_LARGEFILE_BACKCOMPAT
 $(OBJDIR)/fcntl64.o: dietfeatures.h
 
-# WANT_SSP
-# This facepalm brought to you by: Ubuntu!
-$(OBJDIR)/stackgap.o: lib/stackgap.c dietfeatures.h
-	$(CROSS)$(CC) $(INC) $(CFLAGS) -c lib/stackgap.c -o $@ -D__dietlibc__ -fno-stack-protector
-	$(COMMENT) -$(CROSS)strip -x -R .comment -R .note $@
-
 # WANT_MALLOC_ZERO
 $(OBJDIR)/strndup.o: dietfeatures.h
+
+# dietdirent.h dependencies
+$(OBJDIR)/closedir.o $(OBJDIR)/fdopendir.o $(OBJDIR)/ftw.o $(OBJDIR)/ftw64.o $(OBJDIR)/opendir.o $(OBJDIR)/readdir.o $(OBJDIR)/readdir64.o $(OBJDIR)/readdir_r.o $(OBJDIR)/rewinddir.o $(OBJDIR)/seekdir.o $(OBJDIR)/telldir.o $(OBJDIR)/dirfd.o: dietdirent.h
+
+$(OBJDIR)/thrd_%.o: include/thread.h
+
+$(OBJDIR)/__fcntl64.o $(OBJDIR)/__fstat64.o $(OBJDIR)/__fstatfs64.o $(OBJDIR)/__ftruncate64.o \
+$(OBJDIR)/__getcwd.o $(OBJDIR)/__lstat64.o $(OBJDIR)/__mmap.o $(OBJDIR)/__ptrace.o \
+$(OBJDIR)/__sendfile64.o $(OBJDIR)/__stat64.o $(OBJDIR)/__statfs64.o $(OBJDIR)/__stime.o \
+$(OBJDIR)/__truncate64.o $(OBJDIR)/__utmp_io.o $(OBJDIR)/__v_printf.o $(OBJDIR)/addmntent.o \
+$(OBJDIR)/alloc.o $(OBJDIR)/bindresvport.o $(OBJDIR)/cfsetispeed.o $(OBJDIR)/cfsetospeed.o \
+$(OBJDIR)/clnt_generic.o $(OBJDIR)/clnt_tcp.o $(OBJDIR)/clnt_udp.o $(OBJDIR)/cnd_timedwait.o \
+$(OBJDIR)/cnd_wait.o $(OBJDIR)/confstr.o $(OBJDIR)/dnscruft2.o $(OBJDIR)/dnsd.o \
+$(OBJDIR)/err.o $(OBJDIR)/errno_location.o $(OBJDIR)/errx.o $(OBJDIR)/execl.o \
+$(OBJDIR)/execle.o $(OBJDIR)/execlp.o $(OBJDIR)/execv.o $(OBJDIR)/execvp.o \
+$(OBJDIR)/fdglue.o $(OBJDIR)/fdglue2.o $(OBJDIR)/fdopen.o $(OBJDIR)/freopen.o \
+$(OBJDIR)/ftell.o $(OBJDIR)/fwrite.o $(OBJDIR)/getdelim.o $(OBJDIR)/gethostbyaddr.o \
+$(OBJDIR)/gethostbyaddr_r.o $(OBJDIR)/gethostbyname.o $(OBJDIR)/gethostbyname2.o \
+$(OBJDIR)/gethostbyname2_r.o $(OBJDIR)/gethostbyname_r.o $(OBJDIR)/gethostent.o \
+$(OBJDIR)/getpass.o $(OBJDIR)/glob.o $(OBJDIR)/herrno_location.o $(OBJDIR)/iconv.o \
+$(OBJDIR)/iconv_open.o $(OBJDIR)/inet_pton.o $(OBJDIR)/isatty.o $(OBJDIR)/lockf.o \
+$(OBJDIR)/logging.o $(OBJDIR)/lseek64.o $(OBJDIR)/mbrlen.o $(OBJDIR)/mbrtowc.o \
+$(OBJDIR)/mkdtemp.o $(OBJDIR)/mkstemp.o $(OBJDIR)/mktemp.o $(OBJDIR)/mmap64.o \
+$(OBJDIR)/mtx_lock.o $(OBJDIR)/mtx_timedlock.o $(OBJDIR)/mtx_trylock.o \
+$(OBJDIR)/mtx_unlock.o $(OBJDIR)/netent.o $(OBJDIR)/nice.o $(OBJDIR)/openpty.o \
+$(OBJDIR)/perror.o $(OBJDIR)/pmap_getmaps.o $(OBJDIR)/pmap_rmt.o \
+$(OBJDIR)/pthread_atfork.o $(OBJDIR)/pthread_attr_getdetachstate.o \
+$(OBJDIR)/pthread_attr_getinheritsched.o $(OBJDIR)/pthread_attr_getschedparam.o \
+$(OBJDIR)/pthread_attr_getschedpolicy.o $(OBJDIR)/pthread_attr_getscope.o \
+$(OBJDIR)/pthread_attr_getstackaddr.o $(OBJDIR)/pthread_attr_getstacksize.o \
+$(OBJDIR)/pthread_attr_setdetachstate.o $(OBJDIR)/pthread_attr_setinheritsched.o \
+$(OBJDIR)/pthread_attr_setschedparam.o $(OBJDIR)/pthread_attr_setschedpolicy.o \
+$(OBJDIR)/pthread_attr_setscope.o $(OBJDIR)/pthread_attr_setstackaddr.o \
+$(OBJDIR)/pthread_attr_setstacksize.o $(OBJDIR)/pthread_cleanup.o \
+$(OBJDIR)/pthread_cond_broadcast.o $(OBJDIR)/pthread_cond_destroy.o \
+$(OBJDIR)/pthread_cond_init.o $(OBJDIR)/pthread_cond_signal.o \
+$(OBJDIR)/pthread_cond_timedwait.o $(OBJDIR)/pthread_cond_wait.o \
+$(OBJDIR)/pthread_condattr_getshared.o $(OBJDIR)/pthread_condattr_setshared.o \
+$(OBJDIR)/pthread_create.o $(OBJDIR)/pthread_detach.o $(OBJDIR)/pthread_fdglue2.o \
+$(OBJDIR)/pthread_internal.o $(OBJDIR)/pthread_join.o $(OBJDIR)/pthread_key.o \
+$(OBJDIR)/pthread_mutex_destroy.o $(OBJDIR)/pthread_mutex_init.o \
+$(OBJDIR)/pthread_mutex_lock.o $(OBJDIR)/pthread_mutex_trylock.o \
+$(OBJDIR)/pthread_mutex_unlock.o $(OBJDIR)/pthread_mutexattr_getkind_np.o \
+$(OBJDIR)/pthread_mutexattr_init.o $(OBJDIR)/pthread_mutexattr_setkind_np.o \
+$(OBJDIR)/pthread_semaphore_destroy.o $(OBJDIR)/pthread_semaphore_getvalue.o \
+$(OBJDIR)/pthread_semaphore_init.o $(OBJDIR)/pthread_semaphore_misc.o \
+$(OBJDIR)/pthread_semaphore_post.o $(OBJDIR)/pthread_semaphore_trywait.o \
+$(OBJDIR)/pthread_semaphore_wait.o $(OBJDIR)/pthread_setcancelstate.o \
+$(OBJDIR)/pthread_setschedparam.o $(OBJDIR)/pthread_spinlock.o \
+$(OBJDIR)/putenv.o $(OBJDIR)/putpwent.o $(OBJDIR)/readdir64.o \
+$(OBJDIR)/realpath.o $(OBJDIR)/remove.o $(OBJDIR)/res_mkquery.o \
+$(OBJDIR)/res_query.o $(OBJDIR)/res_search.o $(OBJDIR)/sigaddset.o \
+$(OBJDIR)/sigdelset.o $(OBJDIR)/sigismember.o $(OBJDIR)/signalfd.o \
+$(OBJDIR)/strerror.o $(OBJDIR)/strtol.o $(OBJDIR)/strtoll.o \
+$(OBJDIR)/strtoul.o $(OBJDIR)/strtoull.o $(OBJDIR)/svc.o \
+$(OBJDIR)/svc_run.o $(OBJDIR)/svc_tcp.o $(OBJDIR)/svc_udp.o \
+$(OBJDIR)/sysconf.o $(OBJDIR)/sysconf_cpus.o $(OBJDIR)/system.o \
+$(OBJDIR)/tcflow.o $(OBJDIR)/tcsendbreak.o $(OBJDIR)/tcsetattr.o \
+$(OBJDIR)/tempnam.o $(OBJDIR)/thrd_exit.o $(OBJDIR)/thrd_join.o \
+$(OBJDIR)/tmpnam.o $(OBJDIR)/utxent.o $(OBJDIR)/verr.o \
+$(OBJDIR)/verrx.o $(OBJDIR)/vwarn.o $(OBJDIR)/warn.o \
+$(OBJDIR)/wcsrtombs.o $(OBJDIR)/wcstombs.o: include/errno_definition.h
+
+$(OBJDIR)/abort.o $(OBJDIR)/pselect.o $(OBJDIR)/__utmp_block_signals.o \
+$(OBJDIR)/system.o $(OBJDIR)/utxent.o $(OBJDIR)/sigemptyset.o \
+$(OBJDIR)/sigorset.o $(OBJDIR)/sigandset.o $(OBJDIR)/sigfillset.o \
+$(OBJDIR)/sigisemptyset.o: include/signal.h
+
+include/errno_definition.h: dietfeatures.h
+	if grep -q '^#define WANT_TLS' $<; then echo "extern __thread int errno;"; else echo "extern int errno;"; fi > $@
+
+ldso: ldso.c
+	gcc -nostdlib -shared -g -DIN_LDSO -Iinclude.ldso -I. -isystem include x86_64/start.S -o ldso ldso.c -fPIC x86_64/dyn_syscalls.S lib/errno_location.c -D__thread=
+
+GIT_CVSIMPORT=git cvsimport
+CVS_EXTRA_bigo.ensc.de=;proxy=www-cache;proxyport=3128
+CVS_EXTRA=$(CVS_EXTRA_$(shell hostname -d))
+cvsimport:
+	$(GIT_CVSIMPORT) -k -p '--cvs-direct' -d ':pserver$(CVS_EXTRA):cvs@cvs.fefe.de:/cvs' dietlibc
diff -urN -x .git dietlibc-0.33/mips/Makefile.add dietlibc/mips/Makefile.add
--- dietlibc-0.33/mips/Makefile.add	2012-01-24 18:24:27.000000000 +0000
+++ dietlibc/mips/Makefile.add	2015-01-01 12:14:43.514938893 +0000
@@ -9,6 +9,10 @@
 ifeq ($(CROSS),mips-linux-)
 ENDIAN=-meb
 endif
+ifeq ($(CC),gcc -mabi=64)
+CFLAGS+=$(ENDIAN) -Os -march=mips64
+else
 CFLAGS+=$(ENDIAN) -Os -march=mips2
+endif
 VPATH:=mips:syscalls.s:$(VPATH)
 LIBOBJ+=$(OBJDIR)/pread64.o $(OBJDIR)/pwrite64.o $(OBJDIR)/divdi3.o $(OBJDIR)/__CAS.o
diff -urN -x .git dietlibc-0.33/mips/start.S dietlibc/mips/start.S
--- dietlibc-0.33/mips/start.S	2006-05-29 16:30:53.000000000 +0000
+++ dietlibc/mips/start.S	2015-01-01 12:14:43.514938893 +0000
@@ -47,6 +47,15 @@
 #endif
 	add	$a2, $a2, $a1
 	sw	$a2, environ
+#ifdef WANT_ELFINFO
+#  warning "MAKE ME MIPS CODE!"
+1:	addu	$a2, $a2, 4	/* increment envp */
+	lw	$4, -4($a2)     /* load envp[-1]; TODO: is $4 a proper
+				   temporary register? */
+	bnz	1b		/* ... until envp[-1]==NULL
+				   TODO: use proper 'bnz' operation */
+	sw	$a2, __elfinfo
+#endif
 	jalr	$25
 	la	$25, exit
 	move	$4,$2
diff -urN -x .git dietlibc-0.33/mips/syscalls.h dietlibc/mips/syscalls.h
--- dietlibc-0.33/mips/syscalls.h	2008-12-10 20:00:59.000000000 +0000
+++ dietlibc/mips/syscalls.h	2015-01-01 12:14:43.514938893 +0000
@@ -3,16 +3,16 @@
  * Linux o32 style syscalls are in the range from 4000 to 4999.
  */
 #define __NR_Linux			4000
-#define __NR_syscall			(__NR_Linux +   0)
-#define __NR_exit			(__NR_Linux +   1)
-#define __NR_fork			(__NR_Linux +   2)
-#define __NR_read			(__NR_Linux +   3)
-#define __NR_write			(__NR_Linux +   4)
-#define __NR_open			(__NR_Linux +   5)
-#define __NR_close			(__NR_Linux +   6)
-#define __NR_waitpid			(__NR_Linux +   7)
-#define __NR_creat			(__NR_Linux +   8)
-#define __NR_link			(__NR_Linux +   9)
+#define __NR_syscall			(__NR_Linux +	0)
+#define __NR_exit			(__NR_Linux +	1)
+#define __NR_fork			(__NR_Linux +	2)
+#define __NR_read			(__NR_Linux +	3)
+#define __NR_write			(__NR_Linux +	4)
+#define __NR_open			(__NR_Linux +	5)
+#define __NR_close			(__NR_Linux +	6)
+#define __NR_waitpid			(__NR_Linux +	7)
+#define __NR_creat			(__NR_Linux +	8)
+#define __NR_link			(__NR_Linux +	9)
 #define __NR_unlink			(__NR_Linux +  10)
 #define __NR_execve			(__NR_Linux +  11)
 #define __NR_chdir			(__NR_Linux +  12)
@@ -203,8 +203,8 @@
 #define __NR_rt_sigtimedwait		(__NR_Linux + 197)
 #define __NR_rt_sigqueueinfo		(__NR_Linux + 198)
 #define __NR_rt_sigsuspend		(__NR_Linux + 199)
-#define __NR_pread			(__NR_Linux + 200)
-#define __NR_pwrite			(__NR_Linux + 201)
+#define __NR_pread64			(__NR_Linux + 200)
+#define __NR_pwrite64			(__NR_Linux + 201)
 #define __NR_chown			(__NR_Linux + 202)
 #define __NR_getcwd			(__NR_Linux + 203)
 #define __NR_capget			(__NR_Linux + 204)
@@ -296,7 +296,7 @@
 #define __NR_mknodat			(__NR_Linux + 290)
 #define __NR_fchownat			(__NR_Linux + 291)
 #define __NR_futimesat			(__NR_Linux + 292)
-#define __NR_fstatat			(__NR_Linux + 293)
+#define __NR_fstatat64			(__NR_Linux + 293)
 #define __NR_unlinkat			(__NR_Linux + 294)
 #define __NR_renameat			(__NR_Linux + 295)
 #define __NR_linkat			(__NR_Linux + 296)
@@ -312,21 +312,53 @@
 #define __NR_tee			(__NR_Linux + 306)
 #define __NR_vmsplice			(__NR_Linux + 307)
 #define __NR_move_pages			(__NR_Linux + 308)
-#define __NR_set_robust_list		(__NR_Linux + 272)
-#define __NR_get_robust_list		(__NR_Linux + 273)
-#define __NR_kexec_load			(__NR_Linux + 274)
-#define __NR_getcpu			(__NR_Linux + 275)
-#define __NR_epoll_pwait		(__NR_Linux + 276)
-#define __NR_ioprio_set			(__NR_Linux + 277)
-#define __NR_ioprio_get			(__NR_Linux + 278)
-#define __NR_utimensat			(__NR_Linux + 279)
-#define __NR_signalfd			(__NR_Linux + 280)
-#define __NR_timerfd			(__NR_Linux + 281)
-#define __NR_eventfd			(__NR_Linux + 282)
-#define __NR_fallocate			(__NR_Linux + 283)
-#define __NR_timerfd_create		(__NR_Linux + 284)
-#define __NR_timerfd_gettime		(__NR_Linux + 285)
-#define __NR_timerfd_settime		(__NR_Linux + 286)
+#define __NR_set_robust_list		(__NR_Linux + 309)
+#define __NR_get_robust_list		(__NR_Linux + 310)
+#define __NR_kexec_load			(__NR_Linux + 311)
+#define __NR_getcpu			(__NR_Linux + 312)
+#define __NR_epoll_pwait		(__NR_Linux + 313)
+#define __NR_ioprio_set			(__NR_Linux + 314)
+#define __NR_ioprio_get			(__NR_Linux + 315)
+#define __NR_utimensat			(__NR_Linux + 316)
+#define __NR_signalfd			(__NR_Linux + 317)
+#define __NR_timerfd			(__NR_Linux + 318)
+#define __NR_eventfd			(__NR_Linux + 319)
+#define __NR_fallocate			(__NR_Linux + 320)
+#define __NR_timerfd_create		(__NR_Linux + 321)
+#define __NR_timerfd_gettime		(__NR_Linux + 322)
+#define __NR_timerfd_settime		(__NR_Linux + 323)
+#define __NR_signalfd4			(__NR_Linux + 324)
+#define __NR_eventfd2			(__NR_Linux + 325)
+#define __NR_epoll_create1		(__NR_Linux + 326)
+#define __NR_dup3			(__NR_Linux + 327)
+#define __NR_pipe2			(__NR_Linux + 328)
+#define __NR_inotify_init1		(__NR_Linux + 329)
+#define __NR_preadv			(__NR_Linux + 330)
+#define __NR_pwritev			(__NR_Linux + 331)
+#define __NR_rt_tgsigqueueinfo		(__NR_Linux + 332)
+#define __NR_perf_event_open		(__NR_Linux + 333)
+#define __NR_accept4			(__NR_Linux + 334)
+#define __NR_recvmmsg			(__NR_Linux + 335)
+#define __NR_fanotify_init		(__NR_Linux + 336)
+#define __NR_fanotify_mark		(__NR_Linux + 337)
+#define __NR_prlimit64			(__NR_Linux + 338)
+#define __NR_name_to_handle_at		(__NR_Linux + 339)
+#define __NR_open_by_handle_at		(__NR_Linux + 340)
+#define __NR_clock_adjtime		(__NR_Linux + 341)
+#define __NR_syncfs			(__NR_Linux + 342)
+#define __NR_sendmmsg			(__NR_Linux + 343)
+#define __NR_setns			(__NR_Linux + 344)
+#define __NR_process_vm_readv		(__NR_Linux + 345)
+#define __NR_process_vm_writev		(__NR_Linux + 346)
+#define __NR_kcmp			(__NR_Linux + 347)
+#define __NR_finit_module		(__NR_Linux + 348)
+#define __NR_sched_setattr		(__NR_Linux + 349)
+#define __NR_sched_getattr		(__NR_Linux + 350)
+#define __NR_renameat2			(__NR_Linux + 351)
+#define __NR_seccomp			(__NR_Linux + 352)
+#define __NR_getrandom			(__NR_Linux + 353)
+#define __NR_memfd_create		(__NR_Linux + 354)
+
 
 #define syscall_weak(name,wsym,sym) \
 .text; \
diff -urN -x .git dietlibc-0.33/parisc/semctl.S dietlibc/parisc/semctl.S
--- dietlibc-0.33/parisc/semctl.S	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/parisc/semctl.S	2015-01-01 12:14:43.518272227 +0000
@@ -0,0 +1,3 @@
+#include "syscalls.h"
+
+syscall(semctl,semctl)
diff -urN -x .git dietlibc-0.33/parisc/semget.S dietlibc/parisc/semget.S
--- dietlibc-0.33/parisc/semget.S	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/parisc/semget.S	2015-01-01 12:14:43.518272227 +0000
@@ -0,0 +1,3 @@
+#include "syscalls.h"
+
+syscall(semget,semget)
diff -urN -x .git dietlibc-0.33/parisc/semop.S dietlibc/parisc/semop.S
--- dietlibc-0.33/parisc/semop.S	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/parisc/semop.S	2015-01-01 12:14:43.518272227 +0000
@@ -0,0 +1,3 @@
+#include "syscalls.h"
+
+syscall(semop,semop)
diff -urN -x .git dietlibc-0.33/parisc/start.S dietlibc/parisc/start.S
--- dietlibc-0.33/parisc/start.S	2006-05-29 16:30:53.000000000 +0000
+++ dietlibc/parisc/start.S	2015-01-01 12:14:43.518272227 +0000
@@ -34,6 +34,16 @@
 	ldil LP%environ, %r19
 	ldo RP%environ(%r19), %r19
 
+#ifdef WANT_ELFINFO
+#  warning "MAKE ME PARISC CODE!"
+1:	add %r20, %r19, %r19		; envp += 4
+	ldw -4(0,%r19), %r21		; load envp[-4] into %r21
+	comibf =,0, 0,%r21,1b		; compare %r21 with 0 without nullification
+
+	ldil LP%__elfinfo, %r19
+	ldo RP%__elfinfo(%r19), %r19
+#endif
+
 	/* Expand the stack to store the 5th through 7th args */
 	ldo 64(%sp), %sp
 
diff -urN -x .git dietlibc-0.33/parisc/strcmp.S dietlibc/parisc/strcmp.S
--- dietlibc-0.33/parisc/strcmp.S	2003-09-04 01:50:50.000000000 +0000
+++ dietlibc/parisc/strcmp.S	2015-01-01 12:14:43.518272227 +0000
@@ -1,6 +1,8 @@
 .text
 .globl strcmp
 
+.weak strcoll
+strcoll:
 strcmp:
 	.PROC
 	.CALLINFO
diff -urN -x .git dietlibc-0.33/parisc/syscalls.h dietlibc/parisc/syscalls.h
--- dietlibc-0.33/parisc/syscalls.h	2008-12-10 20:00:59.000000000 +0000
+++ dietlibc/parisc/syscalls.h	2015-01-01 12:14:43.518272227 +0000
@@ -323,8 +323,40 @@
 #define __NR_timerfd_create	(__NR_Linux + 306)
 #define __NR_timerfd_settime	(__NR_Linux + 307)
 #define __NR_timerfd_gettime	(__NR_Linux + 308)
+#define __NR_signalfd4		(__NR_Linux + 309)
+#define __NR_eventfd2		(__NR_Linux + 310)
+#define __NR_epoll_create1	(__NR_Linux + 311)
+#define __NR_dup3		(__NR_Linux + 312)
+#define __NR_pipe2		(__NR_Linux + 313)
+#define __NR_inotify_init1	(__NR_Linux + 314)
+#define __NR_preadv		(__NR_Linux + 315)
+#define __NR_pwritev		(__NR_Linux + 316)
+#define __NR_rt_tgsigqueueinfo	(__NR_Linux + 317)
+#define __NR_perf_event_open	(__NR_Linux + 318)
+#define __NR_recvmmsg		(__NR_Linux + 319)
+#define __NR_accept4		(__NR_Linux + 320)
+#define __NR_prlimit64		(__NR_Linux + 321)
+#define __NR_fanotify_init	(__NR_Linux + 322)
+#define __NR_fanotify_mark	(__NR_Linux + 323)
+#define __NR_clock_adjtime	(__NR_Linux + 324)
+#define __NR_name_to_handle_at	(__NR_Linux + 325)
+#define __NR_open_by_handle_at	(__NR_Linux + 326)
+#define __NR_syncfs		(__NR_Linux + 327)
+#define __NR_setns		(__NR_Linux + 328)
+#define __NR_sendmmsg		(__NR_Linux + 329)
+#define __NR_process_vm_readv	(__NR_Linux + 330)
+#define __NR_process_vm_writev	(__NR_Linux + 331)
+#define __NR_kcmp		(__NR_Linux + 332)
+#define __NR_finit_module	(__NR_Linux + 333)
+#define __NR_sched_setattr	(__NR_Linux + 334)
+#define __NR_sched_getattr	(__NR_Linux + 335)
+#define __NR_utimes		(__NR_Linux + 336)
+#define __NR_renameat2		(__NR_Linux + 337)
+#define __NR_seccomp		(__NR_Linux + 338)
+#define __NR_getrandom		(__NR_Linux + 339)
+#define __NR_memfd_create	(__NR_Linux + 340)
 
-#define __NR_Linux_syscalls	(__NR_fallocate + 1)
+#define __NR_Linux_syscalls	(__NR_memfd_create + 1)
 
 #define LINUX_GATEWAY_ADDR      0x100
 
diff -urN -x .git dietlibc-0.33/PORTING dietlibc/PORTING
--- dietlibc-0.33/PORTING	2010-09-25 17:03:25.000000000 +0000
+++ dietlibc/PORTING	2015-01-01 12:14:43.451605563 +0000
@@ -18,9 +18,11 @@
   - edit include/sys/mman.h
   - edit include/sys/shm.h
   - edit include/sys/stat.h
+  - edit include/sys/tls.h
   - edit include/errno.h
   - edit syscalls.h
   - edit include/termios.h
+  - edit lib/__get_cur_tcb.c
   - edit diet.c to make it recognize the architecture and add proper
     CFLAGS
   - edit libcompat/syscall.S
diff -urN -x .git dietlibc-0.33/ppc/select.S dietlibc/ppc/select.S
--- dietlibc-0.33/ppc/select.S	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/ppc/select.S	2015-01-01 12:14:43.518272227 +0000
@@ -0,0 +1,3 @@
+#include "syscalls.h"
+
+syscall_weak(_newselect,select,__libc_select)
diff -urN -x .git dietlibc-0.33/ppc/start.S dietlibc/ppc/start.S
--- dietlibc-0.33/ppc/start.S	2006-05-29 16:30:53.000000000 +0000
+++ dietlibc/ppc/start.S	2015-01-01 12:14:43.518272227 +0000
@@ -31,6 +31,15 @@
 	lis	14,environ@ha
 	stw	5,environ@l(14)
 
+#ifdef WANT_ELFINFO
+1:	lwzu	15,0(5)
+	addi	5, 5, 4
+	cmpwi	15,0
+	bne	1b
+
+	stw	5,__elfinfo@l(14)
+#endif
+
 #ifdef WANT_DYNAMIC
 	mr	6,7
 	bl	_dyn_start
diff -urN -x .git dietlibc-0.33/ppc/syscalls.h dietlibc/ppc/syscalls.h
--- dietlibc-0.33/ppc/syscalls.h	2008-12-10 20:00:59.000000000 +0000
+++ dietlibc/ppc/syscalls.h	2015-01-01 12:14:43.518272227 +0000
@@ -311,7 +311,54 @@
 #define __NR_subpage_prot	310
 #define __NR_timerfd_settime	311
 #define __NR_timerfd_gettime	312
-
+#define __NR_signalfd4		313
+#define __NR_eventfd2		314
+#define __NR_epoll_create1	315
+#define __NR_dup3		316
+#define __NR_pipe2		317
+#define __NR_inotify_init1	318
+#define __NR_perf_event_open	319
+#define __NR_preadv		320
+#define __NR_pwritev		321
+#define __NR_rt_tgsigqueueinfo	322
+#define __NR_fanotify_init	323
+#define __NR_fanotify_mark	324
+#define __NR_prlimit64		325
+#define __NR_socket		326
+#define __NR_bind		327
+#define __NR_connect		328
+#define __NR_listen		329
+#define __NR_accept		330
+#define __NR_getsockname	331
+#define __NR_getpeername	332
+#define __NR_socketpair		333
+#define __NR_send		334
+#define __NR_sendto		335
+#define __NR_recv		336
+#define __NR_recvfrom		337
+#define __NR_shutdown		338
+#define __NR_setsockopt		339
+#define __NR_getsockopt		340
+#define __NR_sendmsg		341
+#define __NR_recvmsg		342
+#define __NR_recvmmsg		343
+#define __NR_accept4		344
+#define __NR_name_to_handle_at	345
+#define __NR_open_by_handle_at	346
+#define __NR_clock_adjtime	347
+#define __NR_syncfs		348
+#define __NR_sendmmsg		349
+#define __NR_setns		350
+#define __NR_process_vm_readv	351
+#define __NR_process_vm_writev	352
+#define __NR_finit_module	353
+#define __NR_kcmp		354
+#define __NR_sched_setattr	355
+#define __NR_sched_getattr	356
+#define __NR_renameat2		357
+#define __NR_seccomp		358
+#define __NR_getrandom		359
+#define __NR_memfd_create	360
 
 #define syscall_weak(name,wsym,sym) \
 .text; \
diff -urN -x .git dietlibc-0.33/ppc64/select.S dietlibc/ppc64/select.S
--- dietlibc-0.33/ppc64/select.S	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/ppc64/select.S	2015-01-01 12:14:43.521605560 +0000
@@ -0,0 +1,3 @@
+#include "syscalls.h"
+
+syscall_weak(_newselect,select,__libc_select)
diff -urN -x .git dietlibc-0.33/ppc64/start.S dietlibc/ppc64/start.S
--- dietlibc-0.33/ppc64/start.S	2012-01-24 18:24:28.000000000 +0000
+++ dietlibc/ppc64/start.S	2015-01-01 12:14:43.521605560 +0000
@@ -58,6 +58,15 @@
 	oris	14,14,environ@ha
 	std	5,environ@l(14)
 
+#ifdef WANT_ELFINFO
+1:	ldu	15,0(5)
+	addi	5, 5, 8
+	cmpdi	15,0
+	bne	1b
+
+	std	5,__elfinfo@l(14)
+#endif
+
 #ifdef WANT_DYNAMIC
 /* #warning dynamic */
 	mr	6,7
diff -urN -x .git dietlibc-0.33/ppc64/syscalls.h dietlibc/ppc64/syscalls.h
--- dietlibc-0.33/ppc64/syscalls.h	2008-12-10 20:00:59.000000000 +0000
+++ dietlibc/ppc64/syscalls.h	2015-01-01 12:14:43.521605560 +0000
@@ -311,7 +311,54 @@
 #define __NR_subpage_prot	310
 #define __NR_timerfd_settime	311
 #define __NR_timerfd_gettime	312
-
+#define __NR_signalfd4		313
+#define __NR_eventfd2		314
+#define __NR_epoll_create1	315
+#define __NR_dup3		316
+#define __NR_pipe2		317
+#define __NR_inotify_init1	318
+#define __NR_perf_event_open	319
+#define __NR_preadv		320
+#define __NR_pwritev		321
+#define __NR_rt_tgsigqueueinfo	322
+#define __NR_fanotify_init	323
+#define __NR_fanotify_mark	324
+#define __NR_prlimit64		325
+#define __NR_socket		326
+#define __NR_bind		327
+#define __NR_connect		328
+#define __NR_listen		329
+#define __NR_accept		330
+#define __NR_getsockname	331
+#define __NR_getpeername	332
+#define __NR_socketpair		333
+#define __NR_send		334
+#define __NR_sendto		335
+#define __NR_recv		336
+#define __NR_recvfrom		337
+#define __NR_shutdown		338
+#define __NR_setsockopt		339
+#define __NR_getsockopt		340
+#define __NR_sendmsg		341
+#define __NR_recvmsg		342
+#define __NR_recvmmsg		343
+#define __NR_accept4		344
+#define __NR_name_to_handle_at	345
+#define __NR_open_by_handle_at	346
+#define __NR_clock_adjtime	347
+#define __NR_syncfs		348
+#define __NR_sendmmsg		349
+#define __NR_setns		350
+#define __NR_process_vm_readv	351
+#define __NR_process_vm_writev	352
+#define __NR_finit_module	353
+#define __NR_kcmp		354
+#define __NR_sched_setattr	355
+#define __NR_sched_getattr	356
+#define __NR_renameat2		357
+#define __NR_seccomp		358
+#define __NR_getrandom		359
+#define __NR_memfd_create	360
 
 #define __diet_proto_common(sym) \
 	.section ".opd","aw"; \
diff -urN -x .git dietlibc-0.33/s390/fadvise64_64.S dietlibc/s390/fadvise64_64.S
--- dietlibc-0.33/s390/fadvise64_64.S	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/s390/fadvise64_64.S	2015-01-01 12:14:43.521605560 +0000
@@ -0,0 +1,5 @@
+#include "syscalls.h"
+
+#ifdef __NR_fadvise64_64
+syscall(fadvise64_64, __s390_fadvise64_64);
+#endif
diff -urN -x .git dietlibc-0.33/s390/__fadvise.c dietlibc/s390/__fadvise.c
--- dietlibc-0.33/s390/__fadvise.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/s390/__fadvise.c	2015-01-01 12:14:43.521605560 +0000
@@ -0,0 +1,29 @@
+#include "syscalls.h"
+
+#define _LINUX_SOURCE
+#include <fcntl.h>
+#include <unistd.h>
+
+struct fadvise64_64_layout
+{
+  int fd;
+  off64_t offset;
+  off64_t len;
+  int advise;
+};
+
+long fadvise64_64(int fd, off64_t offset, off64_t len, int advise)
+{
+  struct fadvise64_64_layout parameters;
+  extern long __s390_fadvise64_64(struct fadvise64_64_layout *args);
+
+  parameters.fd = fd;
+  parameters.offset = offset;
+  parameters.len = len;
+  parameters.advise = advise;
+
+  return __s390_fadvise64_64(&parameters);
+}
+
+int posix_fadvise(int fd, off64_t offset, off64_t len, int advise)
+  __attribute__((__alias__("fadvise64_64")));
diff -urN -x .git dietlibc-0.33/s390/Makefile.add dietlibc/s390/Makefile.add
--- dietlibc-0.33/s390/Makefile.add	2002-11-09 18:10:23.000000000 +0000
+++ dietlibc/s390/Makefile.add	2015-01-01 12:14:43.521605560 +0000
@@ -1,4 +1,4 @@
 
 CFLAGS+=-Os # -fomit-frame-pointer -fstrict-aliasing
 VPATH:=s390:syscalls.s:$(VPATH)
-LIBOBJ+=$(OBJDIR)/__waitpid.o
+LIBOBJ+=$(OBJDIR)/__waitpid.o $(OBJDIR)/__fadvise.o
diff -urN -x .git dietlibc-0.33/s390/setjmp.S dietlibc/s390/setjmp.S
--- dietlibc-0.33/s390/setjmp.S	2001-11-26 14:50:08.000000000 +0000
+++ dietlibc/s390/setjmp.S	2015-01-01 12:14:43.521605560 +0000
@@ -14,6 +14,7 @@
 
 .global _setjmp
 .type	_setjmp,@function
+_setjmp:
 	lhi	%r3,0
 .size	_setjmp,.-_setjmp
 
@@ -26,15 +27,18 @@
 	std	%f6,48(%r2)
 
 	/* Make a tail call to __sigjmp_save; it takes the same args.  */
-	basr	%r1,%r0
+	basr	%r1,0
 #ifdef	PIC
-.L0:	la	%r1,.L1-.L0(0,%r1)
+.L0:	al	%r1,.L1-.L0(0,%r1)
 	l	%r1,__sigjmp_save@GOT12(0,%r1)
+#else
+.L0:	l	%r1,.L1-.L0(0,%r1)
+#endif
 	br	%r1
+	.p2align 3
+#ifdef	PIC
 .L1:	.long	_GLOBAL_OFFSET_TABLE_-.L0
 #else
-	l	%r1,.L1(0,%r1)
-	br	%r1
 .L1:	.long	__sigjmp_save
 #endif
 .size __sigsetjmp,.-__sigsetjmp;
diff -urN -x .git dietlibc-0.33/s390/start.S dietlibc/s390/start.S
--- dietlibc-0.33/s390/start.S	2006-05-29 16:30:53.000000000 +0000
+++ dietlibc/s390/start.S	2015-01-01 12:14:43.521605560 +0000
@@ -30,6 +30,17 @@
 	l	%r1,8(%r13)
 	st	%r4,0(%r1)
 
+#ifdef WANT_ELFINFO
+	lhi	%r6, -4
+1:	ahi	%r4, 4		# increment envp
+	l	%r12, 0(%r6,%r4)	# load envp[-1] into %r12
+	or	%r12, %r12	# test %r12 for NULL
+	jne	1b
+
+	ahi	%r1, 4
+	st	%r4,0(%r1)
+#endif
+
 /* call main or _dyn_start */
 	l	%r1,0(%r13)
 	basr	%r14,%r1
diff -urN -x .git dietlibc-0.33/s390/syscalls.h dietlibc/s390/syscalls.h
--- dietlibc-0.33/s390/syscalls.h	2008-12-10 20:00:59.000000000 +0000
+++ dietlibc/s390/syscalls.h	2015-01-01 12:14:43.521605560 +0000
@@ -277,6 +277,7 @@
 #define __NR_mknodat		290
 #define __NR_fchownat		291
 #define __NR_futimesat		292
+#define __NR_fstatat64		293
 #define __NR_unlinkat		294
 #define __NR_renameat		295
 #define __NR_linkat		296
@@ -305,7 +306,35 @@
 #define __NR_timerfd_create	319
 #define __NR_timerfd_settime	320
 #define __NR_timerfd_gettime	321
-
+#define __NR_signalfd4		322
+#define __NR_eventfd2		323
+#define __NR_inotify_init1	324
+#define __NR_pipe2		325
+#define __NR_dup3		326
+#define __NR_epoll_create1	327
+#define	__NR_preadv		328
+#define	__NR_pwritev		329
+#define __NR_rt_tgsigqueueinfo	330
+#define __NR_perf_event_open	331
+#define __NR_fanotify_init	332
+#define __NR_fanotify_mark	333
+#define __NR_prlimit64		334
+#define __NR_name_to_handle_at	335
+#define __NR_open_by_handle_at	336
+#define __NR_clock_adjtime	337
+#define __NR_syncfs		338
+#define __NR_setns		339
+#define __NR_process_vm_readv	340
+#define __NR_process_vm_writev	341
+#define __NR_s390_runtime_instr 342
+#define __NR_kcmp		343
+#define __NR_finit_module	344
+#define __NR_sched_setattr	345
+#define __NR_sched_getattr	346
+#define __NR_renameat2		347
+#define __NR_seccomp		348
+#define __NR_getrandom		349
+#define __NR_memfd_create	350
 
 #define syscall_weak(name,wsym,sym) \
 .text; \
diff -urN -x .git dietlibc-0.33/s390x/setjmp.S dietlibc/s390x/setjmp.S
--- dietlibc-0.33/s390x/setjmp.S	2003-10-10 13:37:34.000000000 +0000
+++ dietlibc/s390x/setjmp.S	2015-01-01 12:14:43.521605560 +0000
@@ -14,6 +14,7 @@
 
 .global _setjmp
 .type	_setjmp,@function
+_setjmp:
 	lhi	%r3,0
 .size	_setjmp,.-_setjmp
 
@@ -26,15 +27,18 @@
 	std	%f6,48(%r2)
 
 	/* Make a tail call to __sigjmp_save; it takes the same args.  */
-	basr	%r1,%r0
+	basr	%r1,0
 #ifdef	PIC
-.L0:	la	%r1,.L1-.L0(0,%r1)
+.L0:	al	%r1,.L1-.L0(0,%r1)
 	l	%r1,__sigjmp_save@GOT12(0,%r1)
+#else
+.L0:	l	%r1,.L1-.L0(0,%r1)
+#endif
 	br	%r1
+	.p2align 3
+#ifdef	PIC
 .L1:	.long	_GLOBAL_OFFSET_TABLE_-.L0
 #else
-	l	%r1,.L1(0,%r1)
-	br	%r1
 .L1:	.long	__sigjmp_save
 #endif
 .size __sigsetjmp,.-__sigsetjmp;
diff -urN -x .git dietlibc-0.33/s390x/start.S dietlibc/s390x/start.S
--- dietlibc-0.33/s390x/start.S	2006-05-29 16:30:54.000000000 +0000
+++ dietlibc/s390x/start.S	2015-01-01 12:14:43.521605560 +0000
@@ -26,6 +26,16 @@
 	larl	%r13,environ
 	stg	%r4,0(%r13)
 
+#ifdef WANT_ELFINFO
+1:	aghi	%r4, 8		# increment envp
+	lg	%r12, -8(0,%r4)	# load envp[-1] into %r12
+	ogr	%r12, %r12	# test %r12 for NULL
+	jne	1b
+
+	aghi	%r13, 8
+	stg	%r4,0(%r13)
+#endif
+
 /* call main or _dyn_start */
 #ifdef WANT_DYNAMIC
 	brasl	%r14,_dyn_start
diff -urN -x .git dietlibc-0.33/s390x/syscalls.h dietlibc/s390x/syscalls.h
--- dietlibc-0.33/s390x/syscalls.h	2008-12-10 20:00:59.000000000 +0000
+++ dietlibc/s390x/syscalls.h	2015-01-01 12:14:43.521605560 +0000
@@ -305,7 +305,35 @@
 #define __NR_timerfd_create	319
 #define __NR_timerfd_settime	320
 #define __NR_timerfd_gettime	321
-
+#define __NR_signalfd4		322
+#define __NR_eventfd2		323
+#define __NR_inotify_init1	324
+#define __NR_pipe2		325
+#define __NR_dup3		326
+#define __NR_epoll_create1	327
+#define __NR_preadv		328
+#define __NR_pwritev		329
+#define __NR_rt_tgsigqueueinfo	330
+#define __NR_perf_event_open	331
+#define __NR_fanotify_init	332
+#define __NR_fanotify_mark	333
+#define __NR_prlimit64		334
+#define __NR_name_to_handle_at	335
+#define __NR_open_by_handle_at	336
+#define __NR_clock_adjtime	337
+#define __NR_syncfs		338
+#define __NR_setns		339
+#define __NR_process_vm_readv	340
+#define __NR_process_vm_writev	341
+#define __NR_s390_runtime_instr 342
+#define __NR_kcmp		343
+#define __NR_finit_module	344
+#define __NR_sched_setattr	345
+#define __NR_sched_getattr	346
+#define __NR_renameat2		347
+#define __NR_seccomp		348
+#define __NR_getrandom		349
+#define __NR_memfd_create	350
 
 /* 
  * There are some system calls that are not present on 64 bit, some
@@ -313,6 +341,7 @@
  * is __NR_chown on 64 bit).
  */
 #ifdef __s390x__
+
 #undef  __NR_time
 #undef  __NR_lchown
 #undef  __NR_setuid
diff -urN -x .git dietlibc-0.33/sparc/shmat.c dietlibc/sparc/shmat.c
--- dietlibc-0.33/sparc/shmat.c	2001-06-16 17:48:57.000000000 +0000
+++ dietlibc/sparc/shmat.c	2015-01-01 12:14:43.521605560 +0000
@@ -3,17 +3,15 @@
 #include <sys/shm.h>
 #include <unistd.h>
 
-extern void* __ipc();
+#include "../dietpagesize.h"
 
-#ifndef PAGE_SIZE
-#define PAGE_SIZE 4096
-#endif
+extern void* __ipc();
 
 void* shmat(int shmid,const void* shmaddr,int shmflg) {
   void* raddr;
   register void* result;
   result=__ipc(SHMAT,shmid,shmflg,&raddr,shmaddr);
-  if ((unsigned long)result <= -(unsigned long)PAGE_SIZE)
+  if ((unsigned long)result <= -(unsigned long)__DIET_PAGE_SIZE)
     result=raddr;
   return result;
 }
diff -urN -x .git dietlibc-0.33/sparc/start.S dietlibc/sparc/start.S
--- dietlibc-0.33/sparc/start.S	2006-05-29 16:30:54.000000000 +0000
+++ dietlibc/sparc/start.S	2015-01-01 12:14:43.521605560 +0000
@@ -25,6 +25,17 @@
 	or	%o3, %lo(environ), %o3
 	st	%o2, [%o3]
 
+#ifdef WANT_ELFINFO
+#  warning "VERIFY ME!"
+1:	add	%o2, %o2, 4
+	ld	[%o2-4], %o4
+	orcc	%o4, %o4, %o4
+	bne	1b
+
+	add	%o3, %o3, 4
+	st	%o2, [%o3]
+#endif
+
 /* When starting a binary via the dynamic linker, %g1 contains the
    address of the shared library termination function, which will be
    registered with atexit(). If we are statically linked, this will
diff -urN -x .git dietlibc-0.33/sparc/strchr.S dietlibc/sparc/strchr.S
--- dietlibc-0.33/sparc/strchr.S	2003-09-04 01:50:50.000000000 +0000
+++ dietlibc/sparc/strchr.S	2015-01-01 12:14:43.521605560 +0000
@@ -11,6 +11,8 @@
 
 .text
 .globl strchr
+.weak index
+index:
 strchr:
 	ldub [%o0], %o2
 	cmp %o2, %o1
diff -urN -x .git dietlibc-0.33/sparc/strcmp.S dietlibc/sparc/strcmp.S
--- dietlibc-0.33/sparc/strcmp.S	2003-09-04 01:50:50.000000000 +0000
+++ dietlibc/sparc/strcmp.S	2015-01-01 12:14:43.521605560 +0000
@@ -11,6 +11,8 @@
 
 .text
 .globl strcmp
+.weak strcoll
+strcoll:
 strcmp:
 	clr %o4
 .Lloop:
diff -urN -x .git dietlibc-0.33/sparc/syscalls.h dietlibc/sparc/syscalls.h
--- dietlibc-0.33/sparc/syscalls.h	2008-12-10 20:00:59.000000000 +0000
+++ dietlibc/sparc/syscalls.h	2015-01-01 12:14:43.521605560 +0000
@@ -315,6 +315,38 @@
 #define __NR_fallocate		314
 #define __NR_timerfd_settime	315
 #define __NR_timerfd_gettime	316
+#define __NR_signalfd4		317
+#define __NR_eventfd2		318
+#define __NR_epoll_create1	319
+#define __NR_dup3		320
+#define __NR_pipe2		321
+#define __NR_inotify_init1	322
+#define __NR_accept4		323
+#define __NR_preadv		324
+#define __NR_pwritev		325
+#define __NR_rt_tgsigqueueinfo	326
+#define __NR_perf_event_open	327
+#define __NR_recvmmsg		328
+#define __NR_fanotify_init	329
+#define __NR_fanotify_mark	330
+#define __NR_prlimit64		331
+#define __NR_name_to_handle_at	332
+#define __NR_open_by_handle_at	333
+#define __NR_clock_adjtime	334
+#define __NR_syncfs		335
+#define __NR_sendmmsg		336
+#define __NR_setns		337
+#define __NR_process_vm_readv	338
+#define __NR_process_vm_writev	339
+#define __NR_kern_features	340
+#define __NR_kcmp		341
+#define __NR_finit_module	342
+#define __NR_sched_setattr	343
+#define __NR_sched_getattr	344
+#define __NR_renameat2		345
+#define __NR_seccomp		346
+#define __NR_getrandom		347
+#define __NR_memfd_create	348
 
 #define syscall_weak(name,wsym,sym) \
 .text; \
diff -urN -x .git dietlibc-0.33/sparc64/start.S dietlibc/sparc64/start.S
--- dietlibc-0.33/sparc64/start.S	2006-05-29 16:30:54.000000000 +0000
+++ dietlibc/sparc64/start.S	2015-01-01 12:14:43.524938894 +0000
@@ -25,6 +25,17 @@
 	or	%o3, %lo(environ), %o3
 	stx	%o2, [%o3]
 
+#ifdef WANT_ELFINFO
+#  warning "VERIFY ME!"
+1:	add	%o2, %o2, 8
+	ldx	[%o2-8], %o4
+	orcc	%o4, %o4, %o4
+	bne	1b
+
+	add	%o3, %o3, 8
+	stx	%o2, [%o3]
+#endif
+
 /* When starting a binary via the dynamic linker, %g1 contains the
    address of the shared library termination function, which will be
    registered with atexit(). If we are statically linked, this will
diff -urN -x .git dietlibc-0.33/sparc64/syscalls.h dietlibc/sparc64/syscalls.h
--- dietlibc-0.33/sparc64/syscalls.h	2008-12-10 20:00:59.000000000 +0000
+++ dietlibc/sparc64/syscalls.h	2015-01-01 12:14:43.524938894 +0000
@@ -314,6 +314,38 @@
 #define __NR_fallocate		314
 #define __NR_timerfd_settime	315
 #define __NR_timerfd_gettime	316
+#define __NR_signalfd4		317
+#define __NR_eventfd2		318
+#define __NR_epoll_create1	319
+#define __NR_dup3		320
+#define __NR_pipe2		321
+#define __NR_inotify_init1	322
+#define __NR_accept4		323
+#define __NR_preadv		324
+#define __NR_pwritev		325
+#define __NR_rt_tgsigqueueinfo	326
+#define __NR_perf_event_open	327
+#define __NR_recvmmsg		328
+#define __NR_fanotify_init	329
+#define __NR_fanotify_mark	330
+#define __NR_prlimit64		331
+#define __NR_name_to_handle_at	332
+#define __NR_open_by_handle_at	333
+#define __NR_clock_adjtime	334
+#define __NR_syncfs		335
+#define __NR_sendmmsg		336
+#define __NR_setns		337
+#define __NR_process_vm_readv	338
+#define __NR_process_vm_writev	339
+#define __NR_kern_features	340
+#define __NR_kcmp		341
+#define __NR_finit_module	342
+#define __NR_sched_setattr	343
+#define __NR_sched_getattr	344
+#define __NR_renameat2		345
+#define __NR_seccomp		346
+#define __NR_getrandom		347
+#define __NR_memfd_create	348
 
 #define syscall_weak(name,wsym,sym) \
 .text; \
diff -urN -x .git dietlibc-0.33/syscalls.h dietlibc/syscalls.h
--- dietlibc-0.33/syscalls.h	2005-05-08 15:33:38.000000000 +0000
+++ dietlibc/syscalls.h	2015-01-01 12:14:43.524938894 +0000
@@ -2,7 +2,11 @@
 #include "i386/syscalls.h"
 
 #elif defined(__x86_64__)
+#if defined(__ILP32__)
+#include "x32/syscalls.h"
+#else
 #include "x86_64/syscalls.h"
+#endif
 
 #elif defined(__sparc__)
 #if defined(__arch64__)
diff -urN -x .git dietlibc-0.33/syscalls.s/accept4.S dietlibc/syscalls.s/accept4.S
--- dietlibc-0.33/syscalls.s/accept4.S	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/syscalls.s/accept4.S	2015-01-01 12:14:43.524938894 +0000
@@ -0,0 +1,5 @@
+#include "syscalls.h"
+
+#ifdef __NR_accept4
+syscall(accept4,accept4)
+#endif
diff -urN -x .git dietlibc-0.33/syscalls.s/dup3.S dietlibc/syscalls.s/dup3.S
--- dietlibc-0.33/syscalls.s/dup3.S	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/syscalls.s/dup3.S	2015-01-01 12:14:43.524938894 +0000
@@ -0,0 +1,3 @@
+#include "syscalls.h"
+
+syscall(dup3,dup3)
diff -urN -x .git dietlibc-0.33/syscalls.s/environ.S dietlibc/syscalls.s/environ.S
--- dietlibc-0.33/syscalls.s/environ.S	2005-01-31 12:53:34.000000000 +0000
+++ dietlibc/syscalls.s/environ.S	2015-01-01 12:14:43.524938894 +0000
@@ -1,6 +1,7 @@
 .section ".bss"
 .align 8
 #include <endian.h>
+#include <dietfeatures.h>
 
 .type environ,object
 .weak environ
@@ -15,3 +16,18 @@
 #endif
 .size environ,.-environ
 .size __environ,.-__environ
+
+/* __elfinfo will be initialized in start.S to point to the
+   terminating NULL of the environment. */
+
+#ifdef WANT_ELFINFO
+.type __elfinfo,object
+.weak __elfinfo
+__elfinfo:
+#if __WORDSIZE == 64
+	.quad 0
+#else
+	.long 0
+#endif
+.size __elfinfo,.-__elfinfo
+#endif
diff -urN -x .git dietlibc-0.33/syscalls.s/epoll_create1.S dietlibc/syscalls.s/epoll_create1.S
--- dietlibc-0.33/syscalls.s/epoll_create1.S	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/syscalls.s/epoll_create1.S	2015-01-01 12:14:43.524938894 +0000
@@ -0,0 +1,5 @@
+#include "syscalls.h"
+
+#ifdef __NR_epoll_create1
+syscall(epoll_create1,epoll_create1)
+#endif
diff -urN -x .git dietlibc-0.33/syscalls.s/errno.S dietlibc/syscalls.s/errno.S
--- dietlibc-0.33/syscalls.s/errno.S	2002-11-15 15:39:17.000000000 +0000
+++ dietlibc/syscalls.s/errno.S	1970-01-01 00:00:00.000000000 +0000
@@ -1,8 +0,0 @@
-.section ".bss"
-.align 8
-
-.type errno,object
-.weak errno
-errno:
-	.long 0
-.size errno,.-errno
diff -urN -x .git dietlibc-0.33/syscalls.s/__eventfd2.S dietlibc/syscalls.s/__eventfd2.S
--- dietlibc-0.33/syscalls.s/__eventfd2.S	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/syscalls.s/__eventfd2.S	2015-01-01 12:14:43.524938894 +0000
@@ -0,0 +1,3 @@
+#include "syscalls.h"
+
+syscall(eventfd2,__eventfd2)
diff -urN -x .git dietlibc-0.33/syscalls.s/__eventfd.S dietlibc/syscalls.s/__eventfd.S
--- dietlibc-0.33/syscalls.s/__eventfd.S	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/syscalls.s/__eventfd.S	2015-01-01 12:14:43.524938894 +0000
@@ -0,0 +1,3 @@
+#include "syscalls.h"
+
+syscall(eventfd,__eventfd)
diff -urN -x .git dietlibc-0.33/syscalls.s/fadvise64.S dietlibc/syscalls.s/fadvise64.S
--- dietlibc-0.33/syscalls.s/fadvise64.S	2012-01-24 18:24:28.000000000 +0000
+++ dietlibc/syscalls.s/fadvise64.S	2015-01-01 12:14:43.524938894 +0000
@@ -3,15 +3,14 @@
 
 #include "syscalls.h"
 
+#ifdef __NR_fadvise64
+syscall(fadvise64,fadvise64)
+
 #ifndef __NR_fadvise64_64
+posix_fadvise = fadvise64
 .globl posix_fadvise
-.type posix_fadvise,@function
-posix_fadvise:
 #endif
 
-#ifdef __NR_fadvise64
-syscall(fadvise64,fadvise64)
-
 #endif
 
 #endif
diff -urN -x .git dietlibc-0.33/syscalls.s/fanotify_init.S dietlibc/syscalls.s/fanotify_init.S
--- dietlibc-0.33/syscalls.s/fanotify_init.S	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/syscalls.s/fanotify_init.S	2015-01-01 12:14:43.524938894 +0000
@@ -0,0 +1,3 @@
+#include "syscalls.h"
+
+syscall(fanotify_init,fanotify_init)
diff -urN -x .git dietlibc-0.33/syscalls.s/fanotify_mark.S dietlibc/syscalls.s/fanotify_mark.S
--- dietlibc-0.33/syscalls.s/fanotify_mark.S	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/syscalls.s/fanotify_mark.S	2015-01-01 12:14:43.524938894 +0000
@@ -0,0 +1,3 @@
+#include "syscalls.h"
+
+syscall(fanotify_mark,fanotify_mark)
diff -urN -x .git dietlibc-0.33/syscalls.s/fstatat64.S dietlibc/syscalls.s/fstatat64.S
--- dietlibc-0.33/syscalls.s/fstatat64.S	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/syscalls.s/fstatat64.S	2015-01-01 12:14:43.524938894 +0000
@@ -0,0 +1,5 @@
+#include "syscalls.h"
+
+#ifdef __NR_fstatat64
+syscall(fstatat64,fstatat64)
+#endif
diff -urN -x .git dietlibc-0.33/syscalls.s/fstatat.S dietlibc/syscalls.s/fstatat.S
--- dietlibc-0.33/syscalls.s/fstatat.S	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/syscalls.s/fstatat.S	2015-01-01 12:14:43.524938894 +0000
@@ -0,0 +1,5 @@
+#include "syscalls.h"
+
+#ifdef __NR_fstatat
+syscall(fstatat,fstatat)
+#endif
diff -urN -x .git dietlibc-0.33/syscalls.s/getrandom.S dietlibc/syscalls.s/getrandom.S
--- dietlibc-0.33/syscalls.s/getrandom.S	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/syscalls.s/getrandom.S	2015-01-01 12:14:43.528272226 +0000
@@ -0,0 +1,3 @@
+#include "syscalls.h"
+
+syscall(getrandom,getrandom)
diff -urN -x .git dietlibc-0.33/syscalls.s/inotify_init1.S dietlibc/syscalls.s/inotify_init1.S
--- dietlibc-0.33/syscalls.s/inotify_init1.S	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/syscalls.s/inotify_init1.S	2015-01-01 12:14:43.528272226 +0000
@@ -0,0 +1,5 @@
+#include "syscalls.h"
+
+#ifdef __NR_inotify_init1
+syscall(inotify_init1,inotify_init1)
+#endif
diff -urN -x .git dietlibc-0.33/syscalls.s/_llseek.S dietlibc/syscalls.s/_llseek.S
--- dietlibc-0.33/syscalls.s/_llseek.S	2004-06-30 05:52:31.000000000 +0000
+++ dietlibc/syscalls.s/_llseek.S	2015-01-01 12:14:43.524938894 +0000
@@ -2,7 +2,7 @@
 
 #ifdef __NR__llseek
 .global llseek
-.type	llseek,function
+.type	llseek,STT_FUNC
 llseek:
 syscall(_llseek,_llseek)
 #endif
diff -urN -x .git dietlibc-0.33/syscalls.s/memfd_create.S dietlibc/syscalls.s/memfd_create.S
--- dietlibc-0.33/syscalls.s/memfd_create.S	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/syscalls.s/memfd_create.S	2015-01-01 12:14:43.528272226 +0000
@@ -0,0 +1,3 @@
+#include "syscalls.h"
+
+syscall(memfd_create,memfd_create)
diff -urN -x .git dietlibc-0.33/syscalls.s/newfstatat.S dietlibc/syscalls.s/newfstatat.S
--- dietlibc-0.33/syscalls.s/newfstatat.S	2012-01-16 21:10:29.000000000 +0000
+++ dietlibc/syscalls.s/newfstatat.S	2015-01-01 12:14:43.528272226 +0000
@@ -2,4 +2,12 @@
 
 #ifdef __NR_newfstatat
 syscall(newfstatat,newfstatat)
+
+#ifdef __NR_fstatat64
+#  error __NR_newfstatat and __NR_fstatat64 must not both be defined
+#endif
+
+fstatat = newfstatat
+.globl fstatat
+
 #endif
diff -urN -x .git dietlibc-0.33/syscalls.s/pipe2.S dietlibc/syscalls.s/pipe2.S
--- dietlibc-0.33/syscalls.s/pipe2.S	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/syscalls.s/pipe2.S	2015-01-01 12:14:43.528272226 +0000
@@ -0,0 +1,3 @@
+#include "syscalls.h"
+
+syscall(pipe2,pipe2)
diff -urN -x .git dietlibc-0.33/syscalls.s/preadv.S dietlibc/syscalls.s/preadv.S
--- dietlibc-0.33/syscalls.s/preadv.S	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/syscalls.s/preadv.S	2015-01-01 12:14:43.528272226 +0000
@@ -0,0 +1,3 @@
+#include "syscalls.h"
+
+syscall(preadv,preadv)
diff -urN -x .git dietlibc-0.33/syscalls.s/pwritev.S dietlibc/syscalls.s/pwritev.S
--- dietlibc-0.33/syscalls.s/pwritev.S	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/syscalls.s/pwritev.S	2015-01-01 12:14:43.528272226 +0000
@@ -0,0 +1,3 @@
+#include "syscalls.h"
+
+syscall(pwritev,pwritev)
diff -urN -x .git dietlibc-0.33/syscalls.s/recvmmsg.S dietlibc/syscalls.s/recvmmsg.S
--- dietlibc-0.33/syscalls.s/recvmmsg.S	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/syscalls.s/recvmmsg.S	2015-01-01 12:14:43.528272226 +0000
@@ -0,0 +1,5 @@
+#include "syscalls.h"
+
+#ifdef __NR_recvmmsg
+syscall(recvmmsg,recvmmsg)
+#endif
diff -urN -x .git dietlibc-0.33/syscalls.s/sendmmsg.S dietlibc/syscalls.s/sendmmsg.S
--- dietlibc-0.33/syscalls.s/sendmmsg.S	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/syscalls.s/sendmmsg.S	2015-01-01 12:14:43.528272226 +0000
@@ -0,0 +1,5 @@
+#include "syscalls.h"
+
+#ifdef __NR_sendmmsg
+syscall(sendmmsg,sendmmsg)
+#endif
diff -urN -x .git dietlibc-0.33/syscalls.s/setns.S dietlibc/syscalls.s/setns.S
--- dietlibc-0.33/syscalls.s/setns.S	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/syscalls.s/setns.S	2015-01-01 12:14:43.528272226 +0000
@@ -0,0 +1,3 @@
+#include "syscalls.h"
+
+syscall(setns,setns)
diff -urN -x .git dietlibc-0.33/syscalls.s/__signalfd4.S dietlibc/syscalls.s/__signalfd4.S
--- dietlibc-0.33/syscalls.s/__signalfd4.S	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/syscalls.s/__signalfd4.S	2015-01-01 12:14:43.524938894 +0000
@@ -0,0 +1,5 @@
+#include "syscalls.h"
+
+#ifdef __NR_signalfd
+syscall(signalfd4,__signalfd4)
+#endif
diff -urN -x .git dietlibc-0.33/syscalls.s/syncfs.S dietlibc/syscalls.s/syncfs.S
--- dietlibc-0.33/syscalls.s/syncfs.S	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/syscalls.s/syncfs.S	2015-01-01 12:14:43.531605560 +0000
@@ -0,0 +1,3 @@
+#include "syscalls.h"
+
+syscall(syncfs,syncfs)
diff -urN -x .git dietlibc-0.33/syscalls.s/timerfd_gettime.S dietlibc/syscalls.s/timerfd_gettime.S
--- dietlibc-0.33/syscalls.s/timerfd_gettime.S	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/syscalls.s/timerfd_gettime.S	2015-01-01 12:14:43.531605560 +0000
@@ -0,0 +1,3 @@
+#include "syscalls.h"
+
+syscall(timerfd_gettime,timerfd_gettime)
diff -urN -x .git dietlibc-0.33/syscalls.s/timerfd_settime.S dietlibc/syscalls.s/timerfd_settime.S
--- dietlibc-0.33/syscalls.s/timerfd_settime.S	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/syscalls.s/timerfd_settime.S	2015-01-01 12:14:43.531605560 +0000
@@ -0,0 +1,3 @@
+#include "syscalls.h"
+
+syscall(timerfd_settime,timerfd_settime)
diff -urN -x .git dietlibc-0.33/t.c dietlibc/t.c
--- dietlibc-0.33/t.c	2010-09-25 17:03:25.000000000 +0000
+++ dietlibc/t.c	2015-01-01 12:14:43.531605560 +0000
@@ -47,6 +47,7 @@
 #include <pty.h>
 #include <sys/statfs.h>
 #include <mqueue.h>
+#include <ucontext.h>
 #ifdef __dietlibc__
 #include <md5.h>
 #include <write12.h>
@@ -108,12 +109,27 @@
 #define malloc(x) ({typeof(x) y=x; (y<0 || (size_t)(y)!=y ? 0 : malloc(y));})
 
 int main(int argc,char *argv[]) {
+  int n;
+  struct ucontext uc;
+  n=0;
+  getcontext(&uc);
+  puts("getcontext returned");
+  if (n==0) {
+    ++n;
+    setcontext(&uc);
+    puts("should not get here");
+    exit(1);
+  }
+  puts("all ok");
+  return 0;
 #if 0
   char* a=malloc(-3);
   char* b=malloc(0xffffffffull+1);
   printf("%p %p\n",a,b);
 #endif
+#if 0
   printf("%u\n",getpagesize());
+#endif
 #if 0
   struct stat s;
   time_t t=time(0);
@@ -172,7 +188,7 @@
   strcpy(buf+i,"/bin:/bin");
   putenv(buf);
   execvp("sh",argv);
-  printf("%d\n",islower(''));
+  printf("%d\n",islower(0xfc));
 #endif
 #if 0
   char buf[101];
diff -urN -x .git dietlibc-0.33/test/adjtime.c dietlibc/test/adjtime.c
--- dietlibc-0.33/test/adjtime.c	2002-08-05 18:08:24.000000000 +0000
+++ dietlibc/test/adjtime.c	2015-01-01 12:14:43.531605560 +0000
@@ -1,9 +1,25 @@
 #include <stdio.h>
+#include <assert.h>
+#include <errno.h>
 #include <sys/time.h>
 
 int main() {
   struct timeval a,b;
+  int rc;
   a.tv_sec=0; a.tv_usec=0;
-  printf("%d\n",adjtime(&a,&b));
+  rc = adjtime(&a,&b);
+  assert(!rc || errno == EPERM);
+
+  rc = adjtime(&a, NULL);
+  assert(!rc || errno == EPERM);
+
+  rc = adjtime(NULL,&b);
+  assert(!rc);
+  assert(b.tv_sec  < 30);	    /* 30 seconds delta is very unlikely... */
+  assert(b.tv_sec  > -30);	    /* 30 seconds delta is very unlikely... */
+  assert(b.tv_usec > -1000000);
+  assert(b.tv_usec < 1000000);
+
+  printf("%lu/%d\n", (unsigned long)b.tv_sec, (int)b.tv_usec);
   return 0;
 }
diff -urN -x .git dietlibc-0.33/test/asctime.c dietlibc/test/asctime.c
--- dietlibc-0.33/test/asctime.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/test/asctime.c	2015-01-01 12:14:43.531605560 +0000
@@ -0,0 +1,27 @@
+#include <assert.h>
+#include <stdlib.h>
+#include <time.h>
+
+int main(void)
+{
+	char		*buf;
+	struct tm const	tm = {
+		.tm_sec = 20,
+		.tm_min = 21,
+		.tm_hour = 22,
+		.tm_mday = 10,
+		.tm_mon = 11,
+		.tm_year = 112,
+	};
+	char		*res;
+
+	buf = malloc(4096);
+	assert(buf != NULL);
+	memset(buf, 23, 4096);
+
+	res = asctime_r(&tm, buf);
+	assert(strcmp(res, asctime(&tm)) == 0);
+	assert(strcmp(res, "Sun Dec 10 22:21:20 2012\n") == 0);
+
+	return EXIT_SUCCESS;
+}
diff -urN -x .git dietlibc-0.33/test/asprintf.c dietlibc/test/asprintf.c
--- dietlibc-0.33/test/asprintf.c	2003-12-15 13:07:42.000000000 +0000
+++ dietlibc/test/asprintf.c	2015-01-01 12:14:43.531605560 +0000
@@ -13,7 +13,7 @@
  assert(strlen(path) == asprintlen);
 	     
  printf("%s\n", path);
- asprintlen=asprintf(&path, "/proc" "/%d/stat", strlen(argv[1]));
+ asprintlen=asprintf(&path, "/proc" "/%zu/stat", strlen(argv[1]));
  assert(strlen(path) == asprintlen);
  printf("%s\n", path);
 
diff -urN -x .git dietlibc-0.33/test/atexit.c dietlibc/test/atexit.c
--- dietlibc-0.33/test/atexit.c	2003-02-20 15:57:12.000000000 +0000
+++ dietlibc/test/atexit.c	2015-01-01 12:14:43.531605560 +0000
@@ -2,7 +2,7 @@
 #include <unistd.h>
 
 void blah(void) {
-  write(2,"atexit\n",7);
+  write(1,"atexit\n",7);
 }
 
 int main() {
diff -urN -x .git dietlibc-0.33/test/atfile.c dietlibc/test/atfile.c
--- dietlibc-0.33/test/atfile.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/test/atfile.c	2015-01-01 12:14:43.531605560 +0000
@@ -0,0 +1,111 @@
+#define _GNU_SOURCE
+#define _XOPEN_SOURCE 700
+#define _FILE_OFFSET_BITS 64
+
+#include <stdlib.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <assert.h>
+#include <stdio.h>
+#include <sys/stat.h>
+
+#define TMPDIR	"/tmp"
+
+#define TEST(_op)	do {						\
+		int rc = (_op);						\
+		if (rc < 0) {						\
+			printf("%s:%u: %s: %u/%s\n", __FILE__, __LINE__,	\
+			       # _op, errno, strerror(errno));		\
+			abort();					\
+		}							\
+	} while (0)
+
+#define memeq(_a, _b) \
+	((memcmp(_a, _b, sizeof *(_a)) == 0 ? 0 : -1))
+
+#define memne(_a, _b) \
+	((memcmp(_a, _b, sizeof *(_a)) == 0 ? -1 : 0))
+
+int main(void)
+{
+	char dname_buf[] = "/tmp/test-mmap.XXXXXX";
+	char *dname;
+	int dir_fd;
+	int file_fd;
+	struct stat st[5];
+
+	/* check whether *at(2) syscalls are available */
+	dir_fd = openat(AT_FDCWD, "/", O_DIRECTORY|O_RDONLY);
+	if (dir_fd == -1 && errno == ENOSYS)
+		return EXIT_SUCCESS;	/* kernel too old */
+
+	assert(dir_fd != -1);
+	close(dir_fd);
+
+	/* create a tree like
+	 * /
+	 * +- tmp/
+	 *    +- <tmpname>/
+	 *       |- test/
+	 *       |- some-file
+	 *       +- some-link -> some-file
+	 */
+	dname = mkdtemp(dname_buf);
+	assert(dname != NULL);
+
+	dir_fd = open(dname, O_DIRECTORY|O_RDONLY);
+	assert(dir_fd != -1);
+
+	TEST(mkdirat(dir_fd, "test", 0700));
+	TEST(chdir(dname));
+	TEST(chdir("test"));
+
+	file_fd = openat(dir_fd, "some-file", O_WRONLY|O_CREAT, 0400);
+	assert(file_fd != -1);
+
+	write(file_fd, "some text\n", 10);
+	TEST(close(file_fd));
+
+	TEST(symlinkat("some-file", dir_fd, "some-link"));
+	TEST(symlinkat("dangling", dir_fd, "dangling-link"));
+
+	/* now check, whether attributes of 'some-file' and 'some-link'
+	 * returned by stat(2), lstat(2) and fstatat(2) are consistent */
+	TEST(stat("../some-file", &st[0]));
+	TEST(lstat("../some-link", &st[1]));
+
+	TEST(fstatat(dir_fd, "some-file", &st[2], 0));
+	TEST(fstatat(dir_fd, "some-link", &st[3], AT_SYMLINK_NOFOLLOW));
+	TEST(fstatat(dir_fd, "some-link", &st[4], 0));
+
+	TEST(faccessat(dir_fd, "some-file", R_OK, 0));
+	TEST((faccessat(dir_fd, "some-file", W_OK, 0) == -1 &&
+	      errno == EACCES) ? 0 : -1);;
+
+	if (1)
+		fputs("skipping faccessat(..., AT_SYMLINK_NOFOLLOW) checks for now...\n",
+		      stderr);
+	else {
+		/* this is broken for dietlibc; the 'flags' parameter is not checked
+		 * by the kernel but must be handled by the libc itself */
+		TEST(faccessat(dir_fd, "some-link", W_OK, AT_SYMLINK_NOFOLLOW));
+		TEST(faccessat(dir_fd, "dangling-link", R_OK, AT_SYMLINK_NOFOLLOW));
+	}
+
+	assert(st[0].st_mode == (0400 | S_IFREG));
+	assert(S_ISLNK(st[1].st_mode));
+
+	TEST(memne(&st[0], &st[1]));
+	TEST(memeq(&st[0], &st[2]));
+	TEST(memeq(&st[0], &st[4]));
+	TEST(memeq(&st[1], &st[3]));
+
+	/* and cleanup the mess... */
+	TEST(unlinkat(dir_fd, "some-link", 0));
+	TEST(unlinkat(dir_fd, "some-file", 0));
+	TEST(unlinkat(dir_fd, "dangling-link", 0));
+	TEST(unlinkat(dir_fd, "test", AT_REMOVEDIR));
+	TEST(rmdir(dname));
+
+	return EXIT_SUCCESS;
+}
diff -urN -x .git dietlibc-0.33/test/byteswap.c dietlibc/test/byteswap.c
--- dietlibc-0.33/test/byteswap.c	2003-12-15 13:07:42.000000000 +0000
+++ dietlibc/test/byteswap.c	2015-01-01 12:14:43.531605560 +0000
@@ -9,12 +9,12 @@
   snprintf(buf,100,"%x %x", bswap_16(0x1234), bswap_16(0x5678));
   assert(strcmp(buf, "3412 7856") == 0);
   
-  printf("%lx\n",bswap_32(0x12345678));
-  snprintf(buf,100,"%lx", bswap_32(0x12345678));
+  printf("%x\n",(unsigned int)bswap_32(0x12345678));
+  snprintf(buf,100,"%x", (unsigned int)bswap_32(0x12345678));
   assert(strcmp(buf, "78563412") == 0);
 
-  printf("%qx\n",bswap_64(0x123456789ABCDEFull));
-  snprintf(buf,100,"%qx", bswap_64(0x123456789ABCDEFull));
+  printf("%llx\n",(unsigned long long)bswap_64(0x123456789ABCDEFull));
+  snprintf(buf,100,"%llx", (unsigned long long)bswap_64(0x123456789ABCDEFull));
   assert(strcmp(buf, "efcdab8967452301") == 0);
   return 0; 
 }
diff -urN -x .git dietlibc-0.33/test/cycles.c dietlibc/test/cycles.c
--- dietlibc-0.33/test/cycles.c	2004-08-27 15:09:14.000000000 +0000
+++ dietlibc/test/cycles.c	2015-01-01 12:14:43.531605560 +0000
@@ -12,8 +12,21 @@
   asm volatile ("rdtsc" : "=a" (l), "=d" (h)); \
   dst = (((uint64_t)h) << 32) | l;                             \
 } while (0)
+#elif defined (__powerpc64__)
+#define RDTSC(dst) asm volatile ("mftb %0" : "=r" (dst))
+#elif defined (__powerpc__)
+#define RDTSC(dst) do { \
+  uint32_t chk, tbl, tbu; \
+  /* The code below is as suggested in Motorola reference manual for 32 bits PPCs. */ \
+  __asm__ __volatile__ ("1: mftbu %0; mftb %1; mftbu %2; cmpw %2,%0; bne 1b" \
+    : "=r" (tbu), "=r" (tbl), "=r" (chk) ); \
+  dst = ((uint64_t)tbu << 32) | tbl; \
+} while (0)
+#elif defined (__sparcv9__)
+#define RDTSC(dst) asm volatile ("rd %%tick, %%0":"=r"(dst))
 #else
-#error "Unimplemented rdtsc"
+#warning "Unimplemented rdtsc"
+#define RDTSC(dst) dst = 0
 #endif
 
 extern char **environ;
@@ -24,7 +37,7 @@
   if (!fork()) { execve(argv[1],argv+1,environ); exit(1); }
   wait(0);
   RDTSC(b);
-  printf("%llu cycles\n",b-a);
+  printf("%llu cycles\n",(unsigned long long)(b-a));
 
   return 0;
 }
diff -urN -x .git dietlibc-0.33/test/dirent/.gitignore dietlibc/test/dirent/.gitignore
--- dietlibc-0.33/test/dirent/.gitignore	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/test/dirent/.gitignore	2015-01-01 12:14:43.531605560 +0000
@@ -0,0 +1,2 @@
+/opendir-tst1
+/tst-seekdir
diff -urN -x .git dietlibc-0.33/test/ftruncate.c dietlibc/test/ftruncate.c
--- dietlibc-0.33/test/ftruncate.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/test/ftruncate.c	2015-01-01 12:14:43.531605560 +0000
@@ -0,0 +1,54 @@
+#define _GNU_SOURCE
+#define _XOPEN_SOURCE 600
+#define _FILE_OFFSET_BITS 64
+
+#include <stdlib.h>
+#include <fcntl.h>
+#include <assert.h>
+#include <unistd.h>
+#include <sys/stat.h>
+
+#define CHECK(_sz)				\
+  assert(ftruncate(fd, (_sz)) == 0);		\
+  assert(fstat(fd, &st) == 0);			\
+  assert(st.st_size == (_sz));			\
+
+#define CHECK64(_sz)				\
+  assert(ftruncate64(fd, (_sz)) == 0);		\
+  assert(fstat64(fd, &st64) == 0);		\
+  assert(st64.st_size == (_sz));		\
+
+int main(void)
+{
+  char file[] = "/tmp/dietlibc-fadvise-test.XXXXXX";
+  int fd;
+  struct stat st;
+
+  fd = mkstemp(file);
+  unlink(file);
+
+  assert(ftruncate(fd, 500000) == 0);
+  assert(fstat(fd, &st) == 0);
+
+  if (st.st_blocks > 1) {
+    /* spare files not supported by filesystem :( */
+    return EXIT_SUCCESS;
+  }
+
+  CHECK(1);
+  CHECK(0x7fffffff);
+
+#if __WORDSIZE == 32
+  {
+    struct stat64 st64;
+    CHECK64(1);
+    CHECK64(0x7fffffff);
+    CHECK64(0x80000001ul);
+    CHECK64(0x17fffffffull);
+  }
+#else
+  CHECK(0x17fffffffull);
+#endif
+
+  return EXIT_SUCCESS;
+}
diff -urN -x .git dietlibc-0.33/test/getmntent.c dietlibc/test/getmntent.c
--- dietlibc-0.33/test/getmntent.c	2003-12-15 13:07:42.000000000 +0000
+++ dietlibc/test/getmntent.c	2015-01-01 12:14:43.534938894 +0000
@@ -33,10 +33,6 @@
 
  printf("closing /etc/fstab\n");
  assert ( 1 == endmntent(fstab));
- printf("closing /etc/fstab again\n");
- assert ( 1 == endmntent(fstab)); /* endmntent must always return 1 */
- printf("entmntent(0)\n");
- assert ( 1 == endmntent(0)); /* causes a segfault with diet libc */
+
  return 0;
 }
-
diff -urN -x .git dietlibc-0.33/test/getservbyname.c dietlibc/test/getservbyname.c
--- dietlibc-0.33/test/getservbyname.c	2003-12-15 13:07:42.000000000 +0000
+++ dietlibc/test/getservbyname.c	2015-01-01 12:14:43.534938894 +0000
@@ -1,5 +1,6 @@
 #include <stdio.h>
 #include <netdb.h>
+#include <arpa/inet.h>
 
 int main(int argc,char *argv[]) {
   struct servent* se;
diff -urN -x .git dietlibc-0.33/test/.gitignore dietlibc/test/.gitignore
--- dietlibc-0.33/test/.gitignore	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/test/.gitignore	2015-01-01 12:14:43.531605560 +0000
@@ -0,0 +1,91 @@
+.testenv.sh
+/adjtime
+/alarm
+/argv
+/asctime
+/asprintf
+/atexit
+/atfile
+/bsearch
+/byteswap
+/calloc
+/confstr
+/cycles
+/empty
+/fadvise
+/ffs
+/flush
+/fnmatch
+/fputc
+/ftruncate
+/ftw
+/fwrite
+/getaddrinfo
+/getdelim
+/getenv
+/getgrnam
+/gethostbyaddr
+/gethostbyname
+/gethostbyname_r
+/getmntent
+/getopt
+/getpass
+/getpwnam
+/getservbyname
+/getservbyport
+/getusershell
+/glob
+/grent
+/hasmntopt
+/hello
+/iconv
+/if_nameindex
+/ltostr
+/malloc-debugger
+/math
+/md5_testharness
+/memccpy
+/memchr
+/memcmp
+/memrchr
+/memusage
+/mktime
+/mmap_test
+/pipe
+/printf
+/printftest
+/protoent
+/prototypes
+/putenv
+/pwent
+/rand48
+/read1
+/readdir
+/readdir64
+/regex
+/select
+/sendfile
+/servent
+/setjmp
+/siglist
+/sigsetjmp
+/speed
+/spent
+/sprintf
+/sscanf
+/stdarg
+/strcasecmp
+/strcmp
+/strncat
+/strncpy
+/strptime
+/strrchr
+/strstr
+/strtol
+/sysconf
+/sysenter
+/test
+/testing
+/ungetc
+/utime
+/waitpid
diff -urN -x .git dietlibc-0.33/test/if_nameindex.c dietlibc/test/if_nameindex.c
--- dietlibc-0.33/test/if_nameindex.c	2003-02-20 15:57:12.000000000 +0000
+++ dietlibc/test/if_nameindex.c	2015-01-01 12:14:43.534938894 +0000
@@ -1,8 +1,12 @@
 #include <stdio.h>
+#include <assert.h>
 #include <net/if.h>
 
 int main() {
   struct if_nameindex* t=if_nameindex();
+
+  assert(t != NULL);
+
   if (t) {
     struct if_nameindex* t1=t;
     while (t->if_index) {
diff -urN -x .git dietlibc-0.33/test/inet/.gitignore dietlibc/test/inet/.gitignore
--- dietlibc-0.33/test/inet/.gitignore	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/test/inet/.gitignore	2015-01-01 12:14:43.534938894 +0000
@@ -0,0 +1,3 @@
+/test_ifindex
+/tst-gethnm
+/tst-ntoa
diff -urN -x .git dietlibc-0.33/test/Makefile dietlibc/test/Makefile
--- dietlibc-0.33/test/Makefile	2012-01-24 18:24:29.000000000 +0000
+++ dietlibc/test/Makefile	2015-01-01 12:14:43.531605560 +0000
@@ -7,14 +7,14 @@
 
 LCOMPAT=-lcompat
 
-TESTPROGRAMS=adjtime alarm argv asprintf atexit bsearch byteswap calloc confstr cycles empty fadvise flush fnmatch \
-fputc ftw fwrite getaddrinfo getenv getgrnam gethostbyaddr gethostbyname \
+TESTPROGRAMS=adjtime alarm argv asctime asprintf atexit atfile bsearch byteswap calloc confstr cycles empty fadvise flush fnmatch \
+fputc ftruncate ftw fwrite getaddrinfo getenv getgrnam gethostbyaddr gethostbyname \
 gethostbyname_r getmntent getopt getpass getpwnam getservbyname getservbyport getusershell \
-glob grent hasmntopt hello iconv if_nameindex ltostr malloc-debugger md5_testharness \
+glob grent hasmntopt hello iconv if_nameindex ltostr malloc-debugger math md5_testharness \
 memccpy memchr memcmp memrchr memusage mktime mmap_test pipe printf printftest \
-protoent prototypes putenv pwent rand48 read1 readdir regex select sendfile servent siglist \
-speed spent sprintf sscanf stdarg strcasecmp strcmp strncat strncpy strptime strrchr \
-strstr strtol sysenter ungetc utime waitpid
+protoent prototypes putenv pwent rand48 read1 readdir readdir64 regex select sendfile servent setjmp siglist \
+sigsetjmp speed spent sprintf sscanf stdarg strcasecmp strcmp strncat strncpy strptime strrchr \
+strstr strtol sysconf sysenter unaligned ungetc utime waitpid
 
 test: $(TESTPROGRAMS)
 
diff -urN -x .git dietlibc-0.33/test/malloc-debugger.c dietlibc/test/malloc-debugger.c
--- dietlibc-0.33/test/malloc-debugger.c	2003-02-20 15:57:13.000000000 +0000
+++ dietlibc/test/malloc-debugger.c	2015-01-01 12:14:43.534938894 +0000
@@ -4,7 +4,7 @@
 int main() {
   char* c=malloc(13);
   char* tmp;
-  fprintf(stderr,"got %p\n",c);
+  fprintf(stdout,"got %p\n",c);
   c[0]=14;
 //  c[15]=0;
   tmp=realloc(c,12345);
diff -urN -x .git dietlibc-0.33/test/math.c dietlibc/test/math.c
--- dietlibc-0.33/test/math.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/test/math.c	2015-01-01 12:14:43.534938894 +0000
@@ -0,0 +1,29 @@
+#include <math.h>
+#include <float.h>
+#include <assert.h>
+
+int main()
+{
+  extern int __isinf(double d);
+  extern int __isnan(double d);
+
+#if (__GNUC__ > 3) || ((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3))
+  assert(__isinf(__builtin_inff())  == +1);
+  assert(__isinf(-__builtin_inff()) == -1);
+
+  assert(__isinf(__builtin_inf())   == +1);
+  assert(__isinf(-__builtin_inf())  == -1);
+
+  assert(__isnan(__builtin_nan("")));
+#endif
+
+  assert(__isinf((DBL_MAX * DBL_MAX))  == +1);
+  assert(__isinf(-(DBL_MAX * DBL_MAX)) == -1);
+
+  assert(isinf((DBL_MAX * DBL_MAX)));
+  assert(isinf(-(DBL_MAX * DBL_MAX)));
+
+  //assert(isnan(nan("")));
+
+  return 0;
+}
diff -urN -x .git dietlibc-0.33/test/mktime.c dietlibc/test/mktime.c
--- dietlibc-0.33/test/mktime.c	2004-03-27 00:47:00.000000000 +0000
+++ dietlibc/test/mktime.c	2015-01-01 12:14:43.534938894 +0000
@@ -9,15 +9,15 @@
   t.tm_mday=29;
   t.tm_mon=2;
   t.tm_year=100;
-  printf("%d\n",mktime(&t));
+  printf("%ld\n",(long)mktime(&t));
   t.tm_mday=1;
   t.tm_mon=3;
   t.tm_year=102;
-  printf("%d\n",mktime(&t));
+  printf("%ld\n",(long)mktime(&t));
   t.tm_mday=1;
   t.tm_mon=6;
   t.tm_year=102;
-  printf("%d\n",mktime(&t));
+  printf("%ld\n",(long)mktime(&t));
   return 0;
 }
 
diff -urN -x .git dietlibc-0.33/test/mmap_test.c dietlibc/test/mmap_test.c
--- dietlibc-0.33/test/mmap_test.c	2002-02-18 00:37:31.000000000 +0000
+++ dietlibc/test/mmap_test.c	2015-01-01 12:14:43.534938894 +0000
@@ -1,12 +1,13 @@
-
 #include <stdio.h>
 #include <fcntl.h>
 #include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
 #include <sys/mman.h>
 #include <errno.h>
 
-#define FILENAME   "/tmp/zz_temp_mmap_test"
-#define TESTSTRING "This is a test string"
+#define TESTSTRING0 "This is a test string"
+#define TESTSTRING1 "Another string for testing"
 
 
 int main (int argc, char * argv[])
@@ -14,16 +15,26 @@
    int fd;
    void *filememory_1;
    void *filememory_2;
-   
-   fd = open (FILENAME, O_RDWR | O_CREAT);
-   
+   void *filememory_3;
+   unsigned int pg_sz = sysconf(_SC_PAGESIZE);
+   char fname[] = "/tmp/test-mmap.XXXXXX";
+
+   fd = mkstemp(fname);
    if (fd < 0)
    {
-      fprintf (stderr, "Couldn't open %s for writing\n", FILENAME);
+      fprintf (stderr, "Couldn't open %s for writing\n", fname);
       return (1);
    }
 
-   write (fd, TESTSTRING, sizeof(TESTSTRING));
+   unlink(fname);
+
+   write (fd, TESTSTRING0, sizeof TESTSTRING0);
+
+   ftruncate(fd, pg_sz);
+   lseek(fd, pg_sz, SEEK_SET);
+   write(fd, TESTSTRING1, sizeof TESTSTRING1);
+
+   ftruncate(fd, 2*pg_sz);
 
    /*
       Try mmapping the newly created file...
@@ -38,6 +49,18 @@
    }
 
    /*
+      Test mapping at a given offset
+    */
+
+   filememory_3 = mmap (NULL, 0x0100, PROT_READ, MAP_PRIVATE, fd, pg_sz);
+
+   if (filememory_3 == (void *) -1)
+   {
+      perror("mmap (pg_sz) returned error");
+      return (1);
+   }
+
+   /*
       Try mmapping with a bogus file descriptor... (should fail)
    */
 
@@ -49,32 +72,33 @@
       return (1);
    }
    
-   close (fd);
-
    /*
       Check that we can read back from the file OK
    */
 
-   if ((*(unsigned char *) filememory_1) != TESTSTRING[0])
+   if (memcmp(filememory_1, TESTSTRING0, sizeof TESTSTRING0) != 0)
    {
       fprintf (stderr, "mmap doesn't give expected data...\n");
       return (1);
    }
-   
-   /*
-      fixme: check unmapping as well.... ??
-   */
 
+   if (memcmp(filememory_3, TESTSTRING1, sizeof TESTSTRING1) != 0)
+   {
+      fprintf (stderr, "mmap (pg_sz) doesn't give expected data...\n");
+      return (1);
+   }
+
+   if (munmap(filememory_3, 0x0100) < 0 ||
+       munmap(filememory_1, 0x0100) < 0)
+   {
+      perror("munmap()");
+      return 1;
+   }
 
    /*
       Clean up.
    */
-
-   if (unlink (FILENAME) != 0)
-   {
-      fprintf (stderr, "Unexpected problem deleting the tempfile... ?\n");
-      return (1);
-   }
+   close (fd);
 
    return (0);
 }
diff -urN -x .git dietlibc-0.33/test/pipe.c dietlibc/test/pipe.c
--- dietlibc-0.33/test/pipe.c	2002-05-13 15:56:48.000000000 +0000
+++ dietlibc/test/pipe.c	2015-01-01 12:14:43.534938894 +0000
@@ -5,6 +5,9 @@
 main (void)
 {
 	int fd[2];
+	close(3);
+	close(4);
+
 	assert (!pipe (fd));
 	/* if for some reason the parent process has fd3 or fd4
 	   already open, then this will fail although there is
diff -urN -x .git dietlibc-0.33/test/printf.c dietlibc/test/printf.c
--- dietlibc-0.33/test/printf.c	2008-05-06 17:18:35.000000000 +0000
+++ dietlibc/test/printf.c	2015-01-01 12:14:43.534938894 +0000
@@ -2,11 +2,26 @@
 #include <string.h>
 #include <stdlib.h>
 #include <assert.h>
+#include <math.h>
+#include <float.h>
 #include <sys/param.h>
 #include <locale.h>
 
 #define ALGN		5
 
+#ifndef INFINITY
+#  if (__GNUC__ > 3) || ((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3))
+#    define INFINITY	(__builtin_inf())
+#  endif
+#endif
+
+#ifndef NAN
+#  if (__GNUC__ > 3) || ((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3))
+#    define NAN		(__builtin_nan(""))
+#  endif
+#endif
+
+
 // https://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=112986
 #if 0
 #undef  assert
@@ -60,7 +75,7 @@
   TEST_SNPRINTF(EXP,  0,                __VA_ARGS__);		\
   TEST_SNPRINTF(EXP,  sizeof(EXP)+ALGN, __VA_ARGS__);		\
   TEST_SNPRINTF_NULL(EXP, __VA_ARGS__)
-  
+
 
 int main()
 {
@@ -101,7 +116,7 @@
   TEST("42.23",   "%5.2f",  42.23);
   TEST("42.23",   "%5.4g",  42.23);
   TEST(" 42.2",   "%5.3g",  42.23);
-  
+
   TEST("   1",     "%*i",   4, 1);
   TEST("   1",     "%4i",   1);
   TEST("1   ",     "%-4i",  1);
@@ -131,13 +146,32 @@
   TEST("-01234",   "%6.5i", -1234);
   TEST("  1234",   "%6.5s", "1234");
 
+#ifdef INFINITY
+  TEST("inf",	"%f", INFINITY);
+  TEST("-inf",	"%f", -INFINITY);
+  TEST("INF",	"%F", INFINITY);
+  TEST("-INF",	"%F", -INFINITY);
+
+  TEST("inf",	"%g", INFINITY);
+  TEST("-inf",	"%g", -INFINITY);
+  TEST("INF",	"%G", INFINITY);
+  TEST("-INF",	"%G", -INFINITY);
+#endif
+
+#ifdef NAN
+  TEST("nan",	"%f", NAN);
+  TEST("NAN",	"%F", NAN);
+  TEST("nan",	"%g", NAN);
+  TEST("NAN",	"%G", NAN);
+#endif
+
 #ifdef XSI_TESTS
   setlocale(LC_ALL, "de_DE");
-  
+
   TEST("1.234",    "%'u", 1234);
   TEST("2 1",      "%2$u %1$u",  1, 2);
 #endif
-  
-  
+
+
   return EXIT_SUCCESS;
 }
diff -urN -x .git dietlibc-0.33/test/printftest.c dietlibc/test/printftest.c
--- dietlibc-0.33/test/printftest.c	2003-12-15 13:07:42.000000000 +0000
+++ dietlibc/test/printftest.c	2015-01-01 12:14:43.534938894 +0000
@@ -101,8 +101,8 @@
   printf("#%i#\n",18);
   printf("#%d#\n",18);
   printf("#%u#\n",18);
-  printf("#%lu#\n",18);
-  printf("#%li#\n",18);
+  printf("#%lu#\n",18l);
+  printf("#%li#\n",18l);
   printf("#%-+#06d#\n", -123);
   printf("#%-+#6d#\n", -123);
   printf("#%+#06d#\n", -123);
@@ -142,7 +142,7 @@
 	    buf);
     memset(buf2,0,sizeof(buf));
     i=snprintf(buf2, 256, "%.9999u", 10);
-    printf("%i %i\n",i,strlen(buf2));
+    printf("%i %li\n",i,strlen(buf2));
     
     printf ("snprintf (\"%%.999999u\", 10) == %d\n",
     	    snprintf(buf2, sizeof(buf2), "%.999999u", 10));
diff -urN -x .git dietlibc-0.33/test/rand48.c dietlibc/test/rand48.c
--- dietlibc-0.33/test/rand48.c	2002-05-29 13:20:40.000000000 +0000
+++ dietlibc/test/rand48.c	2015-01-01 12:14:43.534938894 +0000
@@ -6,16 +6,16 @@
 {
   static unsigned short  data[7] = { 1, 2, 3, 4, 5, 6, 7 };
 
-  printf ("one   %X\n", mrand48 ());
-  printf ("two   %X\n", mrand48 ());
-  printf ("three %X\n", mrand48 ());
+  printf ("one   %lX\n", mrand48 ());
+  printf ("two   %lX\n", mrand48 ());
+  printf ("three %lX\n", mrand48 ());
 
   lcong48 (data);
   printf ("after lcong48:\n");
 
-  printf ("one   %X\n", mrand48 ());
-  printf ("two   %X\n", mrand48 ());
-  printf ("three %X\n", mrand48 ());
+  printf ("one   %lX\n", mrand48 ());
+  printf ("two   %lX\n", mrand48 ());
+  printf ("three %lX\n", mrand48 ());
 
   return 0;
 }
diff -urN -x .git dietlibc-0.33/test/readdir64.c dietlibc/test/readdir64.c
--- dietlibc-0.33/test/readdir64.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/test/readdir64.c	2015-01-01 12:14:43.534938894 +0000
@@ -0,0 +1,2 @@
+#define _FILE_OFFSET_BITS 64
+#include "readdir.c"
diff -urN -x .git dietlibc-0.33/test/readdir.c dietlibc/test/readdir.c
--- dietlibc-0.33/test/readdir.c	2003-02-20 15:57:13.000000000 +0000
+++ dietlibc/test/readdir.c	2015-01-01 12:14:43.534938894 +0000
@@ -1,17 +1,103 @@
-#define _FILE_OFFSET_BITS 64
+#define _BSD_SOURCE
 #include <dirent.h>
 #include <stdio.h>
+#include <stdlib.h>
 #include <errno.h>
+#include <fcntl.h>
+
+#include "../dietdirent.h"
+
+static int rc = 0;
+
+static void xputs(char const *str)
+{
+  fputs(str, stderr);
+  rc = 1;
+}
+
+static int create_file(char const *dir, char const *name)
+{
+  char	buf[strlen(dir) + strlen(name) + sizeof("/")];
+  strcpy(buf, dir);
+  strcat(buf, "/");
+  strcat(buf, name);
+
+  return close(open(buf, O_WRONLY|O_CREAT,0666));
+}
+
+static int remove_file(char const *dir, char const *name)
+{
+  char	buf[strlen(dir) + strlen(name) + sizeof("/")];
+  strcpy(buf, dir);
+  strcat(buf, "/");
+  strcat(buf, name);
+
+  return unlink(buf);
+}
 
 int main() {
-  DIR* D=opendir(".");
-  struct dirent* d;
+  char tmpdir[] = "/tmp/readdir.XXXXXX";
+  unsigned long res = 0;
+  DIR* D;
+  if (!mkdtemp(tmpdir)) {
+    perror("mkdtemp");
+    return 1;
+  }
+  D=opendir(tmpdir);
   if (!D) {
     perror("opendir");
+    rmdir(tmpdir);
     return 1;
   }
+
+  if (chdir(tmpdir) < 0) {
+    perror("chdir");
+    rmdir(tmpdir);
+    return 1;
+  }
+  close(open("bar",O_WRONLY|O_CREAT,0666));
+  close(open("baz",O_WRONLY|O_CREAT,0666));
+
+  struct dirent* d;
+
   while ((d=readdir(D))) {
-    printf("found %s\n",d->d_name);
+    struct stat		st;
+
+    if (strcmp(d->d_name,".") == 0)
+      res |= 1<<0;
+    else if (strcmp(d->d_name,"..") == 0)
+      res |= 1<<1;
+    else if (strcmp(d->d_name,"bar") == 0)
+      res |= 1<<2;
+    else if (strcmp(d->d_name,"baz") == 0)
+      res |= 1<<3;
+    else
+      xputs("got additional file");
+
+    if (lstat(d->d_name, &st) < 0) {
+      perror("lstat");
+      rc = 1;
+    } else if (st.st_ino != d->d_ino) {
+      xputs("mismatch in ino");
+    } else if (d->d_type == DT_UNKNOWN) {
+      /* noop */
+    } else if ((d->d_type == DT_REG && !S_ISREG(st.st_mode)) ||
+	       (d->d_type == DT_DIR && !S_ISDIR(st.st_mode))) {
+      xputs("mismatch in d_type");
+    } else if (d->d_type != DT_REG && d->d_type != DT_DIR) {
+      xputs("unexpected d_type");
+    }
+
+    if (telldir(D) != d->d_off) {
+      xputs("mismatch with telldir");
+    }
+
+    unlink(d->d_name);
   }
-  return 0;
+
+  if (res != 0x0f)
+    xputs("did not got all expected files");
+
+  rmdir(tmpdir);
+  return rc;
 }
diff -urN -x .git dietlibc-0.33/test/regex.c dietlibc/test/regex.c
--- dietlibc-0.33/test/regex.c	2010-09-25 17:03:28.000000000 +0000
+++ dietlibc/test/regex.c	2015-01-01 12:14:43.534938894 +0000
@@ -117,6 +117,9 @@
   assert(regexec(&r,"foobarfoo",10,matches,0)==0);
   regfree(&r);
 
+  assert(regcomp(&r,"^(postmaster|abuse|(felix|leitner|zoke|sanjiyan|dreesen|akuma|braun|kristine|gilda|oskar|moritz)(-[^@]*|))@qarx.de$",REG_NOSUB|REG_EXTENDED)==0);
+  assert(regexec(&r,"apollo.bingo-ev.de@fefe.de",10,matches,0)!=0);
+
 #if 0
   printf("regcomp %d\n",regcomp(&r,"\\.( ? ? ?\\.)*\\.",REG_EXTENDED|REG_NOSUB));
   printf("regexec %d\n",regexec(&r,buf,1,0,0));
diff -urN -x .git dietlibc-0.33/test/runtests.sh dietlibc/test/runtests.sh
--- dietlibc-0.33/test/runtests.sh	2012-01-24 18:24:29.000000000 +0000
+++ dietlibc/test/runtests.sh	2015-01-01 12:14:43.534938894 +0000
@@ -1,6 +1,6 @@
 SUBDIRS="dirent inet stdio string stdlib time"
 
-TESTPROGRAMS="adjtime alarm argv atexit bsearch byteswap calloc confstr empty fadvise flush fputc ffs fnmatch ftw fwrite getaddrinfo getenv getdelim getgrnam gethostbyaddr gethostbyname gethostbyname_r getmntent getopt getpwnam getservbyname getservbyport getusershell glob grent hasmntopt hello iconv if_nameindex ltostr malloc-debugger md5_testharness memccpy memchr memcmp memrchr memusage mktime mmap_test pipe printf printftest protoent prototypes putenv pwent rand48 readdir regex select sendfile servent siglist speed spent sprintf sscanf stdarg strcasecmp strcmp strncat strncpy strptime strrchr strstr strtol sysenter ungetc utime waitpid"
+TESTPROGRAMS="adjtime alarm argv asctime atexit atfile bsearch byteswap calloc confstr empty fadvise flush fputc ffs fnmatch ftruncate ftw fwrite getaddrinfo getenv getdelim getgrnam gethostbyaddr gethostbyname gethostbyname_r getmntent getopt getpwnam getservbyname getservbyport getusershell glob grent hasmntopt hello iconv if_nameindex ltostr malloc-debugger math md5_testharness memccpy memchr memcmp memrchr memusage mktime mmap_test pipe printf printftest protoent prototypes putenv pwent rand48 readdir regex select sendfile servent setjmp siglist sigsetjmp speed spent sprintf sscanf stdarg strcasecmp strcmp strncat strncpy strptime strrchr strstr strtol sysconf sysenter ungetc utime waitpid"
 
 STDIN="read1"
 PASS="getpass" 
diff -urN -x .git dietlibc-0.33/test/runtests-X.sh dietlibc/test/runtests-X.sh
--- dietlibc-0.33/test/runtests-X.sh	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/test/runtests-X.sh	2015-01-01 12:14:43.534938894 +0000
@@ -0,0 +1,162 @@
+#! /bin/bash
+
+SKIP=(
+  ":asprintf"			# requires special cmdline
+  ":getpass"			# expects input from TTY
+  ":read1"			# expects input
+  ":stdio:tst-ferror"		# expects input
+  ":stdio:tstscanf"		# expects input
+  ":stdlib:testdiv"		# expects input
+)
+
+FAILURES_BOGUS=(
+  ":gethostbyname"		# network test; net might not be available in test environment
+  ":gethostbyname_r"		# network test; net might not be available in test environment
+
+  ":stdlib:tst-environ"		# test uses environ function in unsupported ways (dup keys)
+  ":stdlib:tst-rand48"		# platform dependent; does not give reliable results
+  ":stdlib:tst-strtod"		# infinite recursion in __dtostr()
+  ":time:tst-mktime"		# dietlibc does not support $TZ env
+  ":time:tst-posixtz"		# dietlibc does not support $TZ env
+  ":time:tst-strftime"		# dietlibc does not support glibc specific format specifications
+)
+
+FAILURES_BOGUS_emulator=(
+  ":adjtime"			# ajdtimex() not implement in qemu
+  ":if_nameindex"		# ioctls not implement in qemu
+  ":mmap_test"			# qemu does not pass back mmap(2) error codes
+  ":fadvise"			# bad translation of 64bit args in qemu
+  ":stdio:tst-fseek"		# !! unclear; must be investigated
+  ":dirent:tst-seekdir"		# 32/64 bit issue when calling lseek()
+)
+
+FAILURES_KNOWN=(
+  ":sendfile"			# stdin/stdout not supported; test must be wrapped
+  ":sigsetjmp"			# fp test fails when registers are on stack
+  ":stdio:tstdiomisc"		# scanf(3) fails on some constructs
+  ":stdio:tst-fphex"		# printf(3) does not support %a specifiers
+  ":stdio:tst-printf"		# printf(3) does not support some floating point ops
+  ":stdio:tst-sscanf"		# scanf(3) fails on double input
+  ":stdlib:test-canon"		# realpath(3) is broken...
+)
+
+TESTENV=.testenv.sh
+
+function is_in() {
+    local	val=$1
+    local	i
+    shift
+
+    for i; do
+	test x"$i" != x"$val" || return 0
+    done
+    return 1
+}
+
+function getenv() {
+    local _e=testenv.sh
+
+    if ${1:-false} || \
+	test ! -e $TESTENV -o \
+		Makefile -nt $TESTENV -o \
+		runtests.sh -nt $TESTENV; then
+	eval $(grep '^\(SUBDIRS\)=' runtests.sh)
+	eval $(make --no-print-directory \
+	    --eval 'print-tests:;@echo TESTPROGRAMS=\"$(sort $(TESTPROGRAMS))\"' \
+	    print-tests)
+
+	rm -f $TESTENV
+
+	{
+	  printf "SUBDIRS='%s'\n" "$SUBDIRS"
+	  printf "TESTPROGRAMS='%s'\n" "$TESTPROGRAMS"
+	} > $TESTENV
+    fi
+
+    source $TESTENV
+}
+
+: ${TESTDIR:=.}
+
+case $1 in
+  --generate-env)
+	getenv true
+	TESTPROGRAMS=		# skip tests; progress subdirs only
+	;;
+  --install)
+	getenv
+	install -d -m 0755 $2/$TESTDIR
+	install -p -m 0755 $TESTPROGRAMS $TESTENV $2/$TESTDIR/
+	TESTPROGRAMS=
+	;;
+  *)
+	getenv
+	;;
+esac
+
+rc=0
+
+: ${ME:=${BASH_SOURCE[0]}}
+: ${EMULATOR:=}
+: ${RUNTEST_INDENT=0}
+
+export ME
+export RUNTEST_INDENT
+export RUNTEST_NS
+export TESTDIR
+
+case $ME in
+  /*) ;;
+  *) ME=`pwd`/$ME;;
+esac
+
+test -z "$EMULATOR" || \
+    FAILURES_BOGUS=( "${FAILURES_BOGUS[@]}" "${FAILURES_BOGUS_emulator[@]}" )
+
+for p in $TESTPROGRAMS; do
+    ! tty -s || printf '%*s%-20s' $RUNTEST_INDENT '' "$p"
+
+    is_in "$RUNTEST_NS:$p" "${FAILURES_BOGUS[@]}" && fail_bogus=true || fail_bogus=false
+    is_in "$RUNTEST_NS:$p" "${FAILURES_KNOWN[@]}" && fail_known=true || fail_known=false
+
+    if is_in "$RUNTEST_NS:$p" "${SKIP[@]}"; then
+	res='SKIPPED'
+    else
+	$EMULATOR ./$p >/dev/null && failed=false || failed=true
+
+	case $failed:$fail_known:$fail_bogus in
+	  (false:false:*)	res='OK';;
+	  (false:true:true)	res='OK (bogus)';;
+	  (false:true:false)	res="OK (unexpected)"; let ++rc;;
+	  (true:*:true)		res='FAIL (bogus)';;
+	  (true:true:*)		res="FAIL (known)";;
+	  (true:false:*)	res='FAIL'; let ++rc;;
+	esac
+    fi
+
+    ! tty -s || printf '\r'
+
+    printf '%*s%-20s%s\n' $RUNTEST_INDENT '' "$p" "$res"
+done
+
+test $rc -eq 0 || \
+    printf "%*s--> %u tests failed\n" $RUNTEST_INDENT '' $rc
+
+orig_testdir=$TESTDIR
+
+for d in $SUBDIRS; do
+    echo "--- entering directory $d ---"
+    let RUNTEST_INDENT+=2
+    old_ns=$RUNTEST_NS
+    RUNTEST_NS=$RUNTEST_NS:$d
+
+    TESTDIR=$orig_testdir/$d
+    cd $d && bash $ME "$@" || let ++rc
+
+    RUNTEST_NS=$old_ns
+    let RUNTEST_INDENT-=2
+
+    cd $OLDPWD || exit 1
+done
+
+test $rc -eq 0 && exit 0 || exit 1
diff -urN -x .git dietlibc-0.33/test/sendfile.c dietlibc/test/sendfile.c
--- dietlibc-0.33/test/sendfile.c	2003-12-15 13:07:42.000000000 +0000
+++ dietlibc/test/sendfile.c	2015-01-01 12:14:43.534938894 +0000
@@ -11,5 +11,5 @@
 
   printf("sendfile returned %d\n",ret);
 
-return 0;    
+  return ret<0 ? 1 : 0;
 }
diff -urN -x .git dietlibc-0.33/test/setjmp.c dietlibc/test/setjmp.c
--- dietlibc-0.33/test/setjmp.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/test/setjmp.c	2015-01-01 12:14:43.534938894 +0000
@@ -0,0 +1,106 @@
+#include <assert.h>
+#include <stdlib.h>
+#include <string.h>
+#include <setjmp.h>
+
+static int Xmemcmp(void const volatile *a, void const volatile *b, size_t l)
+{
+  return memcmp((void const *)a, (void const *)b, l);
+}
+
+int main(void)
+{
+  char volatile a[8] = "testbufA";
+  jmp_buf env;
+  char volatile b[8] = "testbufB";
+
+  assert(Xmemcmp(a, "testbufA", 8) == 0);
+  assert(Xmemcmp(b, "testbufB", 8) == 0);
+
+
+  /* Test 1: not calling longjmp */
+  if (setjmp(env) == 0) {
+    char volatile somebuf[128];
+
+    memset((void *)somebuf, 0xde, sizeof somebuf);
+
+    assert(Xmemcmp(a, "testbufA", 8) == 0);
+    assert(Xmemcmp(b, "testbufB", 8) == 0);
+  } else
+    assert(0);
+
+  assert(Xmemcmp(a, "testbufA", 8) == 0);
+  assert(Xmemcmp(b, "testbufB", 8) == 0);
+
+
+  /* Test 2: calling longjmp */
+  switch (setjmp(env)) {
+  case 0: {
+    char volatile somebuf[128];
+
+    memset((void *)somebuf, 0xde, sizeof somebuf);
+
+    assert(Xmemcmp(a, "testbufA", 8) == 0);
+    assert(Xmemcmp(b, "testbufB", 8) == 0);
+
+    longjmp(env, 23);
+
+    a[0] = 'X';
+    b[0] = 'X';
+  }
+
+  case 23:
+    break;
+
+  default:
+    assert(0);
+  }
+
+  assert(Xmemcmp(a, "testbufA", 8) == 0);
+  assert(Xmemcmp(b, "testbufB", 8) == 0);
+
+
+  /* Test 3: calling longjmp again with dirty env */
+  switch (setjmp(env)) {
+  case 0: {
+    char volatile somebuf[128];
+
+    memset((void *)somebuf, 0xde, sizeof somebuf);
+
+    assert(Xmemcmp(a, "testbufA", 8) == 0);
+    assert(Xmemcmp(b, "testbufB", 8) == 0);
+
+    longjmp(env, 23);
+
+    a[0] = 'X';
+    b[0] = 'X';
+  }
+
+  case 23:
+    break;
+
+  default:
+    assert(0);
+  }
+
+  assert(Xmemcmp(a, "testbufA", 8) == 0);
+  assert(Xmemcmp(b, "testbufB", 8) == 0);
+
+
+ /* Test 4: not calling longjmp, but dirty env */
+  if (setjmp(env) == 0) {
+    char volatile somebuf[128];
+
+    memset((void *)somebuf, 0xde, sizeof somebuf);
+
+    assert(Xmemcmp(a, "testbufA", 8) == 0);
+    assert(Xmemcmp(b, "testbufB", 8) == 0);
+  } else
+    assert(0);
+
+  assert(Xmemcmp(a, "testbufA", 8) == 0);
+  assert(Xmemcmp(b, "testbufB", 8) == 0);
+
+
+  return EXIT_SUCCESS;
+}
diff -urN -x .git dietlibc-0.33/test/sigsetjmp.c dietlibc/test/sigsetjmp.c
--- dietlibc-0.33/test/sigsetjmp.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/test/sigsetjmp.c	2015-01-01 12:14:43.534938894 +0000
@@ -0,0 +1,206 @@
+#include <assert.h>
+#include <stdlib.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <string.h>
+#include <signal.h>
+#include <setjmp.h>
+
+#define TEST_PATTERN	\
+	"0123456789abcdefghijklmnopqrstuv"	\
+	"ZYXWVUTSRQPONMLKJIHGFEDCBA987654"	\
+	"456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"	\
+	"vutsrqponmlkjihgfedcba9876543210"	\
+	"0123456789ABCDEFGHIJKLMNOPQRSTUV"	\
+	"zyxwvutsrqponmlkjihgfedcba987654"	\
+	"456789abcdefghijklmnopqrstuvwxyz"	\
+	"VUTSRQPONMLKJIHGFEDCBA987654321"	\
+
+static struct {
+	char volatile a[256];
+	sigjmp_buf env;
+	char volatile b[256];
+} sigenv = {
+	.a = TEST_PATTERN "<",
+	.b = TEST_PATTERN ">",
+};
+
+static double const volatile	FP_REF[] = {
+  0.4, 0.8, 1.5, 1.6, 2.3, 4.2
+};
+
+static int volatile sig_seen;
+
+#define VALIDATE_BUFFERS(_sig_exp) do {		\
+    assert(Xmemcmp(sigenv.a, TEST_PATTERN "<", sizeof sigenv.a) == 0);	\
+    assert(Xmemcmp(sigenv.b, TEST_PATTERN ">", sizeof sigenv.b) == 0);	\
+    assert(sig_seen == (_sig_exp));		\
+  } while (0)
+
+static int Xmemcmp(void const volatile *a, void const volatile *b, size_t l)
+{
+  return memcmp((void const *)a, (void const *)b, l);
+}
+
+static void do_test(int sig_num, int do_save, int block_sig)
+{
+  int		rc;
+  sigset_t	block_set;
+  sigset_t	cur_set;
+
+  printf("%s(%d,%d,%d)... ", __func__, sig_num, do_save, block_sig);
+  fflush(stdout);
+
+  VALIDATE_BUFFERS(0);
+
+  sigemptyset(&block_set);
+  assert(sigprocmask(SIG_SETMASK, NULL, &cur_set) == 0);
+
+  /* verify that tested signal is not blocked */
+  if (sig_num != 0)
+    assert(!sigismember(&cur_set, sig_num));
+
+  /* verify that blocked signal is not already blocked and fill signal set */
+  if (block_sig != 0) {
+    assert(!sigismember(&cur_set, block_sig));
+    sigaddset(&block_set, block_sig);
+  }
+
+  sig_seen = 0;
+  rc = sigsetjmp(sigenv.env, do_save);
+  if (rc == 0) {
+    char volatile somebuf[128];
+
+    memset((void *)somebuf, 0x42, sizeof somebuf);
+    VALIDATE_BUFFERS(0);
+
+    /* modify signal mask */
+    if (block_sig != 0)
+      assert(sigprocmask(SIG_BLOCK, &block_set, NULL) == 0);
+
+    /* raise a signal which triggers a siglongjmp */
+    if (sig_num != 0) {
+      raise(sig_num);
+      sigenv.a[0] = 'X';
+      sigenv.b[0] = 'X';
+      assert(0);
+    }
+  } else if (rc != sig_num)
+    /* sigsetjmp() returned with an unexpected value */
+    assert(0);
+
+  VALIDATE_BUFFERS(sig_num);
+  sig_seen = 0;
+
+  /* check whether current signal mask contains the blocked signal; it should
+     be there iff sigsetjmp() was triggered and sigmask was saved. */
+  if (block_sig != 0) {
+    sigset_t	cur_set;
+    assert(sigprocmask(SIG_SETMASK, NULL, &cur_set) == 0);
+
+    if (do_save && rc != 0)
+      assert(!sigismember(&cur_set, block_sig));
+    else {
+      assert( sigismember(&cur_set, block_sig));
+      sigprocmask(SIG_UNBLOCK, &block_set, NULL);
+    }
+  }
+
+  printf(" ok\n");
+};
+
+static void do_test_fp(int sig_num, int do_save)
+{
+  sigset_t	cur_set;
+  int		rc;
+  double	fp0, fp1, fp2, fp3;
+
+  printf("%s(%d,%d)... ", __func__, sig_num, do_save);
+  fflush(stdout);
+
+  VALIDATE_BUFFERS(0);
+
+  assert(sigprocmask(SIG_SETMASK, NULL, &cur_set) == 0);
+
+  /* verify that tested signal is not blocked */
+  if (sig_num != 0)
+    assert(!sigismember(&cur_set, sig_num));
+
+  fp0 = FP_REF[0];
+  fp1 = FP_REF[1];
+  fp2 = FP_REF[2];
+  fp3 = FP_REF[3];
+
+  sig_seen = 0;
+  rc = sigsetjmp(sigenv.env, do_save);
+
+  if (rc == 0) {
+    fp0 = FP_REF[4];
+    fp3 = FP_REF[5];
+
+    if (sig_num != 0) {
+      raise(sig_num);
+      assert(0);
+    }
+  } else if (rc != sig_num)
+    /* sigsetjmp() returned with an unexpected value */
+    assert(0);
+
+  assert(fp1 == FP_REF[1]);
+  assert(fp2 == FP_REF[2]);
+
+  if (sig_num == 0) {
+    /* "exception" was not triggered; we should see the new values */
+    assert(fp0 == FP_REF[4]);
+    assert(fp3 == FP_REF[5]);
+  } else {
+    /* "exception" was triggered; we should see the old values */
+    assert(fp0 == FP_REF[0]);
+    assert(fp3 == FP_REF[3]);
+  }
+
+  VALIDATE_BUFFERS(sig_num);
+  sig_seen = 0;
+
+  printf(" ok\n");
+}
+
+static void sig_handler(int num)
+{
+  assert(sig_seen == 0);
+  sig_seen = num;
+  siglongjmp(sigenv.env, num);
+}
+
+int main(void)
+{
+  struct sigaction sigact = {
+    .sa_handler	= sig_handler,
+    .sa_flags	= SA_NODEFER, /* raised signal will be in blocked mask else */
+  };
+
+  /* verify our assumptions about the memory layout */
+  assert(sizeof sigenv.a == 256);
+  assert(sizeof sigenv.b == 256);
+  assert(offsetof(__typeof__(sigenv), env) == sizeof sigenv.a);
+  assert(offsetof(__typeof__(sigenv), b)   == sizeof sigenv.a + sizeof sigenv.env);
+
+  sigaction(SIGBUS,  &sigact, NULL);
+  sigaction(SIGUSR1, &sigact, NULL);
+
+  do_test(0, 0, 0);
+  do_test(0, 0, SIGUSR1);
+  do_test(0, 1, 0);
+  do_test(0, 1, SIGUSR1);
+  do_test(SIGBUS, 0, 0);
+  do_test(SIGBUS, 0, SIGUSR1);
+  do_test(SIGBUS, 1, 0);
+  do_test(SIGBUS, 1, SIGUSR1);
+
+  do_test_fp(0, 0);
+  do_test_fp(0, 1);
+  do_test_fp(SIGBUS, 0);
+  do_test_fp(SIGBUS, 1);
+
+  return EXIT_SUCCESS;
+}
diff -urN -x .git dietlibc-0.33/test/speed.c dietlibc/test/speed.c
--- dietlibc-0.33/test/speed.c	2003-12-15 13:07:42.000000000 +0000
+++ dietlibc/test/speed.c	2015-01-01 12:14:43.534938894 +0000
@@ -7,10 +7,10 @@
   int i;
   time_t t;
   
-  printf("%d\n", time(0));
+  printf("%ld\n", (long)time(0));
   for (i=0; i<10000000; ++i)
     t=time(0);
 
- printf("%d\n", time(0));
+  printf("%ld\n", (long)time(0));
  return 0;   
 }
diff -urN -x .git dietlibc-0.33/test/stat.c dietlibc/test/stat.c
--- dietlibc-0.33/test/stat.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/test/stat.c	2015-01-01 12:14:43.534938894 +0000
@@ -0,0 +1,37 @@
+#define _FILE_OFFSET_BITS 64
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+int main() {
+  int fd=open("/tmp/foo",O_CREAT|O_WRONLY|O_EXCL,0666);
+  struct timeval tv[2];
+  struct stat s;
+  if (fd==-1) {
+    perror("open");
+    return -1;
+  }
+  lseek(fd,0x100000000,SEEK_SET);
+  write(fd,"x",1);
+  close(fd);
+  tv[0].tv_sec=123456789;
+  tv[0].tv_usec=0;
+  tv[1].tv_sec=123456789;
+  tv[1].tv_usec=0;
+  if (utimes("/tmp/foo",tv)) {
+    perror("utimes");
+    unlink("/tmp/foo");
+    return -1;
+  }
+  if (stat("/tmp/foo",&s)) {
+    perror("stat");
+    unlink("/tmp/foo");
+    return -1;
+  }
+  printf("size %lld, atime %ld, mtime %ld, inode %ld\n",(long long)s.st_size,(long)s.st_atime,(long)s.st_mtime,(long)s.st_ino);
+  unlink("/tmp/foo");
+}
diff -urN -x .git dietlibc-0.33/test/stdio/.gitignore dietlibc/test/stdio/.gitignore
--- dietlibc-0.33/test/stdio/.gitignore	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/test/stdio/.gitignore	2015-01-01 12:14:43.534938894 +0000
@@ -0,0 +1,14 @@
+/tst-fdopen
+/tst-ferror
+/tst-fileno
+/tst-fphex
+/tst-fseek
+/tst-printf
+/tst-sprintf
+/tst-sscanf
+/tst-tmpnam
+/tst-unbputc
+/tst-ungetc
+/tstdiomisc
+/tstgetln
+/tstscanf
diff -urN -x .git dietlibc-0.33/test/stdio/tstscanf.c dietlibc/test/stdio/tstscanf.c
--- dietlibc-0.33/test/stdio/tstscanf.c	2003-12-15 13:07:42.000000000 +0000
+++ dietlibc/test/stdio/tstscanf.c	2015-01-01 12:14:43.534938894 +0000
@@ -338,14 +338,14 @@
     int res;
 
     res = sscanf ("-InF", "%f", &value);
-    if (res != 1 || isinf (value) != -1)
+    if (res != 1 || !isinf (value) || !(value<0))
       {
 	fputs ("test failed!\n", stdout);
 	result = 1;
       }
 
     res = sscanf ("+InfiNiTY", "%f", &value);
-    if (res != 1 || isinf (value) != 1)
+    if (res != 1 || !isinf (value) || !(value>0))
       {
 	fputs ("test failed!\n", stdout);
 	result = 1;
diff -urN -x .git dietlibc-0.33/test/stdlib/.gitignore dietlibc/test/stdlib/.gitignore
--- dietlibc-0.33/test/stdlib/.gitignore	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/test/stdlib/.gitignore	2015-01-01 12:14:43.538272226 +0000
@@ -0,0 +1,13 @@
+/test-canon
+/testdiv
+/testrand
+/testsort
+/tst-calloc
+/tst-environ
+/tst-limits
+/tst-malloc
+/tst-rand48
+/tst-strtod
+/tst-strtol
+/tst-strtoll
+/tst-system
diff -urN -x .git dietlibc-0.33/test/stdlib/testsort.c dietlibc/test/stdlib/testsort.c
--- dietlibc-0.33/test/stdlib/testsort.c	2003-12-15 13:07:42.000000000 +0000
+++ dietlibc/test/stdlib/testsort.c	2015-01-01 12:14:43.538272226 +0000
@@ -1,3 +1,5 @@
+#define _BSD_SOURCE
+
 #include <stdlib.h>
 #include <string.h>
 #include <stdio.h>
diff -urN -x .git dietlibc-0.33/test/stdlib/tst-calloc.c dietlibc/test/stdlib/tst-calloc.c
--- dietlibc-0.33/test/stdlib/tst-calloc.c	2003-12-15 13:07:42.000000000 +0000
+++ dietlibc/test/stdlib/tst-calloc.c	2015-01-01 12:14:43.538272226 +0000
@@ -17,6 +17,8 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
+#define _BSD_SOURCE
+
 #include <errno.h>
 #include <limits.h>
 #include <malloc.h>
diff -urN -x .git dietlibc-0.33/test/stdlib/tst-malloc.c dietlibc/test/stdlib/tst-malloc.c
--- dietlibc-0.33/test/stdlib/tst-malloc.c	2003-12-15 13:07:42.000000000 +0000
+++ dietlibc/test/stdlib/tst-malloc.c	2015-01-01 12:14:43.538272226 +0000
@@ -21,13 +21,15 @@
 #include <stdlib.h>
 #include <stdio.h>
 
+#include "../../dietfeatures.h"
+
 static int errors = 0;
 
 static void
 merror (const char *msg)
 {
   ++errors;
-  printf ("Error: %s\n", msg);
+  fprintf (stderr, "Error: %s\n", msg);
 }
 
 int
@@ -56,9 +58,11 @@
   if (p != NULL)
     merror ("realloc (p, 0) failed.");
 
+#ifdef WANT_MALLOC_ZERO
   p = malloc (0);
   if (p == NULL)
     merror ("malloc (0) failed.");
+#endif
 
   p = realloc (p, 0);
   if (p != NULL)
diff -urN -x .git dietlibc-0.33/test/stdlib/tst-strtod.c dietlibc/test/stdlib/tst-strtod.c
--- dietlibc-0.33/test/stdlib/tst-strtod.c	2003-12-15 13:07:42.000000000 +0000
+++ dietlibc/test/stdlib/tst-strtod.c	2015-01-01 12:14:43.538272226 +0000
@@ -149,10 +149,10 @@
     }
 
   const char input2[] = "+1.000000000116415321826934814453125";
-  if (strtold (input2, NULL) != +1.000000000116415321826934814453125)
+  if (strtold (input2, NULL) != +1.000000000116415321826934814453125L)
     {
       printf ("input2: %La != %La\n", strtold (input2, NULL),
-	      +1.000000000116415321826934814453125);
+	      +1.000000000116415321826934814453125L);
       status = 1;
     }
 
diff -urN -x .git dietlibc-0.33/test/string/.gitignore dietlibc/test/string/.gitignore
--- dietlibc-0.33/test/string/.gitignore	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/test/string/.gitignore	2015-01-01 12:14:43.538272226 +0000
@@ -0,0 +1,16 @@
+/memccpy
+/memchr
+/memcmp
+/memcpy
+/mempcpy
+/memrchr
+/strcasecmp
+/strcmp
+/strcspn
+/strlen
+/strncat
+/strncpy
+/strpbrk
+/strrchr
+/strspn
+/strstr
diff -urN -x .git dietlibc-0.33/test/sysconf.c dietlibc/test/sysconf.c
--- dietlibc-0.33/test/sysconf.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/test/sysconf.c	2015-01-01 12:14:43.538272226 +0000
@@ -0,0 +1,80 @@
+#include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <assert.h>
+#include <sys/wait.h>
+
+#include "../dietpagesize.h"
+
+static long exec_getconf(char const *var)
+{
+  char	buf[128];
+  pid_t	pid;
+  int	fd[2];
+  int	status;
+  ssize_t	l;
+
+  if (pipe(fd)<0 || (pid = fork())<0)
+    abort();
+
+  if (pid==0) {
+    close(fd[0]);
+
+    if (fd[1]!=1) {
+      dup2(fd[1], 1);
+      close(fd[1]);
+    }
+
+    execlp("getconf", "getconf", var, NULL);
+    _exit(1);
+  }
+
+  close(fd[1]);
+  l = read(fd[0], buf, sizeof(buf)-1);
+  if (l<0) {
+    perror("read()");
+    goto err;
+  } else if (l==sizeof(buf)-1)
+    goto err;
+  close(fd[0]);
+
+  buf[l] = '\0';
+
+  if (waitpid(pid, &status, 0)<0)
+    goto err;
+
+  if (!WIFEXITED(status) || WEXITSTATUS(status)!=0)
+    goto err;
+
+  return strtol(buf, NULL, 10);
+
+ err:
+  kill(pid, SIGKILL);
+  abort();
+}
+
+static unsigned int do_check(char const *var, long exp)
+{
+  long	cur = exec_getconf(var);
+
+  if (cur!=exp) {
+    fprintf(stderr, "%s mismatch: got %ld, expected %ld\n",
+	    var, cur, exp);
+    return 1;
+  }
+
+  return 0;
+}
+
+int main(int argc, char *argv[])
+{
+  unsigned int	err = 0;
+
+  assert(sysconf(_SC_PAGESIZE) == __DIET_PAGE_SIZE);
+  assert(__DIET_PAGE_SIZE == (1<<__DIET_PAGE_SHIFT));
+
+  err += do_check("PAGE_SIZE", sysconf(_SC_PAGESIZE));
+  err += do_check("CLK_TCK",   sysconf(_SC_CLK_TCK));
+
+  return err;
+}
diff -urN -x .git dietlibc-0.33/test/sysenter.c dietlibc/test/sysenter.c
--- dietlibc-0.33/test/sysenter.c	2003-12-15 13:07:42.000000000 +0000
+++ dietlibc/test/sysenter.c	2015-01-01 12:14:43.538272226 +0000
@@ -11,11 +11,11 @@
   int i;
   for (i=0; environ[i]; ++i) ;
   for (x=(struct elf_aux*)(environ+i+1); x->type; ++x) {
-    printf("%d %x\n",x->type,x->value);
+    printf("%ld %lx\n",x->type,x->value);
     if (x->type==AT_PAGESZ)
-      printf("pagesize %d\n",x->value);
+      printf("pagesize %ld\n",x->value);
     else if (x->type==AT_SYSINFO)
-      printf("vsyscall %p\n",x->value);
+      printf("vsyscall %p\n",(void *)x->value);
   }
   return 0;
 }
diff -urN -x .git dietlibc-0.33/test/thread.c dietlibc/test/thread.c
--- dietlibc-0.33/test/thread.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/test/thread.c	2015-01-01 12:14:43.538272226 +0000
@@ -0,0 +1,162 @@
+#define _REENTRANT
+#include <threads.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <assert.h>
+#include <write12.h>
+#include <time.h>
+#include <errno.h>
+
+mtx_t m;
+
+long l;
+
+int thread(void* arg) {
+  size_t i;
+  char buf[100];
+  (void)arg;
+  for (i=0; i<100; ++i) {
+    mtx_lock(&m);
+    ++l;
+    mtx_unlock(&m);
+  }
+  return 23;
+}
+
+int thread2(void* arg) {
+  mtx_lock(&m);
+  sleep(1);
+  mtx_unlock(&m);
+  return 23;
+}
+
+int recursive_lock(int a) {
+  mtx_lock(&m);
+  if (a>0)
+    return recursive_lock(a-1);
+  else
+    sleep(1);
+  mtx_unlock(&m);
+}
+
+int thread3(void* arg) {
+  recursive_lock(5);
+}
+
+once_flag f=ONCE_FLAG_INIT;
+
+void callme(void) {
+  __write1("callme got called\n");
+}
+
+int thread4(void* arg) {
+  call_once(&f,callme);
+  return 0;
+}
+
+cnd_t cond;
+int done;
+
+int thread5(void* arg) {
+  cnd_wait(&cond,&m);
+//  __write1("thread5\n");
+  ++done;
+  mtx_unlock(&m);
+}
+
+int thread6(void* arg) {
+  errno=0;
+  assert(write(-1,"foo",3)==-1);
+  assert(errno==EBADF);
+  return 0;
+}
+
+int main() {
+  thrd_t threads[16];
+  size_t i;
+  mtx_init(&m,mtx_plain);
+
+  __write1("plain mutex test\n");
+  for (i=0; i<sizeof(threads)/sizeof(threads[0]); ++i) {
+    assert(thrd_create(threads+i,thread,NULL)==thrd_success);
+  }
+  for (i=0; i<sizeof(threads)/sizeof(threads[0]); ++i) {
+    int r;
+    assert(thrd_join(threads[i],&r)==thrd_success && r==23);
+  }
+  assert(l==100*sizeof(threads)/sizeof(threads[0]));
+
+  __write1("mtx_timedlock test\n");
+  assert(thrd_create(threads,thread2,NULL)==thrd_success);
+  {
+    struct timespec ts;
+    ts.tv_sec=0;
+    ts.tv_nsec=10000;
+    nanosleep(&ts,0);
+    assert(mtx_timedlock(&m,&ts)==thrd_timedout);
+  }
+  {
+    int r;
+    assert(thrd_join(threads[0],&r)==thrd_success);
+  }
+  mtx_destroy(&m);
+
+  __write1("mtx_recursive test\n");
+  mtx_init(&m,mtx_recursive);
+  assert(thrd_create(threads,thread3,NULL)==thrd_success);
+  {
+    struct timespec ts;
+    ts.tv_sec=0;
+    ts.tv_nsec=10000;
+    nanosleep(&ts,0);
+    // at this point thread3 should be running, and it should have
+    // locked the recursive lock, and be inside the sleep(1);
+    assert(mtx_trylock(&m)==thrd_busy);
+  }
+  {
+    int r;
+    assert(thrd_join(threads[0],&r)==thrd_success);
+  }
+
+  __write1("call_once test\n");
+  for (i=0; i<sizeof(threads)/sizeof(threads[0]); ++i) {
+    assert(thrd_create(threads+i,thread4,NULL)==thrd_success);
+  }
+  for (i=0; i<sizeof(threads)/sizeof(threads[0]); ++i) {
+    int r;
+    assert(thrd_join(threads[i],&r)==thrd_success && r==0);
+  }
+
+  __write1("cnd_t test\n");
+  cnd_init(&cond);
+  mtx_init(&m,mtx_plain);
+  for (i=0; i<sizeof(threads)/sizeof(threads[0]); ++i) {
+    assert(thrd_create(threads+i,thread5,NULL)==thrd_success);
+    assert(thrd_detach(threads[i])==thrd_success);
+  }
+  {
+    struct timespec ts;
+    ts.tv_sec=0;
+    ts.tv_nsec=100000000;
+    nanosleep(&ts,0);
+    cnd_signal(&cond);
+    nanosleep(&ts,0);
+    mtx_lock(&m);
+    assert(done==1);
+    mtx_unlock(&m);
+    cnd_broadcast(&cond);
+    nanosleep(&ts,0);
+    mtx_lock(&m);
+    assert(done==sizeof(threads)/sizeof(threads[0]));
+    mtx_unlock(&m);
+  }
+
+  errno=0;
+  assert(write(-1,"foo",3)==-1);
+  assert(errno==EBADF);
+
+  assert(thrd_create(threads,thread6,NULL)==thrd_success);
+  assert(thrd_join(threads[0],NULL)==thrd_success);
+
+  return 0;
+}
diff -urN -x .git dietlibc-0.33/test/time/.gitignore dietlibc/test/time/.gitignore
--- dietlibc-0.33/test/time/.gitignore	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/test/time/.gitignore	2015-01-01 12:14:43.538272226 +0000
@@ -0,0 +1,4 @@
+/tst-mktime
+/tst-posixtz
+/tst-strftime
+/tst-strptime
diff -urN -x .git dietlibc-0.33/test/time/tst-strftime.c dietlibc/test/time/tst-strftime.c
--- dietlibc-0.33/test/time/tst-strftime.c	2003-12-15 13:07:42.000000000 +0000
+++ dietlibc/test/time/tst-strftime.c	2015-01-01 12:14:43.538272226 +0000
@@ -49,18 +49,18 @@
 
       if (res == 0)
 	{
-	  printf ("%Zu: %s: res == 0 despite size == %Zu\n",
+	  printf ("%zu: %s: res == 0 despite size == %zu\n",
 		  cnt, tests[cnt].fmt, size);
 	  result = 1;
 	}
       else if (size < tests[cnt].min)
 	{
-	  printf ("%Zu: %s: size == %Zu was enough\n",
+	  printf ("%zu: %s: size == %zu was enough\n",
 		  cnt, tests[cnt].fmt, size);
 	  result = 1;
 	}
       else
-	printf ("%Zu: %s: size == %Zu: OK\n", cnt, tests[cnt].fmt, size);
+	printf ("%zu: %s: size == %zu: OK\n", cnt, tests[cnt].fmt, size);
 
       free (buf);
     }
diff -urN -x .git dietlibc-0.33/test/time/tst-strptime.c dietlibc/test/time/tst-strptime.c
--- dietlibc-0.33/test/time/tst-strptime.c	2003-12-15 13:07:42.000000000 +0000
+++ dietlibc/test/time/tst-strptime.c	2015-01-01 12:14:43.538272226 +0000
@@ -41,10 +41,12 @@
   { "C", "03/03/00", "%D", 5, 62, 2, 3 },
   { "C", "9/9/99", "%x", 4, 251, 8, 9 },
   { "C", "19990502123412", "%Y%m%d%H%M%S", 0, 121, 4, 2 },
+#if 0		/* dietlibc does not support %U/%W/%j and non-POSIX locales */
   { "C", "2001 20 Mon", "%Y %U %a", 1, 140, 4, 21 },
   { "C", "2001 21 Mon", "%Y %W %a", 1, 140, 4, 21 },
   { "ja_JP.EUC-JP", "2001 20 \xb7\xee", "%Y %U %a", 1, 140, 4, 21 },
   { "ja_JP.EUC-JP", "2001 21 \xb7\xee", "%Y %W %a", 1, 140, 4, 21 },
+#endif
 };
 
 
@@ -72,9 +74,16 @@
 
   for (i = 0; i < sizeof (tm_tests) / sizeof (tm_tests[0]); ++i)
     {
+      char *pres;
       memset (&tm, '\0', sizeof (tm));
-      
-      if (strptime (tm_tests[i].input, tm_tests[i].format, &tm) != '\0')
+
+      pres = strptime (tm_tests[i].input, tm_tests[i].format, &tm);
+      if (!pres)
+	{
+	  fprintf(stderr, "failed to parse '%s'\n", day_tests[i].input);
+	  result = 1;
+	}
+      else if (*pres != '\0')
 	{
 	  printf ("not all of `%s' read\n", tm_tests[i].input);
 	  result = 1;
@@ -118,6 +127,7 @@
 
   for (i = 0; i < sizeof (day_tests) / sizeof (day_tests[0]); ++i)
     {
+      char *pres;
       memset (&tm, '\0', sizeof (tm));
 
       if (setlocale (LC_ALL, day_tests[i].locale) == NULL)
@@ -125,7 +135,14 @@
 	  printf ("cannot set locale %s: %m\n", day_tests[i].locale);
 	}
 
-      if (*strptime (day_tests[i].input, day_tests[i].format, &tm) != '\0')
+      pres = strptime (day_tests[i].input, day_tests[i].format, &tm);
+      if (!pres)
+	{
+	  fprintf(stderr, "failed to parse '%s' for locale '%s'\n",
+		  day_tests[i].input, day_tests[i].locale);
+	  result = 1;
+	}
+      else if (*pres != '\0')
 	{
 	  printf ("not all of `%s' read\n", day_tests[i].input);
 	  result = 1;
diff -urN -x .git dietlibc-0.33/test/unaligned.c dietlibc/test/unaligned.c
--- dietlibc-0.33/test/unaligned.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/test/unaligned.c	2015-01-01 12:14:43.538272226 +0000
@@ -0,0 +1,53 @@
+#include "../dietunaligned.h"
+#include <assert.h>
+#include <string.h>
+#include <stdlib.h>
+
+struct unaligned0 {
+	uint8_t		u8;
+	uint16_t	u16;
+	uint32_t	u32;
+	uint64_t	u64;
+};
+
+int main()
+{
+	struct unaligned0	data0 = {
+		.u8 = 8,
+		.u16 = 16,
+		.u32 = 32,
+		.u64 = 64
+	};
+	struct unaligned0	data1;
+
+	unsigned char		*buf0 = malloc(sizeof data0 + 1);
+	unsigned char		*buf1 = malloc(sizeof data0 + 1);
+
+	assert(buf0 != NULL);
+	assert(buf1 != NULL);
+
+	memcpy(buf0+1, &data0, sizeof data0);
+
+	assert(read_unaligned_s(buf0+1, struct unaligned0, u8)  == data0.u8);
+	assert(read_unaligned_s(buf0+1, struct unaligned0, u16) == data0.u16);
+	assert(read_unaligned_s(buf0+1, struct unaligned0, u32) == data0.u32);
+	assert(read_unaligned_s(buf0+1, struct unaligned0, u64) == data0.u64);
+
+
+	memset(buf1, 0, sizeof data0 + 1);
+	write_unaligned_s(data0.u8,  buf1+1, struct unaligned0, u8);
+	write_unaligned_s(data0.u16, buf1+1, struct unaligned0, u16);
+	write_unaligned_s(data0.u32, buf1+1, struct unaligned0, u32);
+	write_unaligned_s(data0.u64, buf1+1, struct unaligned0, u64);
+
+	memcpy(&data1, buf1+1, sizeof data1);
+	assert(data0.u8  == data1.u8);
+	assert(data0.u16 == data1.u16);
+	assert(data0.u32 == data1.u32);
+	assert(data0.u64 == data1.u64);
+
+	free(buf1);
+	free(buf0);
+
+	return 0;
+}
diff -urN -x .git dietlibc-0.33/test/waitpid.c dietlibc/test/waitpid.c
--- dietlibc-0.33/test/waitpid.c	2003-12-15 13:07:42.000000000 +0000
+++ dietlibc/test/waitpid.c	2015-01-01 12:14:43.538272226 +0000
@@ -11,7 +11,7 @@
     perror("fork");
     _exit(1);
   case 0:
-    fprintf(stderr,"child, my pid is %u\n",getpid());
+    fprintf(stdout,"child, my pid is %u\n",getpid());
     sleep(1);
     _exit(23);
   }
diff -urN -x .git dietlibc-0.33/x32/Makefile.add dietlibc/x32/Makefile.add
--- dietlibc-0.33/x32/Makefile.add	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/x32/Makefile.add	2015-01-01 12:14:43.538272226 +0000
@@ -0,0 +1,3 @@
+CFLAGS := -Os -fstrict-aliasing -momit-leaf-frame-pointer -mfancy-math-387
+VPATH  := x32:x86_64:syscalls.s:$(VPATH)
+LIBOBJ += $(OBJDIR)/arch_prctl.o $(OBJDIR)/__CAS.o
diff -urN -x .git dietlibc-0.33/x32/start.S dietlibc/x32/start.S
--- dietlibc-0.33/x32/start.S	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/x32/start.S	2015-01-01 12:14:43.538272226 +0000
@@ -0,0 +1,71 @@
+#include "dietfeatures.h"
+
+.text
+.global _start
+_start:
+#ifdef WANT_DYNAMIC
+	movq	%rdx, %rcx		/* %rcx = dynamic fini */
+#endif
+	movl	(%esp), %edi		/* %edi = argc */
+	lea	4(%esp), %esi		/* %esi = argv */
+	
+	leaq	4(%rsi,%rdi,4),%rdx	/* %edx = envp = (4*edi)+%esi+4 */
+
+#ifdef WANT_ELFINFO
+	/* untested !! */
+
+#ifdef __DYN_LIB
+	movl	environ@GOTPCREL(%rip), %eax
+#else
+	leal	environ(%rip), %eax
+#endif
+	movl	%edx, (%eax)	/* environ */
+
+1:	add	$4, %edx	/* incorment envp */
+	cmpl	$0, -4(%edx)	/* load envp[-1] */
+	jne	1b		/* ... until envp[-1]==NULL */
+
+	movl	%edx, 4(%eax)	/* __elfinfo */
+#else	/* WANT_ELFINFO */
+#ifdef __DYN_LIB
+	movl	environ@GOTPCREL(%rip), %eax
+	movl	%edx, (%eax)
+#else
+	movl	%edx, environ(%rip)
+#endif
+#endif	/* WANT_ELFINFO */
+
+#ifdef PROFILING
+	pushl	%edi			/* save reg args */
+	pushl	%esi
+	pushl	%edx
+	pushl	%ecx
+
+	leal	_etext(%eip), %esi	/* highpc */
+	leal	 .text(%eip), %edi	/* lowpc */
+	call	monitor
+
+	popl	%ecx			/* restore reg args */
+	popl	%edx
+	popl	%esi
+	popl	%edi
+#endif
+
+#ifdef WANT_DYNAMIC
+	call	_dyn_start
+#else
+	call	CALL_IN_STARTCODE
+#endif
+
+#ifdef PROFILING
+	pushl	%eax
+	call	_stop_monitor
+	popl	%edi
+#else
+	movl	%eax, %edi	/* return value */
+#endif
+	call	exit
+	hlt
+.Lstart:
+	.size	 _start,.Lstart-_start
+
diff -urN -x .git dietlibc-0.33/x32/syscalls.h dietlibc/x32/syscalls.h
--- dietlibc-0.33/x32/syscalls.h	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/x32/syscalls.h	2015-01-01 12:14:43.538272226 +0000
@@ -0,0 +1,375 @@
+/* the x32 syscall bit is 0x40000000 but we handle that inside our
+ * unified syscall, not here, so we can have a tiny optimization for
+ * small syscall numbers. We still leave the #define in so we can cut
+ * and paste from
+ * /usr/src/linux/arch/x86/include/generated/uapi/asm/unistd_x32.h */
+#define __X32_SYSCALL_BIT 0
+
+#define __NR_read (__X32_SYSCALL_BIT + 0)
+#define __NR_write (__X32_SYSCALL_BIT + 1)
+#define __NR_open (__X32_SYSCALL_BIT + 2)
+#define __NR_close (__X32_SYSCALL_BIT + 3)
+#define __NR_stat (__X32_SYSCALL_BIT + 4)
+#define __NR_fstat (__X32_SYSCALL_BIT + 5)
+#define __NR_lstat (__X32_SYSCALL_BIT + 6)
+#define __NR_poll (__X32_SYSCALL_BIT + 7)
+#define __NR_lseek (__X32_SYSCALL_BIT + 8)
+#define __NR_mmap (__X32_SYSCALL_BIT + 9)
+#define __NR_mprotect (__X32_SYSCALL_BIT + 10)
+#define __NR_munmap (__X32_SYSCALL_BIT + 11)
+#define __NR_brk (__X32_SYSCALL_BIT + 12)
+#define __NR_rt_sigprocmask (__X32_SYSCALL_BIT + 14)
+#define __NR_pread64 (__X32_SYSCALL_BIT + 17)
+#define __NR_pwrite64 (__X32_SYSCALL_BIT + 18)
+#define __NR_access (__X32_SYSCALL_BIT + 21)
+#define __NR_pipe (__X32_SYSCALL_BIT + 22)
+#define __NR_select (__X32_SYSCALL_BIT + 23)
+#define __NR_sched_yield (__X32_SYSCALL_BIT + 24)
+#define __NR_mremap (__X32_SYSCALL_BIT + 25)
+#define __NR_msync (__X32_SYSCALL_BIT + 26)
+#define __NR_mincore (__X32_SYSCALL_BIT + 27)
+#define __NR_madvise (__X32_SYSCALL_BIT + 28)
+#define __NR_shmget (__X32_SYSCALL_BIT + 29)
+#define __NR_shmat (__X32_SYSCALL_BIT + 30)
+#define __NR_shmctl (__X32_SYSCALL_BIT + 31)
+#define __NR_dup (__X32_SYSCALL_BIT + 32)
+#define __NR_dup2 (__X32_SYSCALL_BIT + 33)
+#define __NR_pause (__X32_SYSCALL_BIT + 34)
+#define __NR_nanosleep (__X32_SYSCALL_BIT + 35)
+#define __NR_getitimer (__X32_SYSCALL_BIT + 36)
+#define __NR_alarm (__X32_SYSCALL_BIT + 37)
+#define __NR_setitimer (__X32_SYSCALL_BIT + 38)
+#define __NR_getpid (__X32_SYSCALL_BIT + 39)
+#define __NR_sendfile (__X32_SYSCALL_BIT + 40)
+#define __NR_socket (__X32_SYSCALL_BIT + 41)
+#define __NR_connect (__X32_SYSCALL_BIT + 42)
+#define __NR_accept (__X32_SYSCALL_BIT + 43)
+#define __NR_sendto (__X32_SYSCALL_BIT + 44)
+#define __NR_shutdown (__X32_SYSCALL_BIT + 48)
+#define __NR_bind (__X32_SYSCALL_BIT + 49)
+#define __NR_listen (__X32_SYSCALL_BIT + 50)
+#define __NR_getsockname (__X32_SYSCALL_BIT + 51)
+#define __NR_getpeername (__X32_SYSCALL_BIT + 52)
+#define __NR_socketpair (__X32_SYSCALL_BIT + 53)
+#define __NR_clone (__X32_SYSCALL_BIT + 56)
+#define __NR_fork (__X32_SYSCALL_BIT + 57)
+#define __NR_vfork (__X32_SYSCALL_BIT + 58)
+#define __NR_exit (__X32_SYSCALL_BIT + 60)
+#define __NR_wait4 (__X32_SYSCALL_BIT + 61)
+#define __NR_kill (__X32_SYSCALL_BIT + 62)
+#define __NR_uname (__X32_SYSCALL_BIT + 63)
+#define __NR_semget (__X32_SYSCALL_BIT + 64)
+#define __NR_semop (__X32_SYSCALL_BIT + 65)
+#define __NR_semctl (__X32_SYSCALL_BIT + 66)
+#define __NR_shmdt (__X32_SYSCALL_BIT + 67)
+#define __NR_msgget (__X32_SYSCALL_BIT + 68)
+#define __NR_msgsnd (__X32_SYSCALL_BIT + 69)
+#define __NR_msgrcv (__X32_SYSCALL_BIT + 70)
+#define __NR_msgctl (__X32_SYSCALL_BIT + 71)
+#define __NR_fcntl (__X32_SYSCALL_BIT + 72)
+#define __NR_flock (__X32_SYSCALL_BIT + 73)
+#define __NR_fsync (__X32_SYSCALL_BIT + 74)
+#define __NR_fdatasync (__X32_SYSCALL_BIT + 75)
+#define __NR_truncate (__X32_SYSCALL_BIT + 76)
+#define __NR_ftruncate (__X32_SYSCALL_BIT + 77)
+#define __NR_getdents (__X32_SYSCALL_BIT + 78)
+#define __NR_getcwd (__X32_SYSCALL_BIT + 79)
+#define __NR_chdir (__X32_SYSCALL_BIT + 80)
+#define __NR_fchdir (__X32_SYSCALL_BIT + 81)
+#define __NR_rename (__X32_SYSCALL_BIT + 82)
+#define __NR_mkdir (__X32_SYSCALL_BIT + 83)
+#define __NR_rmdir (__X32_SYSCALL_BIT + 84)
+#define __NR_creat (__X32_SYSCALL_BIT + 85)
+#define __NR_link (__X32_SYSCALL_BIT + 86)
+#define __NR_unlink (__X32_SYSCALL_BIT + 87)
+#define __NR_symlink (__X32_SYSCALL_BIT + 88)
+#define __NR_readlink (__X32_SYSCALL_BIT + 89)
+#define __NR_chmod (__X32_SYSCALL_BIT + 90)
+#define __NR_fchmod (__X32_SYSCALL_BIT + 91)
+#define __NR_chown (__X32_SYSCALL_BIT + 92)
+#define __NR_fchown (__X32_SYSCALL_BIT + 93)
+#define __NR_lchown (__X32_SYSCALL_BIT + 94)
+#define __NR_umask (__X32_SYSCALL_BIT + 95)
+#define __NR_gettimeofday (__X32_SYSCALL_BIT + 96)
+#define __NR_getrlimit (__X32_SYSCALL_BIT + 97)
+#define __NR_getrusage (__X32_SYSCALL_BIT + 98)
+#define __NR_sysinfo (__X32_SYSCALL_BIT + 99)
+#define __NR_times (__X32_SYSCALL_BIT + 100)
+#define __NR_getuid (__X32_SYSCALL_BIT + 102)
+#define __NR_syslog (__X32_SYSCALL_BIT + 103)
+#define __NR_getgid (__X32_SYSCALL_BIT + 104)
+#define __NR_setuid (__X32_SYSCALL_BIT + 105)
+#define __NR_setgid (__X32_SYSCALL_BIT + 106)
+#define __NR_geteuid (__X32_SYSCALL_BIT + 107)
+#define __NR_getegid (__X32_SYSCALL_BIT + 108)
+#define __NR_setpgid (__X32_SYSCALL_BIT + 109)
+#define __NR_getppid (__X32_SYSCALL_BIT + 110)
+#define __NR_getpgrp (__X32_SYSCALL_BIT + 111)
+#define __NR_setsid (__X32_SYSCALL_BIT + 112)
+#define __NR_setreuid (__X32_SYSCALL_BIT + 113)
+#define __NR_setregid (__X32_SYSCALL_BIT + 114)
+#define __NR_getgroups (__X32_SYSCALL_BIT + 115)
+#define __NR_setgroups (__X32_SYSCALL_BIT + 116)
+#define __NR_setresuid (__X32_SYSCALL_BIT + 117)
+#define __NR_getresuid (__X32_SYSCALL_BIT + 118)
+#define __NR_setresgid (__X32_SYSCALL_BIT + 119)
+#define __NR_getresgid (__X32_SYSCALL_BIT + 120)
+#define __NR_getpgid (__X32_SYSCALL_BIT + 121)
+#define __NR_setfsuid (__X32_SYSCALL_BIT + 122)
+#define __NR_setfsgid (__X32_SYSCALL_BIT + 123)
+#define __NR_getsid (__X32_SYSCALL_BIT + 124)
+#define __NR_capget (__X32_SYSCALL_BIT + 125)
+#define __NR_capset (__X32_SYSCALL_BIT + 126)
+#define __NR_rt_sigsuspend (__X32_SYSCALL_BIT + 130)
+#define __NR_utime (__X32_SYSCALL_BIT + 132)
+#define __NR_mknod (__X32_SYSCALL_BIT + 133)
+#define __NR_personality (__X32_SYSCALL_BIT + 135)
+#define __NR_ustat (__X32_SYSCALL_BIT + 136)
+#define __NR_statfs (__X32_SYSCALL_BIT + 137)
+#define __NR_fstatfs (__X32_SYSCALL_BIT + 138)
+#define __NR_sysfs (__X32_SYSCALL_BIT + 139)
+#define __NR_getpriority (__X32_SYSCALL_BIT + 140)
+#define __NR_setpriority (__X32_SYSCALL_BIT + 141)
+#define __NR_sched_setparam (__X32_SYSCALL_BIT + 142)
+#define __NR_sched_getparam (__X32_SYSCALL_BIT + 143)
+#define __NR_sched_setscheduler (__X32_SYSCALL_BIT + 144)
+#define __NR_sched_getscheduler (__X32_SYSCALL_BIT + 145)
+#define __NR_sched_get_priority_max (__X32_SYSCALL_BIT + 146)
+#define __NR_sched_get_priority_min (__X32_SYSCALL_BIT + 147)
+#define __NR_sched_rr_get_interval (__X32_SYSCALL_BIT + 148)
+#define __NR_mlock (__X32_SYSCALL_BIT + 149)
+#define __NR_munlock (__X32_SYSCALL_BIT + 150)
+#define __NR_mlockall (__X32_SYSCALL_BIT + 151)
+#define __NR_munlockall (__X32_SYSCALL_BIT + 152)
+#define __NR_vhangup (__X32_SYSCALL_BIT + 153)
+#define __NR_modify_ldt (__X32_SYSCALL_BIT + 154)
+#define __NR_pivot_root (__X32_SYSCALL_BIT + 155)
+#define __NR_prctl (__X32_SYSCALL_BIT + 157)
+#define __NR_arch_prctl (__X32_SYSCALL_BIT + 158)
+#define __NR_adjtimex (__X32_SYSCALL_BIT + 159)
+#define __NR_setrlimit (__X32_SYSCALL_BIT + 160)
+#define __NR_chroot (__X32_SYSCALL_BIT + 161)
+#define __NR_sync (__X32_SYSCALL_BIT + 162)
+#define __NR_acct (__X32_SYSCALL_BIT + 163)
+#define __NR_settimeofday (__X32_SYSCALL_BIT + 164)
+#define __NR_mount (__X32_SYSCALL_BIT + 165)
+#define __NR_umount2 (__X32_SYSCALL_BIT + 166)
+#define __NR_swapon (__X32_SYSCALL_BIT + 167)
+#define __NR_swapoff (__X32_SYSCALL_BIT + 168)
+#define __NR_reboot (__X32_SYSCALL_BIT + 169)
+#define __NR_sethostname (__X32_SYSCALL_BIT + 170)
+#define __NR_setdomainname (__X32_SYSCALL_BIT + 171)
+#define __NR_iopl (__X32_SYSCALL_BIT + 172)
+#define __NR_ioperm (__X32_SYSCALL_BIT + 173)
+#define __NR_init_module (__X32_SYSCALL_BIT + 175)
+#define __NR_delete_module (__X32_SYSCALL_BIT + 176)
+#define __NR_quotactl (__X32_SYSCALL_BIT + 179)
+#define __NR_getpmsg (__X32_SYSCALL_BIT + 181)
+#define __NR_putpmsg (__X32_SYSCALL_BIT + 182)
+#define __NR_afs_syscall (__X32_SYSCALL_BIT + 183)
+#define __NR_tuxcall (__X32_SYSCALL_BIT + 184)
+#define __NR_security (__X32_SYSCALL_BIT + 185)
+#define __NR_gettid (__X32_SYSCALL_BIT + 186)
+#define __NR_readahead (__X32_SYSCALL_BIT + 187)
+#define __NR_setxattr (__X32_SYSCALL_BIT + 188)
+#define __NR_lsetxattr (__X32_SYSCALL_BIT + 189)
+#define __NR_fsetxattr (__X32_SYSCALL_BIT + 190)
+#define __NR_getxattr (__X32_SYSCALL_BIT + 191)
+#define __NR_lgetxattr (__X32_SYSCALL_BIT + 192)
+#define __NR_fgetxattr (__X32_SYSCALL_BIT + 193)
+#define __NR_listxattr (__X32_SYSCALL_BIT + 194)
+#define __NR_llistxattr (__X32_SYSCALL_BIT + 195)
+#define __NR_flistxattr (__X32_SYSCALL_BIT + 196)
+#define __NR_removexattr (__X32_SYSCALL_BIT + 197)
+#define __NR_lremovexattr (__X32_SYSCALL_BIT + 198)
+#define __NR_fremovexattr (__X32_SYSCALL_BIT + 199)
+#define __NR_tkill (__X32_SYSCALL_BIT + 200)
+#define __NR_time (__X32_SYSCALL_BIT + 201)
+#define __NR_futex (__X32_SYSCALL_BIT + 202)
+#define __NR_sched_setaffinity (__X32_SYSCALL_BIT + 203)
+#define __NR_sched_getaffinity (__X32_SYSCALL_BIT + 204)
+#define __NR_io_destroy (__X32_SYSCALL_BIT + 207)
+#define __NR_io_getevents (__X32_SYSCALL_BIT + 208)
+#define __NR_io_cancel (__X32_SYSCALL_BIT + 210)
+#define __NR_lookup_dcookie (__X32_SYSCALL_BIT + 212)
+#define __NR_epoll_create (__X32_SYSCALL_BIT + 213)
+#define __NR_remap_file_pages (__X32_SYSCALL_BIT + 216)
+#define __NR_getdents64 (__X32_SYSCALL_BIT + 217)
+#define __NR_set_tid_address (__X32_SYSCALL_BIT + 218)
+#define __NR_restart_syscall (__X32_SYSCALL_BIT + 219)
+#define __NR_semtimedop (__X32_SYSCALL_BIT + 220)
+#define __NR_fadvise64 (__X32_SYSCALL_BIT + 221)
+#define __NR_timer_settime (__X32_SYSCALL_BIT + 223)
+#define __NR_timer_gettime (__X32_SYSCALL_BIT + 224)
+#define __NR_timer_getoverrun (__X32_SYSCALL_BIT + 225)
+#define __NR_timer_delete (__X32_SYSCALL_BIT + 226)
+#define __NR_clock_settime (__X32_SYSCALL_BIT + 227)
+#define __NR_clock_gettime (__X32_SYSCALL_BIT + 228)
+#define __NR_clock_getres (__X32_SYSCALL_BIT + 229)
+#define __NR_clock_nanosleep (__X32_SYSCALL_BIT + 230)
+#define __NR_exit_group (__X32_SYSCALL_BIT + 231)
+#define __NR_epoll_wait (__X32_SYSCALL_BIT + 232)
+#define __NR_epoll_ctl (__X32_SYSCALL_BIT + 233)
+#define __NR_tgkill (__X32_SYSCALL_BIT + 234)
+#define __NR_utimes (__X32_SYSCALL_BIT + 235)
+#define __NR_mbind (__X32_SYSCALL_BIT + 237)
+#define __NR_set_mempolicy (__X32_SYSCALL_BIT + 238)
+#define __NR_get_mempolicy (__X32_SYSCALL_BIT + 239)
+#define __NR_mq_open (__X32_SYSCALL_BIT + 240)
+#define __NR_mq_unlink (__X32_SYSCALL_BIT + 241)
+#define __NR_mq_timedsend (__X32_SYSCALL_BIT + 242)
+#define __NR_mq_timedreceive (__X32_SYSCALL_BIT + 243)
+#define __NR_mq_getsetattr (__X32_SYSCALL_BIT + 245)
+#define __NR_add_key (__X32_SYSCALL_BIT + 248)
+#define __NR_request_key (__X32_SYSCALL_BIT + 249)
+#define __NR_keyctl (__X32_SYSCALL_BIT + 250)
+#define __NR_ioprio_set (__X32_SYSCALL_BIT + 251)
+#define __NR_ioprio_get (__X32_SYSCALL_BIT + 252)
+#define __NR_inotify_init (__X32_SYSCALL_BIT + 253)
+#define __NR_inotify_add_watch (__X32_SYSCALL_BIT + 254)
+#define __NR_inotify_rm_watch (__X32_SYSCALL_BIT + 255)
+#define __NR_migrate_pages (__X32_SYSCALL_BIT + 256)
+#define __NR_openat (__X32_SYSCALL_BIT + 257)
+#define __NR_mkdirat (__X32_SYSCALL_BIT + 258)
+#define __NR_mknodat (__X32_SYSCALL_BIT + 259)
+#define __NR_fchownat (__X32_SYSCALL_BIT + 260)
+#define __NR_futimesat (__X32_SYSCALL_BIT + 261)
+#define __NR_newfstatat (__X32_SYSCALL_BIT + 262)
+#define __NR_unlinkat (__X32_SYSCALL_BIT + 263)
+#define __NR_renameat (__X32_SYSCALL_BIT + 264)
+#define __NR_linkat (__X32_SYSCALL_BIT + 265)
+#define __NR_symlinkat (__X32_SYSCALL_BIT + 266)
+#define __NR_readlinkat (__X32_SYSCALL_BIT + 267)
+#define __NR_fchmodat (__X32_SYSCALL_BIT + 268)
+#define __NR_faccessat (__X32_SYSCALL_BIT + 269)
+#define __NR_pselect6 (__X32_SYSCALL_BIT + 270)
+#define __NR_ppoll (__X32_SYSCALL_BIT + 271)
+#define __NR_unshare (__X32_SYSCALL_BIT + 272)
+#define __NR_splice (__X32_SYSCALL_BIT + 275)
+#define __NR_tee (__X32_SYSCALL_BIT + 276)
+#define __NR_sync_file_range (__X32_SYSCALL_BIT + 277)
+#define __NR_utimensat (__X32_SYSCALL_BIT + 280)
+#define __NR_epoll_pwait (__X32_SYSCALL_BIT + 281)
+#define __NR_signalfd (__X32_SYSCALL_BIT + 282)
+#define __NR_timerfd_create (__X32_SYSCALL_BIT + 283)
+#define __NR_eventfd (__X32_SYSCALL_BIT + 284)
+#define __NR_fallocate (__X32_SYSCALL_BIT + 285)
+#define __NR_timerfd_settime (__X32_SYSCALL_BIT + 286)
+#define __NR_timerfd_gettime (__X32_SYSCALL_BIT + 287)
+#define __NR_accept4 (__X32_SYSCALL_BIT + 288)
+#define __NR_signalfd4 (__X32_SYSCALL_BIT + 289)
+#define __NR_eventfd2 (__X32_SYSCALL_BIT + 290)
+#define __NR_epoll_create1 (__X32_SYSCALL_BIT + 291)
+#define __NR_dup3 (__X32_SYSCALL_BIT + 292)
+#define __NR_pipe2 (__X32_SYSCALL_BIT + 293)
+#define __NR_inotify_init1 (__X32_SYSCALL_BIT + 294)
+#define __NR_perf_event_open (__X32_SYSCALL_BIT + 298)
+#define __NR_fanotify_init (__X32_SYSCALL_BIT + 300)
+#define __NR_fanotify_mark (__X32_SYSCALL_BIT + 301)
+#define __NR_prlimit64 (__X32_SYSCALL_BIT + 302)
+#define __NR_name_to_handle_at (__X32_SYSCALL_BIT + 303)
+#define __NR_open_by_handle_at (__X32_SYSCALL_BIT + 304)
+#define __NR_clock_adjtime (__X32_SYSCALL_BIT + 305)
+#define __NR_syncfs (__X32_SYSCALL_BIT + 306)
+#define __NR_setns (__X32_SYSCALL_BIT + 308)
+#define __NR_getcpu (__X32_SYSCALL_BIT + 309)
+#define __NR_kcmp (__X32_SYSCALL_BIT + 312)
+#define __NR_finit_module (__X32_SYSCALL_BIT + 313)
+#define __NR_sched_setattr (__X32_SYSCALL_BIT + 314)
+#define __NR_sched_getattr (__X32_SYSCALL_BIT + 315)
+#define __NR_renameat2 (__X32_SYSCALL_BIT + 316)
+#define __NR_seccomp (__X32_SYSCALL_BIT + 317)
+#define __NR_getrandom (__X32_SYSCALL_BIT + 318)
+#define __NR_memfd_create (__X32_SYSCALL_BIT + 319)
+#define __NR_kexec_file_load (__X32_SYSCALL_BIT + 320)
+
+#define __NR_rt_sigaction (__X32_SYSCALL_BIT + 512)
+#define __NR_rt_sigreturn (__X32_SYSCALL_BIT + 513)
+#define __NR_ioctl (__X32_SYSCALL_BIT + 514)
+#define __NR_readv (__X32_SYSCALL_BIT + 515)
+#define __NR_writev (__X32_SYSCALL_BIT + 516)
+#define __NR_recvfrom (__X32_SYSCALL_BIT + 517)
+#define __NR_sendmsg (__X32_SYSCALL_BIT + 518)
+#define __NR_recvmsg (__X32_SYSCALL_BIT + 519)
+#define __NR_execve (__X32_SYSCALL_BIT + 520)
+#define __NR_ptrace (__X32_SYSCALL_BIT + 521)
+#define __NR_rt_sigpending (__X32_SYSCALL_BIT + 522)
+#define __NR_rt_sigtimedwait (__X32_SYSCALL_BIT + 523)
+#define __NR_rt_sigqueueinfo (__X32_SYSCALL_BIT + 524)
+#define __NR_sigaltstack (__X32_SYSCALL_BIT + 525)
+#define __NR_timer_create (__X32_SYSCALL_BIT + 526)
+#define __NR_mq_notify (__X32_SYSCALL_BIT + 527)
+#define __NR_kexec_load (__X32_SYSCALL_BIT + 528)
+#define __NR_waitid (__X32_SYSCALL_BIT + 529)
+#define __NR_set_robust_list (__X32_SYSCALL_BIT + 530)
+#define __NR_get_robust_list (__X32_SYSCALL_BIT + 531)
+#define __NR_vmsplice (__X32_SYSCALL_BIT + 532)
+#define __NR_move_pages (__X32_SYSCALL_BIT + 533)
+#define __NR_preadv (__X32_SYSCALL_BIT + 534)
+#define __NR_pwritev (__X32_SYSCALL_BIT + 535)
+#define __NR_rt_tgsigqueueinfo (__X32_SYSCALL_BIT + 536)
+#define __NR_recvmmsg (__X32_SYSCALL_BIT + 537)
+#define __NR_sendmmsg (__X32_SYSCALL_BIT + 538)
+#define __NR_process_vm_readv (__X32_SYSCALL_BIT + 539)
+#define __NR_process_vm_writev (__X32_SYSCALL_BIT + 540)
+#define __NR_setsockopt (__X32_SYSCALL_BIT + 541)
+#define __NR_getsockopt (__X32_SYSCALL_BIT + 542)
+#define __NR_io_setup (__X32_SYSCALL_BIT + 543)
+#define __NR_io_submit (__X32_SYSCALL_BIT + 544)
+
+#ifdef __PIC__
+#define syscall_weak(name,wsym,sym) \
+.text; \
+.type wsym,@function; \
+.weak wsym; \
+wsym: ; \
+.type sym,@function; \
+.global sym; \
+sym: \
+	mov	$__NR_##name,%al; \
+	jmp	__unified_syscall@PLT
+
+#define syscall(name,sym) \
+.text; \
+.type sym,@function; \
+.global sym; \
+sym: \
+.ifge __NR_##name-256 ; \
+	mov	$__NR_##name,%ax; \
+	jmp	__unified_syscall_16bit@PLT;  \
+.else ; \
+	mov	$__NR_##name,%al; \
+	jmp	__unified_syscall@PLT;  \
+.endif
+
+#else
+
+#define syscall_weak(name,wsym,sym) \
+.text; \
+.type wsym,@function; \
+.weak wsym; \
+wsym: ; \
+.type sym,@function; \
+.global sym; \
+sym: \
+.ifge __NR_##name-256 ; \
+	mov	$__NR_##name,%ax; \
+	jmp	__unified_syscall_16bit;  \
+.else ; \
+	mov	$__NR_##name,%al; \
+	jmp	__unified_syscall;  \
+.endif
+
+#define syscall(name,sym) \
+.text; \
+.type sym,@function; \
+.global sym; \
+sym: \
+.ifge __NR_##name-256 ; \
+	mov	$__NR_##name,%ax; \
+	jmp	__unified_syscall_16bit; \
+.else ; \
+	mov	$__NR_##name,%al; \
+	jmp	__unified_syscall; \
+.endif
+#endif
diff -urN -x .git dietlibc-0.33/x86_64/clone.S dietlibc/x86_64/clone.S
--- dietlibc-0.33/x86_64/clone.S	2005-01-31 12:53:34.000000000 +0000
+++ dietlibc/x86_64/clone.S	2015-01-01 12:14:43.541605560 +0000
@@ -20,8 +20,52 @@
 	movq	%rcx,8(%rsi)	/* thread parameter */
 	movq	%rdi,0(%rsi)	/* thread function */
 
-	/* syscall */
+	/* args to this function:		args to syscall
+	   ----------------------------------------------------
+	   rdi = function to be called		rdi = flags
+	   rsi = child_stack			rsi = child_stack
+	   rdx = flags				rdx = ptid
+	   rcx = arg				r10 = ctid
+	   r8 = ptid				r8 = regs
+	   r9 = tls
+	   stack = ctid */
+
 	movq	%rdx,%rdi
+	/* if CLONE_PARENT_SETTID is set, r8 goes into rdx */
+	test $0x100000,%rdi
+	jz .Lnocps
+	movq	%r8,%rdx
+	/* if CLONE_SETTLS is set, r9 goes into r8 */
+	test $0x80000,%rdi
+	jz .Lcps_notls
+	movq	%r9,%r8
+	/* if CLONE_CHILD_SETTID is set, stack goes into r10 */
+	test $0x1000000,%rdi
+	jz .Ldone
+	movq	8(%rsp),%r10
+	jmp .Ldone
+
+.Lnocps:
+	/* if CLONE_SETTLS is set, r8 goes into r8 */
+	test $0x80000,%rdi
+	jz .Lnocps_notls
+/*	movq	%r8,%r9 */
+.Lcps_notls:
+	/* if CLONE_CHILD_SETTID is set, r9 goes into r10 */
+	test $0x1000000,%rdi
+	jz .Ldone
+	movq	%r9,%r10
+	jmp .Ldone
+
+.Lnocps_notls:
+	/* if CLONE_CHILD_SETTID is set, r8 goes into r10 */
+	test $0x1000000,%rdi
+	jz .Ldone
+	movq	%r8,%r10
+
+.Ldone:
+
+	/* syscall */
 	movl	$__NR_clone,%eax
 	syscall
 	cmpl	$0,%eax
@@ -36,9 +80,9 @@
 	/* exit a thread */
 	movq	%rax,%rdi
 #ifdef __PIC__
-	jmp	_exit@PLT
+	jmp	thrd_exit@PLT
 #else
-	jmp	_exit
+	jmp	thrd_exit
 #endif
 
 .Lclone_error:
diff -urN -x .git dietlibc-0.33/x86_64/dyn_syscalls.S dietlibc/x86_64/dyn_syscalls.S
--- dietlibc-0.33/x86_64/dyn_syscalls.S	2012-01-24 18:24:30.000000000 +0000
+++ dietlibc/x86_64/dyn_syscalls.S	2015-01-01 12:14:43.541605560 +0000
@@ -19,7 +19,7 @@
 .global __unified_syscall_16bit
 __unified_syscall:
 _unified_syscall:
-	mov	$0, %al
+	mov	$0, %ah
 __unified_syscall_16bit:
 	movzwl	%ax, %eax
 	mov	%rcx, %r10
@@ -29,7 +29,12 @@
 	jbe	.Lnoerror
 	negl	%eax
 	pushq	%rax
+#ifdef IN_LDSO
+	call	__errno_location
+	.hidden __errno_location
+#else
 	call	__errno_location@PLT
+#endif
 	popq	%rcx
 	movl	%ecx,(%rax)
 	orq	$-1, %rax
@@ -70,7 +75,6 @@
 #include "../syscalls.s/epoll_create.S"
 #include "../syscalls.s/epoll_ctl.S"
 #include "../syscalls.s/epoll_wait.S"
-#include "../syscalls.s/errno.S"
 #include "../syscalls.s/execve.S"
 #include "../syscalls.s/fchdir.S"
 #include "../syscalls.s/fchmod.S"
@@ -141,7 +145,6 @@
 #include "../syscalls.s/n_sigprocmask.S"
 #include "../syscalls.s/n_sigsuspend.S"
 #include "../syscalls.s/nanosleep.S"
-#include "../syscalls.s/nice.S"
 #include "../syscalls.s/open.S"
 #include "../syscalls.s/pause.S"
 #include "../syscalls.s/personality.S"
@@ -331,3 +334,5 @@
 #include "x86_64/gettimeofday.S"
 
 #include "syscalls.s/__guard.S"
+
+	.section	.note.GNU-stack,"",@progbits
diff -urN -x .git dietlibc-0.33/x86_64/getcontext.S dietlibc/x86_64/getcontext.S
--- dietlibc-0.33/x86_64/getcontext.S	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/x86_64/getcontext.S	2015-01-01 12:14:43.541605560 +0000
@@ -0,0 +1,47 @@
+#include "syscalls.h"
+
+.text
+.global getcontext
+.type getcontext,@function
+/* store current CPU context into struct ucontext* */
+getcontext:
+  /* the registers are in uc_mcontext, which starts at offset 40 */
+  movq %r8,40(%rdi)
+  movq %r9,48(%rdi)
+//  movq %r10,56(%rdi)
+//  movq %r11,64(%rdi)
+  movq %r12,72(%rdi)
+  movq %r13,80(%rdi)
+  movq %r14,88(%rdi)
+  movq %r15,96(%rdi)
+  movq %rdi,104(%rdi)	/* what a useless statement :-) */
+  movq %rsi,112(%rdi)
+  movq %rbp,120(%rdi)
+  movq %rbx,128(%rdi)
+  movq %rdx,136(%rdi)
+  movq $0,144(%rdi)	/* store 0 as value of rax because that's the return value of the function */
+  movq %rcx,152(%rdi)
+  leaq 8(%rsp),%rax
+  movq %rax,160(%rdi)
+  movq (%rsp),%rax
+  movq %rax,168(%rdi)	/* store function return address as rip */
+  lahf
+  movq %rax,176(%rdi)
+  /* valgrind dies if we use these instructions */
+//  movw %cs,184(%rdi)
+//  movw %gs,186(%rdi)
+//  movw %fs,188(%rdi)
+  /* write nothing to err (192) and trapno (200) */
+
+  leaq 424(%rdi),%rax
+  movq %rax,224(%rdi)
+  fnstenv (%rax)
+  fldenv (%rax)
+  stmxcsr 448(%rdi)
+
+  /* now call sigprocmask(SIG_BLOCK, NULL, &uc->uc_sigmask) */
+  leaq 296(%rdi),%rdx
+  xorl %esi,%esi
+  xorl %edi,%edi
+  jmp sigprocmask
+.size getcontext, .-getcontext
diff -urN -x .git dietlibc-0.33/x86_64/gettimeofday.S dietlibc/x86_64/gettimeofday.S
--- dietlibc-0.33/x86_64/gettimeofday.S	2012-01-24 18:24:30.000000000 +0000
+++ dietlibc/x86_64/gettimeofday.S	2015-01-01 12:14:43.541605560 +0000
@@ -1,7 +1,19 @@
+#include "dietfeatures.h"
+#include "syscalls.h"
+
 .text
 .global gettimeofday
 .type gettimeofday,@function
 gettimeofday:
+#ifdef WANT_VALGRIND_SUPPORT
+#ifdef __PIC__
+	mov __valgrind@GOTPCREL(%rip), %rax
+	cmpb $1, (%rax)
+#else
+	cmpb $1, __valgrind(%rip)
+#endif
+	je .Lvalgrind
+#endif
 	movq gtod(%rip), %rax
 	test %rax,%rax
 	jz .L1
@@ -11,13 +23,25 @@
 .L1:
 	push %rsi
 	push %rdi
+#ifdef __PIC__
+	movq __vdso@GOTPCREL(%rip), %rax
+	movq (%rax),%rdi
+	movq funcname@GOTPCREL(%rip), %rsi
+	call vdso_dlsym@PLT
+#else
 	movq __vdso(%rip),%rdi
 	movq $funcname, %rsi
 	call vdso_dlsym
+#endif
 	pop %rdi
 	pop %rsi
 	jmp .L2
 
+#ifdef WANT_VALGRIND_SUPPORT
+.Lvalgrind:
+	mov $__NR_gettimeofday, %al
+	jmp __unified_syscall
+#endif
 .Lhere:
 	.size	 gettimeofday,.Lhere-gettimeofday
 .local gtod
diff -urN -x .git dietlibc-0.33/x86_64/Makefile.add dietlibc/x86_64/Makefile.add
--- dietlibc-0.33/x86_64/Makefile.add	2012-01-24 18:24:30.000000000 +0000
+++ dietlibc/x86_64/Makefile.add	2015-01-01 12:14:43.541605560 +0000
@@ -1,3 +1,8 @@
-CFLAGS := -Os -fstrict-aliasing -momit-leaf-frame-pointer -mfancy-math-387
+ifeq ($(CC),clang)
+CFLAGS := -Os -fstrict-aliasing -momit-leaf-frame-pointer $(EXTRACFLAGS)
+else
+CFLAGS := -Os -fstrict-aliasing -momit-leaf-frame-pointer -mfancy-math-387 -fPIC -fvisibility=hidden $(EXTRACFLAGS)
+endif
 VPATH  := x86_64:syscalls.s:$(VPATH)
-LIBOBJ += $(OBJDIR)/arch_prctl.o $(OBJDIR)/__CAS.o
+LIBOBJ += $(OBJDIR)/arch_prctl.o $(OBJDIR)/__CAS.o $(OBJDIR)/__munmap_and_exit.o $(OBJDIR)/getcontext.o
+LIBOBJ += $(OBJDIR)/setcontext.o
diff -urN -x .git dietlibc-0.33/x86_64/__munmap_and_exit.S dietlibc/x86_64/__munmap_and_exit.S
--- dietlibc-0.33/x86_64/__munmap_and_exit.S	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/x86_64/__munmap_and_exit.S	2015-01-01 12:14:43.541605560 +0000
@@ -0,0 +1,13 @@
+#include "syscalls.h"
+
+.text
+.global __munmap_and_exit
+.type __munmap_and_exit,@function
+__munmap_and_exit:
+  mov $__NR_munmap,%eax
+  syscall
+  mov $__NR_exit,%eax
+  xor %edi,%edi
+  syscall
+.Lhere:
+.size __munmap_and_exit, .Lhere-__munmap_and_exit
diff -urN -x .git dietlibc-0.33/x86_64/setcontext.S dietlibc/x86_64/setcontext.S
--- dietlibc-0.33/x86_64/setcontext.S	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/x86_64/setcontext.S	2015-01-01 12:14:43.541605560 +0000
@@ -0,0 +1,56 @@
+#include "syscalls.h"
+
+.text
+
+.global __setcontext_trampoline
+.type __setcontext_trampoline,@function
+__setcontext_trampoline:
+  movq %rbx,%rdi
+  /* fall through */
+  .size __setcontext_trampoline, .-__setcontext_trampoline
+
+.global setcontext
+.type setcontext,@function
+/* load current CPU context from struct ucontext* */
+setcontext:
+  /* first restore the signal mask, call sigprocmask(SIG_SETMASK,&uc->uc_sigmask,NULL) */
+  movq %rdi,%rbx
+  leaq 296(%rdi),%rsi
+  xorl %edx,%edx
+  movl $2,%edi
+  call sigprocmask
+  mov %rbx,%rdi
+  test %rax,%rax
+  jc .Lexit
+
+  /* now the floating point context */
+  movq 224(%rdi),%rax
+  fldenv (%rax)
+  ldmxcsr 448(%rdi)
+
+  /* the registers are in uc_mcontext, which starts at offset 40 */
+  movq 40(%rdi),%r8
+  movq 48(%rdi),%r9
+  movq 72(%rdi),%r12
+  movq 80(%rdi),%r13
+  movq 88(%rdi),%r14
+  movq 96(%rdi),%r15
+
+  movq 112(%rdi),%rsi
+  movq 120(%rdi),%rbp
+  movq 128(%rdi),%rbx
+  movq 136(%rdi),%rdx
+  movq 152(%rdi),%rcx
+  movq 160(%rdi),%rsp
+  pushq 168(%rdi)	/* push return value so ret goes to the right place */
+
+//  movw 186(%rdi),%gs
+//  movw 188(%rdi),%fs
+
+  movq 104(%rdi),%rdi
+
+  xorl %eax,%eax
+
+.Lexit:
+  ret
+.size setcontext, .-setcontext
diff -urN -x .git dietlibc-0.33/x86_64/start.S dietlibc/x86_64/start.S
--- dietlibc-0.33/x86_64/start.S	2012-11-02 11:17:28.000000000 +0000
+++ dietlibc/x86_64/start.S	2015-01-01 12:14:43.541605560 +0000
@@ -12,11 +12,28 @@
 	
 	leaq	8(%rsi,%rdi,8),%rdx	/* %rdx = envp = (8*rdi)+%rsi+8 */
 
+#ifndef IN_LDSO
+#ifdef WANT_ELFINFO
+#ifdef __DYN_LIB
+	movq	environ@GOTPCREL(%rip), %rax
+#else
+	leaq	environ(%rip), %rax
+#endif
+	movq	%rdx, (%rax)	/* environ */
+
+1:	add	$8, %rdx	/* increment envp */
+	cmpq	$0, -8(%rdx)	/* load envp[-1] */
+	jne	1b		/* ... until envp[-1]==NULL */
+
+	movq	%rdx, 8(%rax)	/* __elfinfo */
+#else
 #ifdef __DYN_LIB
 	movq	environ@GOTPCREL(%rip), %rax
 	movq	%rdx, (%rax)
 #else
 	movq	%rdx, environ(%rip)
+	.hidden environ
+#endif
 #endif
 
 #ifdef PROFILING
@@ -37,8 +54,10 @@
 
 #ifdef WANT_DYNAMIC
 	call	_dyn_start
+	.hidden _dyn_start
 #else
 	call	CALL_IN_STARTCODE
+	.hidden CALL_IN_STARTCODE
 #endif
 
 #ifdef PROFILING
@@ -48,14 +67,22 @@
 #else
 	movq	%rax, %rdi	/* return value */
 #endif
+
+#else
+	call	main
+	.hidden main
+#endif
+
 #if defined(__ILP32__)
-	xor %rax,%rax		/* do exit inline with x64 syscall number so it also works if the kernel does not have x32 support */
-	inc %rax
+	mov	$SYS_exit,%eax
 	syscall
 #else
 	call	exit
+#ifndef __DYN_LIB
+	.hidden exit
+#endif
 #endif
 	hlt
 .Lstart:
 	.size	 _start,.Lstart-_start
-
+	.section	.note.GNU-stack,"",@progbits
diff -urN -x .git dietlibc-0.33/x86_64/syscalls.h dietlibc/x86_64/syscalls.h
--- dietlibc-0.33/x86_64/syscalls.h	2012-01-24 18:24:30.000000000 +0000
+++ dietlibc/x86_64/syscalls.h	2015-01-01 12:14:43.541605560 +0000
@@ -349,6 +349,24 @@
 #define __NR_fanotify_init	300
 #define __NR_fanotify_mark	301
 #define __NR_prlimit64		302
+#define __NR_name_to_handle_at 303
+#define __NR_open_by_handle_at 304
+#define __NR_clock_adjtime 305
+#define __NR_syncfs 306
+#define __NR_sendmmsg 307
+#define __NR_setns 308
+#define __NR_getcpu 309
+#define __NR_process_vm_readv 310
+#define __NR_process_vm_writev 311
+#define __NR_kcmp 312
+#define __NR_finit_module 313
+#define __NR_sched_setattr 314
+#define __NR_sched_getattr 315
+#define __NR_renameat2 316
+#define __NR_seccomp 317
+#define __NR_getrandom 318
+#define __NR_memfd_create 319
+#define __NR_kexec_file_load 320
 
 #ifdef __PIC__
 #define syscall_weak(name,wsym,sym) \
@@ -359,8 +377,13 @@
 .type sym,@function; \
 .global sym; \
 sym: \
+.ifge __NR_##name-256 ; \
+	mov	$__NR_##name,%ax; \
+	jmp	__unified_syscall_16bit@PLT;  \
+.else ; \
 	mov	$__NR_##name,%al; \
-	jmp	__unified_syscall@PLT
+	jmp	__unified_syscall@PLT; \
+.endif
 
 #define syscall(name,sym) \
 .text; \
@@ -369,10 +392,10 @@
 sym: \
 .ifge __NR_##name-256 ; \
 	mov	$__NR_##name,%ax; \
-	jmp	__unified_syscall_16bit@PLT;  \
+	jmp	__unified_syscall_16bit@PLT; \
 .else ; \
 	mov	$__NR_##name,%al; \
-	jmp	__unified_syscall@PLT;  \
+	jmp	__unified_syscall@PLT; \
 .endif
 
 #else
@@ -387,10 +410,10 @@
 sym: \
 .ifge __NR_##name-256 ; \
 	mov	$__NR_##name,%ax; \
-	jmp	__unified_syscall_16bit;  \
+	jmp	__unified_syscall_16bit; \
 .else ; \
 	mov	$__NR_##name,%al; \
-	jmp	__unified_syscall;  \
+	jmp	__unified_syscall; \
 .endif
 
 #define syscall(name,sym) \
diff -urN -x .git dietlibc-0.33/x86_64/__time.S dietlibc/x86_64/__time.S
--- dietlibc-0.33/x86_64/__time.S	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc/x86_64/__time.S	2015-01-01 12:14:43.541605560 +0000
@@ -0,0 +1,11 @@
+/* implement time(2) via gettimeofday(2) on x86-64 because gettimeofday
+   is a vsyscall (i.e. no actual switch to kernel mode) */
+.text
+.global time
+.type time,@function
+time:
+	mov	$0xffffffffff600400,%rax
+	call	*%rax
+	ret
+.Lhere:
+	.size	 time,.Lhere-time
diff -urN -x .git dietlibc-0.33/x86_64/time.S dietlibc/x86_64/time.S
--- dietlibc-0.33/x86_64/time.S	2012-01-24 18:24:30.000000000 +0000
+++ dietlibc/x86_64/time.S	2015-01-01 12:14:43.541605560 +0000
@@ -1,11 +1 @@
-/* implement time(2) via gettimeofday(2) on x86-64 because gettimeofday
-   is a vsyscall (i.e. no actual switch to kernel mode) */
-.text
-.global time
-.type time,@function
-time:
-	mov	$0xffffffffff600400,%rax
-	call	*%rax
-	ret
-.Lhere:
-	.size	 time,.Lhere-time
+/* avoid empty source file */
diff -urN -x .git dietlibc-0.33/x86_64/unified.S dietlibc/x86_64/unified.S
--- dietlibc-0.33/x86_64/unified.S	2012-11-02 11:17:29.000000000 +0000
+++ dietlibc/x86_64/unified.S	2015-01-01 12:14:43.541605560 +0000
@@ -13,12 +13,14 @@
 .global __error_unified_syscall
 .global __unified_syscall
 .global __unified_syscall_16bit
+.global __unified_syscall_lp64
 __unified_syscall:
 	mov	$0, %ah
 __unified_syscall_16bit:
 	movzwl	%ax, %eax
 #if defined(__ILP32__)
 	or	$0x40000000, %eax
+__unified_syscall_lp64:
 #endif
 	mov	%rcx, %r10
 	syscall
@@ -28,6 +30,9 @@
 	negl	%eax
 	pushq	%rax
 	call	__errno_location
+#ifdef IN_LDSO
+	.hidden __errno_location
+#endif
 	popq	%rcx
 	movl	%ecx,(%rax)
 	orq	$-1, %rax
